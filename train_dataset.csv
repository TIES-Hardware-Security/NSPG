property,sentence
0,The debug system follows the execution-based debug approach described in the RISC-V Debug Specification 0.13.2 and provides the following features.
0,This module provides a RISC-V Debug Specification-compliant debug system with TileLink Uncached Light bus interfaces.
0,"The main functionality is provided by the PULP RISC-V Debug System, which is instantiated by this module."
0,All bus interfaces are converted into TL-UL.
0,See the PULP RISC-V Debug System Documentation for a full list of features and further design documentation.
0,This document only describes the additional logic provided on top of the PULP RISC-V Debug System.
0,"Referring to the Comportable guideline for peripheral device functionality, the module rv_dm has the following hardware interfaces defined."
0,This is a latched version of the lc_hw_debug_en signal and is only used to gate the JTAG / TAP side of the RV_DM.
0,This signal indicates whether the debug module is active and can be used to prevent power down of the core and bus-attached peripherals.
0,The debug module is enabled with the LC_HW_DEBUG_EN signal.
0,This enablement is implemented by gating / enabling critical blocks with separately buffered copies of the life cycle signal.
0,"This comprises the debug module interface (DMI) attached to the TAP, the reset request line, the system bus access module (SBA), the debug request output, the TL-UL adapter for the debug ROM, and the ifetch indicator being fed into the TL-UL adapter for the debug ROM."
0,Debug system functionality is controlled by the HW_DEBUG_EN function of the life cycle controller.
0,The debug system provides a standard JTAG (IEEE Std 1149.1-2013) port for external debug access.
0,All JTAG logic is clocked with an externally supplied test clock (tck).
0,The protocol used for this JTAG port is specified in the RISC-V Debug Specification as JTAG Debug Transport Module (DTM).
0,It is up to the larger system design to specify which parts of the system are actually reset by this signal.
0,The dmactive_o signals that some kind of debugging is ongoing.
0,"Use this signal to prevent the power down of the core and bus-attached peripherals, which might be accessed by the debug system."
0,Most communication between the core and the debug system is performed through the debug memory.
0,"To enter debug mode due to an external debug request, the debug system provides a debug_req_o interrupt."
1,"If the core is unavailable to the debug system, e.g. because it is powered down or in a locked-down state, the unavailable_i signal can signal this condition to the debug system."
0,The debug system implements execution-based debug according to the RISC-V Debug Specification.
0,"Most interactions between the core and the debug system are performed through the debug memory, a bus-exposed memory."
0,The memory needs to be accessible from the core instruction and data interfaces.
0,A full memory map is part of the PULP RISC-V Debug System Documentation.
0,"Bus-attached peripherals can be accessed through the debug system, a functionality called System Bus Access (SBA) in the RISC-V Debug Specification."
0,It is up to the interconnect fabric to decide which peripherals are actually accessible.
0,The debug system wrapper provides a TL-UL host bus interface for SBA.
0,The RISC-V Instruction Set Manual Volume II: Privileged Architecture Privileged Architecture Version 1.10 Warning!
0,This draft specification may change before being accepted as standard by the RISC-V Foundation.
0,"While the editors intend future changes to this specification to be forward compatible, it remains possible that implementations made to this draft specification will not conform to the future standard."
0,Contributors to all versions of the spec in alphabetical order (please contact editors to suggest corrections):
0,"Krste Asanovi´c, Rimas Avizienis, Jacob Bachmeyer, Allen J. Baum, Paolo Bonzini, Ruslan Bukin, Christopher Celio, David Chisnall, Anthony Coulter, Palmer Dabbelt, Monte Dalrymple, Dennis Ferguson, Mike Frysinger, John Hauser, David Horner, Olof Johansson, Yunsup Lee, Andrew Lutomirski, Jonathan Neusch¨afer, Rishiyur Nikhil, Stefan O'Rear, Albert Ou, John Ousterhout, David Patterson, Colin Schmidt, Wesley Terpstra, Matt Thomas, Tommy Thorn, Ray VanDeWalker, Megan Wachs, Andrew Waterman, and Reinoud Zandijk."
0,This document is released under a Creative Commons Attribution 4.0 International License.
0,"This document is a derivative of the RISC-V privileged specification version 1.9.1 released under following license: c 2010-2017 Andrew Waterman, Yunsup Lee, Rimas Avizienis, David Patterson, Krste Asanovi´c."
0,Creative Commons Attribution 4.0 International License.
0,"Please cite as: The RISC-V Instruction Set Manual, Volume II: Privileged Architecture, Version 1.10, Editors Andrew Waterman and Krste Asanovi´c, RISC-V Foundation, May 2017."
0,This is version 1.10 of the RISC-V privileged architecture proposal.
0,"Changes from version 1.9.1 include: 4.0 International Licence by the original authors, and this and future versions of this document will be released under the same licence."
0,The explicit convention on shadow CSR addresses has been removed to reclaim CSR space.
0,Shadow CSRs can still be added as needed.
0,The mvendorid register now contains the JEDEC code of the core provider as opposed to a code supplied by the Foundation.
0,This avoids redundancy and offloads work from the Foundation.
0,"An optional mechanism to change the base ISA used by supervisor and user modes has been added to the mstatus CSR, and the field previously called Base in misa has been renamed to MXL for consistency."
0,Clarified expected use of XS to summarize additional extension state status fields in mstatus.
0,Optional vectored interrupt support has been added to the mtvec and stvec CSRs.
0,The SEIP and UEIP bits in the mip CSR have been redefined to support software injection of external interrupts.
0,The mbadaddr register has been subsumed by a more general mtval register that can now capture bad instruction bits on an illegal instruction fault to speed instruction emulation.
0,The machine-mode base-and-bounds translation and protection schemes have been removed from the specification as part of moving the virtual memory configuration to sptbr (now satp).
0,"Some of the motivation for the base and bound schemes are now covered by the PMP registers, but space remains available in mstatus to add these back at a later date if deemed useful."
1,"In systems with only M-mode, or with both M-mode and U-mode but without U-mode trap support, the medeleg and mideleg registers now do not exist, whereas previously they returned zero."
0,Virtual-memory page faults now have mcause values distinct from physical-memory access exceptions.
0,Page-fault exceptions can now be delegated to S-mode without delegating exceptions generated by PMA and PMP checks.
0,The supervisor virtual memory configuration has been moved from the mstatus register to the sptbr register.
0,"Accordingly, the sptbr register has been renamed to satp (Supervisor"
0, The SFENCE.VM instruction has been removed in favor of the improved SFENCE.VMA instruction.
0,The mstatus bit MXR has been exposed to S-mode via sstatus.
0,The polarity of the PUM bit in sstatus has been inverted to shorten code sequences involving MXR.
0,The bit has been renamed to SUM.
0,Hardware management of page-table entry Accessed and Dirty bits has been made optional; simpler implementations may trap to software to set them.
0,"The counter-enable scheme has changed, so that S-mode can control availability of counters to U-mode."
0,"H-mode has been removed, as we are focusing on recursive virtualization support in S-mode."
0,The encoding space has been reserved and may be repurposed at a later date.
0,A mechanism to improve virtualization performance by trapping S-mode virtual-memory management operations has been added.
0,"The Supervisor Binary Interface (SBI) chapter has been removed, so that it can be maintained as a separate specification."
0,This is version 1.9.1 of the RISC-V privileged architecture proposal.
0,Changes from version 1.9 include:
0,Change configuration string proposal to be use a search process that supports various formats including Device Tree String and flattened Device Tree.
0,Made misa optionally writable to support modifying base and supported ISA extensions.
0,CSR address of misa changed.
0,Added a hardware performance monitoring scheme.
0,"Simplified the handling of existing hardware counters, removing privileged versions of the counters and the corresponding delta registers."
0,3.1.7 Privilege and Global Interrupt-Enable Stack in mstatus register	20
0,This is a draft of the privileged architecture description document for RISC-V.
0,Changes will occur before the final release.
0,"This document describes the RISC-V privileged architecture, which covers all aspects of RISC-V systems beyond the user-level ISA, including privileged instructions as well as additional functionality required for running operating systems and attaching external devices."
0,"Commentary on our design decisions is formatted as in this paragraph, and can be skipped if the reader is only interested in the specification itself."
0,"We briefly note that the entire privileged-level design described in this document could be replaced with an entirely different privileged-level design without changing the user-level ISA, and possibly without even changing the ABI."
0,"In particular, this privileged specification was designed to run existing popular operating systems, and so embodies the conventional level-based protection model."
0,Alternate privileged specifications could embody other more flexible protection-domain models.
0,"A RISC-V hardware platform can contain one or more RISC-V-compatible processing cores together with other non-RISC-V-compatible cores, fixed-function accelerators, various physical memory structures, I/O devices, and an interconnect structure to allow the components to communicate."
1,A component is termed a core if it contains an independent instruction fetch unit.
0,A RISC-V core might have additional specialized instruction set extensions or an added coprocessor.
0,"We use the term coprocessor to refer to a unit that is attached to a RISC-V core and is mostly sequenced by a RISC-V instruction stream, but which contains additional architectural state and instruction set extensions, and possibly some limited autonomy relative to the primary RISC-V instruction stream."
0,We use the term accelerator to refer to either a non-programmable fixed-function unit or a core that can operate autonomously but is specialized for certain tasks.
0,"In RISC-V systems, we expect many programmable accelerators will be RISC-V-based cores with specialized instruction set extensions and/or customized coprocessors."
0,"An important class of RISC-V accelerators are I/O accelerators, which offload I/O processing tasks from the main application cores."
0,The system-level organization of a RISC-V hardware platform can range from a single-core microcontroller to a many-thousand-node cluster of shared-memory manycore server nodes.
0,Even small systems-on-a-chip might be structured as a hierarchy of multicomputers and/or multiprocessors to modularize development effort or to provide secure isolation between subsystems.
0,This document focuses on the privileged architecture visible to each hart (hardware thread) running within a uniprocessor or a shared-memory multiprocessor.
0,This section describes the terminology we use to describe components of the wide range of possible privileged software stacks for RISC-V.
0,Figure 1.1 shows some of the possible software stacks that can be supported by the RISC-V architecture.
0,The left-hand side shows a simple system that supports only a single application running on an application execution environment (AEE).
0,The application is coded to run with a particular application binary interface (ABI).
0,The ABI includes the supported user-level ISA plus a set of ABI calls to interact with the AEE.
0,The ABI hides details of the AEE from the application to allow greater flexibility in implementing the AEE.
0,"The same ABI could be implemented natively on multiple different host OSs, or could be supported by a user-mode emulation environment running on a machine with a different native ISA."
0,Figure 1.1: Different implementation stacks supporting various forms of privileged execution.
0,separate them from concrete instances of components implementing the interfaces.
0,The middle configuration shows a conventional operating system (OS) that can support multiprogrammed execution of multiple applications.
0,"Each application communicates over an ABI with the OS, which provides the AEE."
0,"Just as applications interface with an AEE via an ABI, RISC-V operating systems interface with a supervisor execution environment (SEE) via a supervisor binary interface (SBI)."
0,An SBI comprises the user-level and supervisor-level ISA together with a set of
0,Using a single SBI across all SEE implementations allows a single OS binary image to run on any SEE.
0,"The SEE can be a simple boot loader and BIOS-style IO system in a low-end hardware platform, or a hypervisor-provided virtual machine in a high-end server, or a thin translation layer over a host operating system in an architecture simulation environment."
0,"Most supervisor-level ISA definitions do not separate the SBI from the execution environment and/or the hardware platform, complicating virtualization and bring-up of new hardware platforms."
0,The rightmost configuration shows a virtual machine monitor configuration where multiple multiprogrammed OSs are supported by a single hypervisor.
0,"Each OS communicates via an SBI with the hypervisor, which provides the SEE."
0,"The hypervisor communicates with the hypervisor execution environment (HEE) using a hypervisor binary interface (HBI), to isolate the hypervisor from details of the hardware platform."
0,"The ABI, SBI, and HBI are still a work-in-progress, but we are now prioritizing support for Type-2 hypervisors where the SBI is provided recursively by an S-mode OS."
0,"Hardware implementations of the RISC-V ISA will generally require additional features beyond the privileged ISA to support the various execution environments (AEE, SEE, or HEE)."
1,"At any time, a RISC-V hardware thread (hart) is running at some privilege level encoded as a mode in one or more CSRs (control and status registers)."
0,Three RISC-V privilege levels are currently defined as shown in Table 1.1.
0,"Privilege levels are used to provide protection between different components of the software stack, and attempts to perform operations not permitted by the current privilege mode will cause an exception to be raised."
0,These exceptions will normally cause traps into an underlying execution environment.
0,The machine level has the highest privileges and is the only mandatory privilege level for a RISC-V hardware platform.
0,"Code run in machine-mode (M-mode) is usually inherently trusted, as it has low-level access to the machine implementation."
0,M-mode can be used to manage secure execution environments on RISC-V. User-mode (U-mode) and supervisor-mode (S-mode) are intended for conventional application and operating system usage respectively.
0,S mode suitable for both Type-1 and Type-2 hypervisors as described in Chapter 5.
0,The encoding space for H is reserved for future use and to avoid backwards incompatible changes in bit positions in various status regusters.
0,The bit positions might be reused in the future for different Type-1 hypervisor support or possibly additional secure execution modes.
0,Each privilege level has a core set of privileged ISA extensions with optional extensions and variants.
0,"For example, machine-mode supports several optional standard variants for address translation and memory protection."
0,"Also, supervisor-mode can be extended to support Type-2 hypervisor execution as described in Chapter 5."
0,"Implementations might provide anywhere from 1 to 3 privilege modes trading off reduced isolation for lower implementation cost, as shown in Table 1.2."
0,"In the description, we try to separate the privilege level for which code is written, from the privilege mode in which it runs, although the two are often tied."
0,"For example, a supervisorlevel operating system can run in supervisor-mode on a system with three privilege modes, but can also run in user-mode under a classic virtual machine monitor on systems with two or more privilege modes."
0,"In both cases, the same supervisor-level operating system binary code can be used, coded to a supervisor-level SBI and hence expecting to be able to use supervisor-level privileged instructions and CSRs."
1,"When running a guest OS in user mode, all supervisor-level actions will be trapped and emulated by the SEE running in the higher-privilege level."
1,"All hardware implementations must provide M-mode, as this is the only mode that has unfettered access to the whole machine."
0,"The simplest RISC-V implementations may provide only M-mode, though this will provide no protection against incorrect or malicious application code."
0,The lock feature of the optional PMP facility can provide some limited protection even with only M-mode implemented.
0,Many RISC-V implementations will also support at least user mode (U-mode) to protect the rest of the system from application code.
0,Supervisor mode (S-mode) can be added to provide isolation between a supervisor-level operating system and the SEE.
1,"A hart normally runs application code in U-mode until some trap (e.g., a supervisor call or a timer interrupt) forces a switch to a trap handler, which usually runs in a more privileged mode."
1,"The hart will then execute the trap handler, which will eventually resume execution at or after the original trapped instruction in U-mode."
0,"Traps that increase privilege level are termed vertical traps, while traps that remain at the same privilege level are termed horizontal traps."
0,The RISC-V privileged architecture provides flexible routing of traps to different privilege layers.
0,Horizontal traps can be implemented as vertical traps that return control to a horizontal trap handler in the less-privileged mode.
0,Implementations may also include a debug mode to support off-chip debugging and/or manufacturing test.
0,"Debug mode (D-mode) can be considered an additional privilege mode, with even more access than M-mode."
0,The separate debug specification proposal describes operation of a RISC-V hart in debug mode.
0,"Debug mode reserves a few CSR addresses that are only accessible in D-mode, and may also reserve some portions of the physical memory space on a platform."
0,The SYSTEM major opcode is used to encode all privileged instructions in the RISC-V ISA.
0,"These can be divided into two main classes: those that atomically read-modify-write control and status registers (CSRs), and all other privileged instructions."
0,"In addition to the user-level state described in Volume I of this manual, an implementation may contain additional CSRs, accessible by some subset of the privilege levels using the CSR instructions described in the user-level manual."
0,"In this chapter, we map out the CSR address space."
0,"The following chapters describe the function of each of the CSRs according to privilege level, as well as the other privileged instructions which are generally closely associated with a particular privilege level."
0,"Note that although CSRs and instructions are associated with one privilege level, they are also accessible at all higher privilege levels."
0,"The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up to 4,096 CSRs."
0,"By convention, the upper 4 bits of the CSR address (csr[11:8]) are used to encode the read and write accessibility of the CSRs according to privilege level as shown in Table 2.1."
0,"The top two bits (csr[11:10]) indicate whether the register is read/write (00, 01, or 10) or read-only (11)."
0,The next two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.
0,The CSR address convention uses the upper bits of the CSR address to encode default access privileges.
0,"This simplifies error checking in the hardware and provides a larger CSR space, but does constrain the mapping of CSRs into the address space."
0, Implementations might allow a more-privileged level to trap otherwise permitted CSR accesses by a less-privileged level to allow these accesses to be intercepted.
0,This change should be transparent to the less-privileged software.
1,Attempts to access a non-existent CSR raise an illegal instruction exception.
1,Attempts to access a CSR without appropriate privilege level or to write a read-only register also raise illegal instruction exceptions.
1,"A read/write register might also contain some bits that are read-only, in which case writes to the read-only bits are ignored."
0,Table 2.1 also indicates the convention to allocate CSR addresses between standard and nonstandard uses.
0,The CSR addresses reserved for non-standard uses will not be redefined by future standard extensions.
0,We have dropped the explicit allocation of CSR space for shadow CSRs to leave more flexibility for allocated other CSRs.
0,Shadow CSRs can still be added in the appropriate R/W space.
0,The counters are the only shadowed CSRs in the current spec.
0, Shadows CSRs provide a read-write address via which a higher privilege level can modify a register that is read-only at a lower privilege level.
1,"Note that if one privilege level has already allocated a read/write shadow address, then any higher privilege level can use the same CSR address for read/write access to the same register."
0," Effective virtualization requires that as many instructions run natively as possible inside a virtualized environment, while any privileged accesses trap to the virtual machine monitor [1]."
0,CSRs that are read-only at some lower privilege level are shadowed into separate CSR addresses if they are made read-write at a higher privilege level.
0,This avoids trapping permitted lowerprivilege accesses while still causing traps on illegal accesses.
1,Machine-mode standard read-write CSRs 0x7A0-0x7BF are reserved for use by the debug system.
1,Implementations should raise illegal instruction exceptions on machine-mode access to these registers.
0,Tables 2.2-2.5 list the CSRs that have currently been allocated CSR addresses.
0,"The timers, counters, and floating-point CSRs are standard user-level CSRs, as well as the additional user trap registers added by the N extension."
0,"The other registers are used by privileged code, as described in the following chapters."
0,Note that not all registers are required on all implementations.
0,"Physical memory protection configuration, RV32 only."
0,Physical memory protection configuration.
0,"Physical memory protection configuration, RV32 only."
0,Physical memory protection address register.
0,Machine performance-monitoring counter.
0,"Upper 32 bits of mcycle, RV32I only."
0,"Upper 32 bits of minstret, RV32I only."
0,"Upper 32 bits of mhpmcounter3, RV32I only."
0,"Upper 32 bits of mhpmcounter4, RV32I only."
0,The following definitions and abbreviations are used in specifying the behavior of fields within the CSRs.
1,Some read-only and read/write registers have read-only fields reserved for future use.
1,These reserved read-only fields should be ignored on a read.
1,"Writes to these fields have no effect, unless the whole CSR is read-only, in which case writes might raise an illegal instruction exception."
1,These fields are labeled WIRI in the register descriptions.
1,Some whole read/write fields are reserved for future use.
1,"Software should ignore the values read from these fields, and should preserve the values held in these fields when writing values to other fields of the same register."
1,These fields are labeled WPRI in the register descriptions.
1,"To simplify the software model, any backward-compatible future definition of previously reserved fields within a CSR must cope with the possibility that a non-atomic read/modify/write sequence is used to update other fields in the CSR."
1,"Alternatively, the original CSR definition must specify that subfields can only be updated atomically, which may require a two-instruction clear bit/set bit sequence in general that can be problematic if intermediate values are not legal."
1,"Some read/write CSR fields specify behavior for only a subset of possible bit encodings, with other bit encodings reserved."
1,"Software should not write anything other than legal values to such a field, and should not assume a read will return a legal value unless the last write was of a legal value, or the register has not been written since another operation (e.g., reset) set the register to a legal value."
1,These fields are labeled WLRL in the register descriptions.
1,"Hardware implementations need only implement enough state bits to differentiate between the supported values, but must always return the complete specified bit-encoding of any supported value when read."
1,Implementations are permitted but not required to raise an illegal instruction exception if an instruction attempts to write a non-supported value to a CSR field.
1,"Hardware implementations can return arbitrary bit patterns on the read of a CSR field when the last write was of an illegal value, but the value returned should deterministically depend on the previous written value."
1,"Some read/write CSR fields are only defined for a subset of bit encodings, but allow any value to be written while guaranteeing to return a legal value whenever read."
1,"Assuming that writing the CSR has no other side effects, the range of supported values can be determined by attempting to write a desired setting then reading to see if the value was retained."
1,These fields are labeled WARL in the register descriptions.
1,Implementations will not raise an exception on writes of unsupported values to an WARL field.
1,Implementations must always deterministically return the same legal value after a given illegal value is written.
0,"This chapter describes the machine-level operations available in machine-mode (M-mode), which is the highest privilege mode in a RISC-V system."
0,M-mode is the only mandatory privilege mode in a RISC-V hardware implementation.
0,M-mode is used for low-level access to a hardware platform and is the first mode entered at reset.
0,M-mode can also be used to implement features that are too difficult or expensive to implement in hardware directly.
0,The RISC-V machine-level ISA contains a common core that is extended depending on which other privilege levels are supported and other details of the hardware implementation.
1,"In addition to the machine-level CSRs described in this section, M-mode code can access all CSRs at lower privilege levels."
1,The misa CSR is an XLEN-bit WARL read-write register reporting the ISA supported by the hart.
1,"This register must be readable in any implementation, but a value of zero can be returned to indicate the misa register has not been implemented, requiring that CPU capabilities be determined through a separate non-standard mechanism."
0,The MXL (Machine XLEN) field encodes the native base integer ISA width as shown in Table 3.1.
0,The MXL field may be writable in implementations that support multiple base ISA widths.
1,"The effective XLEN in M-mode, M-XLEN, is given by the setting of MXL, or has a fixed value if misa is zero."
1,The MXL field is always set to the widest supported ISA variant at reset.
0,"The base width can be quickly ascertained using branches on the sign of the returned misa value, and possibly a shift left by one and a second branch on the sign."
0,These checks can be written in assembly code without knowing the register width (XLEN) of the machine.
0,The base width is then shifting the register left by 31 bits at a time.
0,"If zero after one shift, then the machine is RV32."
0,"If zero after two shifts, then the machine is RV64, else RV128."
1,"When MXL is set to a value less than the widest supported XLEN, all operations must ignore source operand register bits above the configured XLEN, and must sign-extend results to fill the entire widest supported XLEN in the destination register."
1,We require that operations always fill the entire underlying hardware registers with defined values to avoid implementation-defined behavior.
1,"The Extensions field encodes the presence of the standard extensions, with a single bit per letter of the alphabet (bit 0 encodes presence of extension A , bit 1 encodes presence of extension B, through to bit 25 which encodes Z)."
1,"The I bit will be set for RV32I, RV64I, RV128I base ISAs, and the E bit will be set for RV32E."
1,The Extension is a WARL field that can contain writable bits where the implementation allows the supported ISA to be modified.
1,"At reset, the Extension field should contain the maximal set of supported extensions, and I should be selected over E if both are available."
1,The G bit is used as an escape to allow expansion to a larger space of standard extension names.
1,reserve the bit to indicate that additional standard extensions are present.
1,The U and S bits will be set if there is support for user and supervisor modes respectively.
1,The X bit will be set if there are any non-standard extensions.
0,The misa CSR exposes a rudimentary catalog of CPU features to machine-mode code.
0,"More extensive information can be obtained in machine mode by probing other machine registers, and examining other ROM storage in the system as part of the boot process."
0, We require that lower privilege levels execute environment calls instead of reading CPU registers to determine features available at each privilege level.
0,"This enables virtualization layers to alter the ISA observed at any level, and supports a much richer command interface without burdening hardware designs."
0,Table 3.2: Encoding of Extensions field in misa.
1,All bits that are reserved for future use must return zero when read.
0,The mvendorid CSR is an XLEN-bit read-only register providing the JEDEC manufacturer ID of the provider of the core.
1,"This register must be readable in any implementation, but a value of 0 can be returned to indicate the field is not implemented or that this is a non-commercial implementation."
0,"JEDEC manufacturer IDs are ordinarily encoded as a sequence of one-byte continuation codes 0x7f, terminated by a one-byte ID not equal to 0x7f, with an odd parity bit in the most-significant bit of each byte."
0,"mvendorid encodes the number of one-byte continuation codes in the Bank field, and encodes the final byte in the Offset field, discarding the parity bit."
0,"For example, the JEDEC manufacturer ID 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x8a (twelve continuation codes followed by 0x8a) would be encoded in the mvendorid field as 0x60a."
0,"Previously the vendor ID was to be a number allocated by the RISC-V Foundation, but this duplicates the work of JEDEC in maintaining a manufacturer ID standard."
0,"At time of writing, registering a manufacturer ID with JEDEC has a one-time cost of $500."
1,The marchid CSR is an XLEN-bit read-only register encoding the base microarchitecture of the hart.
1,"This register must be readable in any implementation, but a value of 0 can be returned to indicate the field is not implemented."
1,The combination of mvendorid and marchid should uniquely identify the type of hart microarchitecture that is implemented.
0,"Open-source project architecture IDs are allocated globally by the RISC-V Foundation, and have non-zero architecture IDs with a zero most-significant-bit (MSB)."
1,"Commercial architecture IDs are allocated by each commercial vendor independently, but must have the MSB set and cannot contain zero in the remaining XLEN-1 bits."
0,The intent is for the architecture ID to represent the microarchitecture associated with the repo around which development occurs rather than a particular organization.
0,Commercial fabrications of open-source designs should (and might be required by the license to) retain the original architecture ID.
0,"This will aid in reducing fragmentation and tool support costs, as well as provide attribution."
0,"Open-source architecture IDs should be administered by the Foundation and should only be allocated to released, functioning open-source projects."
0,Commercial architecture IDs can be managed independently by any registered vendor but are required to have IDs disjoint from the open-source architecture IDs (MSB set) to prevent collisions if a vendor wishes to use both closed-source and open-source microarchitectures.
0," The convention adopted within the following Implementation field can be used to segregate branches of the same architecture design, including by organization."
0,"The misa register also helps distinguish different variants of a design, as does the configuration string if present."
1,The mimpid CSR provides a unique encoding of the version of the processor implementation.
1,"This register must be readable in any implementation, but a value of 0 can be returned to indicate that the field is not implemented."
0,The Implementation value should reflect the design of the RISC-V processor itself and not any surrounding system.
0,"be printed by standard tools as a hexadecimal string without any leading or trailing zeros, so the Implementation value can be left-justified (i.e., filled in from most-significant nibble down) with subfields aligned on nibble boundaries to ease human readability."
1,The mhartid CSR is an XLEN-bit read-only register containing the integer ID of the hardware thread running the code.
1,This register must be readable in any implementation.
1,"Hart IDs might not necessarily be numbered contiguously in a multiprocessor system, but at least one hart must have a hart ID of zero."
0,"In certain cases, we must ensure exactly one hart runs some code (e.g., at reset), and so require one hart to have a known hart ID of zero."
0," For efficiency, system implementers should aim to reduce the magnitude of the largest hart ID used in a system."
0,The mstatus register is an XLEN-bit read/write register formatted as shown in Figure 3.6 for RV32 and Figure 3.7 for RV64 and RV128.
1,The mstatus register keeps track of and controls the hart's current operating state.
1,Restricted views of the mstatus register appear as the sstatus and ustatus registers in the S-level and U-level ISAs respectively.
0,Figure 3.7: Machine-mode status register (mstatus) for RV64 and RV128.
1,"Interrupt-enable bits, MIE, SIE, and UIE, are provided for each privilege mode."
1,These bits are primarily used to guarantee atomicity with respect to interrupt handlers at the current privilege level.
1,"When a hart is executing in privilege mode x, interrupts are enabled when x IE=1."
1,"Interrupts for lower privilege modes are always disabled, whereas interrupts for higher privilege modes are always enabled."
1,Higher-privilege-level code can use separate per-interrupt enable bits to disable selected interrupts before ceding control to a lower privilege level.
1,"The xIE bits are located in the low-order bits of mstatus, allowing them to be atomically set or cleared with a single CSR instruction."
1,"To support nested traps, each privilege mode x has a two-level stack of interrupt-enable bits and privilege modes."
1,"x PIE holds the value of the interrupt-enable bit active prior to the trap, and"
1,x PP holds the previous privilege mode.
1,"The x PP fields can only hold privilege modes up to x, so MPP is two bits wide, SPP is one bit wide, and UPP is implicitly zero."
1,"When a trap is taken from privilege mode y into privilege mode x, x PIE is set to the value of x IE; x IE is set to 0; and x PP is set to y."
1,"For lower privilege modes, any trap (synchronous or asynchronous) is usually taken at a higher privilege mode with interrupts disabled upon entry."
1,"The higher-level trap handler will either service the trap and return using the stacked information, or, if not returning immediately to the interrupted context, will save the privilege stack before re-enabling interrupts, so only one entry per stack is required."
1,"The MRET, SRET, or URET instructions are used to return from traps in M-mode, S-mode, or U-mode respectively."
1,"When executing an xRET instruction, supposing x PP holds the value y, x IE is set to x PIE; the privilege mode is changed to y; x PIE is set to 1; and x PP is set to U (or M if user-mode is not supported)."
1,"When the stack is popped, the lowest-supported privilege mode with interrupts enabled is added to the bottom of stack to help catch errors that cause invalid entries to be popped off the stack."
1,"User-level interrupts are an optional extension and have been allocated the ISA extension letter N. If user-level interrupts are omitted, the UIE and UPIE bits are hardwired to zero."
1,"For all other supported privilege modes x, the x IE and x PIE must not be hardwired."
1,"User-level interrupts are primarily intended to support secure embedded systems with only Mmode and U-mode present, but can also be supported in systems running Unix-like operating systems to support user-level trap handling."
0,Fields that were previously allocated for H-mode support in mstatus have now been reserved as WPRI fields.
0,"To reduce backwards incompatibility with existing implementations, we did not compact the register after removing these fields."
0,"For RV64 and RV128 systems, the SXL and UXL fields are WARL fields that control the value of XLEN for S-mode and U-mode, respectively."
0,"The encoding of these fields is the same as the MXL field of misa, shown in Table 3.1."
0,"The effective XLEN in S-mode and U-mode are termed S-XLEN and U-XLEN, respectively."
0,"For RV32 systems, the SXL and UXL fields do not exist, and S-XLEN=32 and U-XLEN=32."
0,"For RV64 and RV128 systems, if S-mode is not supported, then SXL is hardwired to zero."
0,"Otherwise, it is a WARL field that encodes the current value of S-XLEN."
0,"In particular, the implementation may hardwire SXL so that S-XLEN=M-XLEN."
1,"For RV64 and RV128 systems, if U-mode is not supported, then UXL is hardwired to zero."
1,"Otherwise, it is a WARL field that encodes the current value of U-XLEN."
1,"In particular, the implementation may hardwire UXL so that U-XLEN=M-XLEN."
1,"Whenever XLEN in any mode is set to a value less than the widest supported XLEN, all operations must ignore source operand register bits above the configured XLEN, and must sign-extend results to fill the entire widest supported XLEN in the destination register."
0,"To reduce hardware complexity, the architecture imposes no checks that lower-privilege modes have XLEN settings less than or equal to the next-higher privilege mode."
0,"In practice, such settings would almost always be an error, but machine operation is well-defined even in this case."
1,The MPRV (Modify PRiVilege) bit modifies the privilege level at which loads and stores execute in all privilege modes.
1,"When MPRV=0, translation and protection behave as normal."
1,"When MPRV=1, load and store memory addresses are translated and protected as though the current privilege mode were set to MPP."
1,Instruction address-translation and protection are unaffected.
1,MPRV is hardwired to 0 if U-mode is not supported.
1,The MXR (Make eXecutable Readable) bit modifies the privilege with which loads access virtual memory.
1,"When MXR=0, only loads from pages marked readable (R=1 in Figure 4.15) will succeed."
1,"When MXR=1, loads from pages marked either readable or executable (R=1 or X=1) will succeed."
1,MXR has no effect when page-based virtual memory is not in effect.
1,MXR is hardwired to 0 if S-mode is not supported.
1,"The MPRV and MXR mechanisms were conceived to improve the efficiency of M-mode routines that emulate missing hardware features, e.g., misaligned loads and stores."
1,MPRV obviates the need to perform address translation in software.
1,MXR allows instruction words to be loaded from pages marked execute-only.
0," For simplicity, MPRV and MXR are in effect regardless of privilege mode, but in normal use will only be enabled for short sequences in machine mode."
0,"The SUM (permit Supervisor User Memory access) bit modifies the privilege with which S-mode loads, stores, and instruction fetches access virtual memory."
1,"When SUM=0, S-mode memory accesses to pages that are accessible by U-mode (U=1 in Figure 4.15) will fault."
1,"When SUM=1, these accesses are permitted."
1,SUM has no effect when page-based virtual memory is not in effect.
1,"Note that, while SUM is ordinarily ignored when not executing in S-mode, it is in effect when MPRV=1 and MPP=S."
1,SUM is hardwired to 0 if S-mode is not supported.
1,The TVM (Trap Virtual Memory) bit supports intercepting supervisor virtual-memory management operations.
1,"When TVM=1, attempts to read or write the satp CSR or execute the"
1,SFENCE.VMA instruction while executing in S-mode will raise an illegal instruction exception.
1,"When TVM=0, these operations are permitted in S-mode."
1,TVM is hard-wired to 0 when S-mode is not supported.
0,"The TVM mechanism improves virtualization efficiency by permitting guest operating systems to execute in S-mode, rather than classically virtualizing them in U-mode."
0,This approach obviates the need to trap accesses to most S-mode CSRs.
0, Trapping satp accesses and the SFENCE.VMA instruction provides the hooks necessary to lazily populate shadow page tables.
1,The TW (Timeout Wait) bit supports intercepting the WFI instruction (see Section 3.2.3).
1,"When TW=0, the WFI instruction is permitted in S-mode."
1,"When TW=1, if WFI is executed in S mode, and it does not complete within an implementation-specific, bounded time limit, the WFI instruction causes an illegal instruction trap."
1,"The time limit may always be 0, in which case WFI always causes an illegal instruction trap in S-mode when TW=1."
1,TW is hard-wired to 0 when S-mode is not supported.
0,"Trapping the WFI instruction can trigger a world switch to another guest OS, rather than wastefully idling in the current guest."
1,"The TSR (Trap SRET) bit supports intercepting the supervisor exception return instruction, SRET."
1,"When TSR=1, attempts to execute SRET while executing in S-mode will raise an illegal instruction exception."
1,"When TSR=0, this operation is permitted in S-mode."
1,TSR is hard-wired to 0 when S-mode is not supported.
0,Trapping SRET is necessary to emulate the Augmented Virtualization mechanism (see Chapter 5) on implementations that do not provide it.
0,"Supporting substantial extensions is one of the primary goals of RISC-V, and hence we define a standard interface to allow unchanged privileged-mode code, particularly a supervisor-level OS, to support arbitrary user-mode state extensions."
0,"To date, there are no standard extensions that define additional state beyond the floating-point CSR and data registers."
0,The FS[1:0] read/write field and the XS[1:0] read-only field are used to reduce the cost of context save and restore by setting and tracking the current state of the floating-point unit and any other user-mode extensions respectively.
0,"The FS field encodes the status of the floating-point unit, including the CSR fcsr and floating-point data registers f0-f31, while the XS field encodes the status of additional user-mode extensions and associated state."
1,These fields can be checked by a context switch routine to quickly determine whether a state save or restore is required.
1,"If a save or restore is required, additional instructions and CSRs are typically required to effect and optimize the process."
0,"The design anticipates that most context switches will not need to save/restore state in either or both of the floating-point unit or other extensions, so provides a fast check via the SD bit."
0,"The FS and XS fields use the same status encoding as shown in Table 3.3, with the four possible status values being Off, Initial, Clean, and Dirty."
1,"In systems that do not implement S-mode and do not have a floating-point unit, the FS field is hardwired to zero."
1,"In systems without additional user extensions requiring new state, the XS field is hardwired to zero."
0,Every additional extension with state adds a local field to mstatus encoding the equivalent of the XS states.
0,The XS field represents a summary of all extensions' status as shown in Table 3.3.
0,"The XS field effectively reports the maximum status value across all user-extension status fields, though individual extensions can use a different encoding than XS."
1,The SD bit is a read-only bit that summarizes whether either the FS field or XS field signals the presence of some dirty state that will require saving extended user context to memory.
1,"If both XS and FS are hardwired to zero, then SD is also always zero."
1,"When an extension's status is set to Off, any instruction that attempts to read or write the corresponding state will cause an exception."
1,"When the status is Initial, the corresponding state should have an initial constant value."
1,"When the status is Clean, the corresponding state is potentially different from the initial value, but matches the last value stored on a context swap."
1,"When the status is Dirty, the corresponding state has potentially been modified since the last context save."
1,"During a context save, the responsible privileged code need only write out the corresponding state if its status is Dirty, and can then reset the extension's status to Clean."
1,"During a context restore, the context need only be loaded from memory if the status is Clean (it should never be Dirty at restore)."
1,"If the status is Initial, the context must be set to an initial constant value on context restore to avoid a security hole, but this can be done without accessing memory."
1,"For example, the floating-point registers can all be initialized to the immediate value 0."
1,The FS and XS fields are read by the privileged code before saving the context.
1,"The FS field is set directly by privileged code when resuming a user context, while the XS field is set indirectly by writing to the status register of the individual extensions."
1,"The status fields will also be updated during execution of instructions, regardless of privilege mode."
0,"Extensions to the user-mode ISA often include additional user-mode state, and this state can be considerably larger than the base integer registers."
0,"The extensions might only be used for some applications, or might only be needed for short phases within a single application."
0,"To improve performance, the user-mode extension can define additional instructions to allow user-mode software to return the unit to an initial state or even to turn off the unit."
1,"For example, a coprocessor might require to be configured before use and can be unconfigured after use."
1,The unconfigured state would be represented as the Initial state for context save.
1,"If the same application remains running between the unconfigure and the next configure (which would set status to Dirty), there is no need to actually reinitialize the state at the unconfigure instruction, as all state is local to the user process, i.e., the Initial state may only cause the coprocessor state to be initialized to a constant value at context restore, not at every unconfigure."
1,Executing a user-mode instruction to disable a unit and place it into the Off state will cause an illegal instruction exception to be raised if any subsequent instruction tries to use the unit before it is turned back on.
1,"A user-mode instruction to turn a unit on must also ensure the unit's state is properly initialized, as the unit might have been used by another context meantime."
1,Changing the setting of FS has no effect on the contents of the floating-point register state.
1,"In particular, setting FS=Off does not destroy the state, nor does setting FS=Initial clear the contents."
1,Other extensions might not preserve state when set to Off.
0,Table 3.4 shows all the possible state transitions for the FS or XS status bits.
0,Note that the standard floating-point extensions do not support user-mode unconfigure or disable/enable instructions.
0,"Standard privileged instructions to initialize, save, and restore extension state are provided to insulate privileged code from details of the added extension state by treating the state as an opaque object."
0,Many coprocessor extensions are only used in limited contexts that allows software to safely unconfigure or even disable units when done.
0,This reduces the context-switch overhead of large stateful coprocessors.
0," We separate out floating-point state from other extension state, as when a floating-point unit is present the floating-point registers are part of the standard calling convention, and so user-mode software cannot know when it is safe to disable the floating-point unit."
1,"The XS field provides a summary of all added extension state, but additional microarchitectural bits might be maintained in the extension to further reduce context save and restore overhead."
1,"The SD bit is read-only and is set when either the FS or XS bits encode a Dirty state (i.e., SD=((FS==11) OR (XS==11)))."
1,This allows privileged code to quickly determine when no addi- tional context save is required beyond the integer register set and PC.
1,"The floating-point unit state is always initialized, saved, and restored using standard instructions (F, D, and/or Q), and privileged code must be aware of FLEN to determine the appropriate space to reserve for each f register."
0,"In a supervisor-level OS, any additional user-mode state should be initialized, saved, and restored using SBI calls that treats the additional context as an opaque object of a fixed maximum size."
0,"The implementation of the SBI initialize, save, and restore calls might require additional implementation-dependent privileged instructions to initialize, save, and restore microarchitectural state inside a coprocessor."
0,All privileged modes share a single copy of the FS and XS bits.
0,"In a system with more than one privileged mode, supervisor mode would normally use the FS and XS bits directly to record the status with respect to the supervisor-level saved context."
0,Other more-privileged active modes must be more conservative in saving and restoring the extension state in their corresponding version of the context.
1,"In any reasonable use case, the number of context switches between user and supervisor level should far outweigh the number of context switches to other privilege levels."
1,"Note that coprocessors should not require their context to be saved and restored to service asynchronous interrupts, unless the interrupt results in a user-level context swap."
0,"The mtvec register is an XLEN-bit read/write register that holds trap vector configuration, consisting of a vector base address (BASE) and a vector mode (MODE)."
1,"The mtvec register must always be implemented, but can contain a hardwired read-only value."
1,"If mtvec is writable, the set of values the register may hold can vary by implementation."
1,"The value in the BASE field must always be aligned on a 4-byte boundary, and the MODE setting may impose additional alignment constraints on the value in the BASE field."
0,We allow for considerable flexibility in implementation of the trap vector base address.
0,"On the one hand, we do not wish to burden low-end implementations with a large number of state bits, but on the other hand, we wish to allow flexibility for larger systems."
1,The encoding of the MODE field is shown in Table 3.5.
1,"When MODE=Direct, all traps into machine mode cause the pc to be set to the address in the BASE field."
1,"When MODE=Vectored, all synchronous exceptions into machine mode cause the pc to be set to the address in the BASE field, whereas interrupts cause the pc to be set to the address in the BASE field plus four times the interrupt cause number."
1,"For example, a machine-mode timer interrupt (see Table 3.6) causes the pc to be set to BASE+0x1c."
1,"Setting MODE=Vectored may impose an additional alignment constraint on BASE, requiring up to 4  XLEN -byte alignment."
1,"When vectored interrupts are enabled, interrupt cause 0, which corresponds to user-mode software interrupts, are vectored to the same location as synchronous exceptions."
0,"This ambiguity does not arise in practice, since user-mode software interrupts are either disabled or delegated to a less-privileged mode."
0,Reset and NMI vector locations are given in a platform specification.
0,"By default, all traps at any privilege level are handled in machine mode, though a machine-mode handler can redirect traps back to the appropriate level with the MRET instruction (Section 3.2.2)."
0,"To increase performance, implementations can provide individual read/write bits within medeleg and mideleg to indicate that certain exceptions and interrupts should be processed directly by a lower privilege level."
0,The machine exception delegation register (medeleg) and machine interrupt delegation register (mideleg) are XLEN-bit read/write registers.
1,"In systems with all three privilege modes (M/S/U), setting a bit in medeleg or mideleg will delegate the corresponding trap in S-mode or U-mode to the S-mode trap handler."
1,"If U-mode traps are supported, S-mode may in turn set corresponding bits in the sedeleg and sideleg registers to delegate traps that occur in U-mode to the U-mode trap handler."
1,or mideleg will delegate the corresponding trap in U-mode to the U-mode trap handler.
1,"In systems with only M-mode, or with both M-mode and U-mode but without U-mode trap support, the medeleg and mideleg registers should not exist."
0,"In versions 1.9.1 and earlier , these registers existed but were hardwired to zero in M-mode only, or M/U without N systems."
0,"There is no reason to require they return zero in those cases, as the misa register indicates whether they exist."
1,"When a trap is delegated to a less-privileged mode x, the x cause register is written with the trap cause; the x epc register is written with the virtual address of the instruction that took the trap; the x PP field of mstatus is written with the active privilege mode at the time of the trap; the x PIE field of mstatus is written with the value of the active interrupt-enable bit at the time of the trap; and the x IE field of mstatus is cleared."
1,The mcause and mepc registers and the MPP and MPIE fields of mstatus are not written.
1,"An implementation shall not hardwire any delegation bits to one, i.e., any trap that can be delegated must support not being delegated."
1,"An implementation can choose to subset the delegatable traps, with the supported delegatable bits found by writing one to every bit location, then reading back the value in medeleg or mideleg to see which bit positions hold a one."
0,Traps never transition from a more-privileged mode to a less-privileged mode.
1,"For example, if M-mode has delegated illegal instruction traps to S-mode, and M-mode software later executes an illegal instruction, the trap is taken in M-mode, rather than being delegated to S-mode."
0,"By contrast, traps may be taken horizontally."
1,"Using the same example, if M-mode has delegated illegal instruction traps to S-mode, and S-mode software later executes an illegal instruction, the trap is taken in S-mode."
0,"medeleg has a bit position allocated for every synchronous exception shown in Table 3.6, with the index of the bit position equal to the value returned in the mcause register (i.e., setting bit 8 allows user-mode environment calls to be delegated to a lower-privilege trap handler)."
1,"mideleg holds trap delegation bits for individual interrupts, with the layout of bits matching those in the mip register (i.e., STIP interrupt delegation control is located in bit 5)."
1,"Some exceptions cannot occur at less privileged modes, and corresponding x edeleg bits should be hardwired to zero."
1,"In particular, medeleg[11] and sedeleg[11:9] are all hardwired to zero."
1,"The mip register is an XLEN-bit read/write register containing information on pending interrupts, while mie is the corresponding XLEN-bit read/write register containing interrupt enable bits."
1,"Only the bits corresponding to lower-privilege software interrupts (USIP, SSIP), timer interrupts (UTIP, STIP), and external interrupts (UEIP, SEIP) in mip are writable through this CSR address; the remaining bits are read-only."
1,"Restricted views of the mip and mie registers appear as the sip/sie, and uip/uie registers in S-mode and U-mode respectively."
1,"If an interrupt is delegated to privilege mode x by setting a bit in the mideleg register, it becomes visible in the x ip register and is maskable using the x ie register."
1,"Otherwise, the corresponding bits in x ip and x ie appear to be hardwired to zero."
1,"The MTIP, STIP, UTIP bits correspond to timer interrupt-pending bits for machine, supervisor, and user timer interrupts, respectively."
1,The MTIP bit is read-only and is cleared by writing to the memory-mapped machine-mode timer compare register.
0,The UTIP and STIP bits may be written
0,by M-mode software to deliver timer interrupts to lower privilege levels.
0,User and supervisor software may clear the UTIP and STIP bits with calls to the AEE and SEE respectively.
0,"There is a separate timer interrupt-enable bit, named MTIE, STIE, and UTIE for M-mode, S-mode, and U-mode timer interrupts respectively."
0,"Each lower privilege level has a separate software interrupt-pending bit (SSIP, USIP), which can be both read and written by CSR accesses from code running on the local hart at the associated or any higher privilege level."
0,"The machine-level MSIP bits are written by accesses to memorymapped control registers, which are used by remote harts to provide machine-mode interprocessor interrupts."
0,"Interprocessor interrupts for lower privilege levels are implemented through ABI and SBI calls to the AEE or SEE respectively, which might ultimately result in a machine-mode write to the receiving hart's MSIP bit."
1,A hart can write its own MSIP bit using the same memory-mapped control register.
1,"We only allow a hart to directly write its own SSIP or USIP bits when running in the appropriate mode, as other harts might be virtualized and possibly descheduled by higher privilege levels."
0,We rely on ABI and SBI calls to provide interprocessor interrupts for this reason.
0,"Machinemode harts are not virtualized and can directly interrupt other harts by setting their MSIP bits, typically using uncached I/O writes to memory-mapped control registers depending on the platform specification."
0,The MEIP field in mip is a read-only bit that indicates a machine-mode external interrupt is pending.
1,"MEIP is set and cleared by a platform-specific interrupt controller, such as the standard platform-level interrupt controller specified in Chapter 7."
1,The MEIE field in mie enables machine external interrupts when set.
0,The SEIP field in mip contains a single read-write bit.
0,SEIP may be written by M-mode software to indicate to S-mode that an external interrupt is pending.
0,"Additionally, the platform level interrupt controller may generate supervisor-level external interrupts."
0,The logical-OR of the software-writeable bit and the signal from the external interrupt controller is used to generate external interrupts to the supervisor.
1,"When the SEIP bit is read with a CSRRW, CSRRS, or CSRRC instruction, the value returned in the rd destination register contains the logical-OR of the software-writable bit and the interrupt signal from the interrupt controller."
1,"However, the value used in the read-modify-write sequence of a CSRRS or CSRRC instruction is only the software-writable SEIP bit, ignoring the interrupt value from the external interrupt controller."
0,"The SEIP field behavior is designed to allow a higher privilege layer to mimic external interrupts cleanly, without losing any real external interrupts."
0,The behavior of the CSR instructions is slightly modified from regular CSR accesses as a result.
0,The UEIP field in mip provides user-mode external interrupts when the N extension for user-mode interrupts is implemented.
0,It is defined analogously to SEIP.
0,"The MEIE, SEIE, and UEIE fields in the mie CSR enable M-mode external interrupts, S-mode external interrupts, and U-mode external interrupts, respectively."
1,The non-maskable interrupt is not made visible via the mip register as its presence is implicitly known when executing the NMI trap handler.
1,"For all the various interrupt types (software, timer, and external), if a privilege level is not supported, the associated pending and interrupt-enable bits are hardwired to zero in the mip and mie registers respectively."
0,"Hence, these are all effectively WARL fields."
0,"Implementations can add additional platform-specific machine-level interrupt sources to the high bits of these registers, though the expectation is that most external interrupts will be routed through the platform interrupt controller and be delivered via MEIP."
1,"An interrupt i will be taken if bit i is set in both mip and mie, and if interrupts are globally enabled."
1,"By default, M-mode interrupts are globally enabled if the hart's current privilege mode is less than M, or if the current privilege mode is M and the MIE bit in the mstatus register is set."
1,"If bit i in mideleg is set, however, interrupts are considered to be globally enabled if the hart's current privilege mode equals the delegated privilege mode (S or U) and that mode's interrupt enable bit (SIE or UIE in mstatus) is set, or if the current privilege mode is less than the delegated privilege mode."
0,"Multiple simultaneous interrupts and traps at the same privilege level are handled in the following decreasing priority order: external interrupts, software interrupts, timer interrupts, then finally any synchronous traps."
0,"Platforms provide a real-time counter, exposed as a memory-mapped machine-mode register, mtime."
0,"mtime must run at constant frequency, and the platform must provide a mechanism for determining the timebase of mtime."
0,"The mtime register has a 64-bit precision on all RV32, RV64, and RV128 systems."
1,"Platforms provide a 64-bit memory-mapped machine-mode timer compare register (mtimecmp), which causes a timer interrupt to be posted when the mtime register contains a value greater than or equal to the value in the mtimecmp register."
1,The interrupt remains posted until it is cleared by writing the mtimecmp register.
1,The interrupt will only be taken if interrupts are enabled and the MTIE bit is set in the mie register.
0,processors that run with a highly variable clock frequency to save energy through dynamic voltage and frequency scaling.
0,"or MEMS oscillator) and have to run even when the rest of system is powered down, and so there is usually only one in a system located in a different frequency/voltage domain from the processors."
0,"Hence, the RTC must be shared by all the harts in a system and accesses to the RTC will potentially incur the penalty of a voltage-level-shifter and clock-domain crossing."
0,It is thus more natural to expose mtime as a memory-mapped register than as a CSR.
0, Lower privilege levels do not have their own timecmp registers.
0,"Instead, machine-mode software can implement any number of virtual timers on a hart by multiplexing the next timer interrupt into the mtimecmp register."
0, Simple fixed-frequency systems can use a single clock for both cycle counting and wall-clock time.
0,"In RV32, memory-mapped writes to mtimecmp modify only one 32-bit part of the register."
0,"The following code sequence sets a 64-bit mtimecmp value without spuriously generating a timer interrupt due to the intermediate value of the comparand: sw t0, mtimecmp # No smaller than old value."
0,"sw a1, mtimecmp+4 # No smaller than new value."
0,"sw a0, mtimecmp # New value."
0,Figure 3.15: Sample code for setting the 64-bit time comparand in RV32 assuming the registers live in a strongly ordered I/O region.
0,M-mode includes a basic hardware performance monitoring facility.
0,The mcycle CSR holds a count of the number of cycles the hart has executed since some arbitrary time in the past.
1,The minstret CSR holds a count of the number of instructions the hart has retired since some arbitrary time in the past.
0,"The mcycle and minstret registers have 64-bit precision on all RV32, RV64, and RV128 systems."
0,"The hardware performance monitor includes 29 additional event counters, mhpmcounter3mhpmcounter31."
0,"The event selector CSRs, mhpmevent3-mhpmevent31, are WARL registers that control which event causes the corresponding counter to increment."
0,"The meaning of these events is defined by the platform, but event 0 is reserved to mean no event."
0,"All counters should be implemented, but a legal implementation is to hard-wire both the counter and its corresponding event selector to 0."
0,"All of these counters have 64-bit precision on RV32, RV64, and RV128."
0,"reads of the mcycleh, minstreth, and mhpmcounternh CSRs return bits 63-32 of the corresponding counter."
0,"Figure 3.17: Upper 32 bits of hardware performance monitor counters, RV32 only."
0,"On RV128 systems, the 64-bit values in mcycle, minstret, and mhpmcountern are sign-extended to 128-bits when read."
0,"On RV128 systems, both signed and unsigned 64-bit values are held in a canonical form with bit 63 repeated in all higher bit positions."
0,and so the counter CSR reads preserve the sign-extension invariant.
0,"Implementations may choose to implement fewer bits of the counters, provided software would be unlikely to experi- ence wraparound (e.g., 263 instructions executed) and thereby avoid having to actually implement the sign-extension circuitry."
0,The counter-enable registers mcounteren and scounteren control the availability of the hardware performance monitoring counters to the next-lowest privileged mode.
0,an illegal instruction exception.
1,"When one of these bits is set, access to the corresponding register is permitted in the next implemented privilege mode (S-mode if implemented, otherwise U-mode)."
1,"If S-mode is implemented, the same bit positions in the scounteren register analogously control access to these registers while executing in U-mode."
1,"If S-mode is permitted to access a counter, the same bit positions in the scounteren register analogously control access to these registers while executing in U-mode."
1,"Registers mcounteren and scounteren are WARL registers that must be implemented if U-mode and S-mode are implemented, Any of the bits may contain a hardwired value of zero, indicating reads to the corresponding counter will cause an exception when executing in a less-privileged mode."
0,The counter-enable bits support two common use cases with minimal hardware.
0,"For systems that do not need high-performance timers and counters, machine-mode software can trap accesses and implement all features in software."
0,"For systems that need high-performance timers and counters but are not concerned with obfuscating the underlying hardware counters, the counters can be directly exposed to lower privilege modes."
0,"The cycle, instret, and hpmcountern CSRs are read-only shadows of mcycle, minstret, and mhpmcountern, respectively."
0,The time CSR is a read-only shadow of the memory-mapped mtime register.
0,"Implementations can convert reads of the time CSR into loads to the memory-mapped mtime register, or hard-wire the TM bits in mxcounteren to 0 and emulate this functionality in M-mode software."
0,The mscratch register is an XLEN-bit read/write register dedicated for use by machine mode.
0,"Typically, it is used to hold a pointer to a machine-mode hart-local context space and swapped with a user register upon entry to an M-mode trap handler."
0,The MIPS ISA allocated two user registers (k0/k1) for use by the operating system.
1,"Although the MIPS scheme provides a fast and simple implementation, it also reduces available user registers, and does not scale to further privilege levels, or nested traps."
1,It can also require both registers are cleared before returning to user level to avoid a potential security hole and to provide deterministic debugging behavior.
0, The RISC-V user ISA was designed to support many possible privileged system environments and so we did not want to infect the user-level ISA with any OS-dependent features.
0,The RISCV CSR swap instructions can quickly save/restore values to the mscratch register.
0,"Unlike the MIPS design, the OS can rely on holding a value in the mscratch register while the user context is running."
1,mepc is an XLEN-bit read/write register formatted as shown in Figure 3.20.
1,The low bit of mepc (mepc[0]) is always zero.
1,"On implementations that do not support instruction-set extensions with 16-bit instruction alignment, the two low bits (mepc[1:0]) are always zero."
1,The mepc register can never hold a PC value that would cause an instruction-address-misaligned exception.
0,mepc is a WARL register that must be able to hold all valid physical and virtual addresses.
0,It need not be capable of holding all possible invalid addresses.
0,Implementations may convert some invalid address patterns into other invalid addresses prior to writing them to mepc.
1,"When a trap is taken into M-mode, mepc is written with the virtual address of the instruction that encountered the exception."
1,"Otherwise, mepc is never written by the implementation, though it may be explicitly written by software."
0,The mcause register is an XLEN-bit read-write register formatted as shown in Figure 3.21.
1,"When a trap is taken into M-mode, mcause is written with a code indicating the event that caused the trap."
1,"Otherwise, mcause is never written by the implementation, though it may be explicitly written by software."
0,The Interrupt bit in the mcause register is set if the trap was caused by an interrupt.
0,The Exception Code field contains a code identifying the last exception.
0,Table 3.6 lists the possible machine-level exception codes.
0,"The Exception Code is an WLRL field, so is only guaranteed to hold supported exception codes."
0,We do not distinguish privileged instruction exceptions from illegal opcode exceptions.
0,This simplifies the architecture and also hides details of which higher-privilege instructions are supported by an implementation.
0,"The privilege level servicing the trap can implement a policy on whether these need to be distinguished, and if so, whether a given opcode should be treated as illegal or privileged."
1,Interrupts can be separated from other traps with a single branch on the sign of the mcause register value.
0,A shift left can remove the interrupt bit and scale the exception codes to index into a trap vector table.
0,The mtval register is an XLEN-bit read-write register formatted as shown in Figure 3.22.
1,"When a trap is taken into M-mode, mtval is written with exception-specific information to assist software in handling the trap."
1,"Otherwise, mtval is never written by the implementation, though it may be explicitly written by software."
1,"When a hardware breakpoint is triggered, or an instruction-fetch, load, or store address-misaligned, access, or page-fault exception occurs, mtval is written with the faulting effective address."
1,"On an illegal instruction trap, mtval is written with the first XLEN bits of the faulting instruction as described below."
1,"For other exceptions, mtval is set to zero, but a future standard may redefine mtval's setting for other exceptions."
0,The mtval register replaces the mbadaddr register in the previous specification.
0,"to providing bad addresses, the register can now provide the bad instruction that triggered an illegal instruction trap (and may in future be used to return other information)."
1,Returning the instruction bits accelerates instruction emulation and also removes some races that might be present when trying to emulate illegal instructions.
1,"When page-based virtual memory is enabled, mtval is written with the faulting virtual address, even for physical-memory access exceptions."
0,"This design reduces datapath cost for most implementations, particularly those with hardware page-table walkers."
0,"For instruction-fetch access faults on RISC-V systems with variable-length instructions, mtval will contain a pointer to the portion of the instruction that caused the fault while mepc will point to the beginning of the instruction."
1,The mtval register can optionally also be used to return the faulting instruction bits on an illegal instruction exception (mepc points to the faulting instruction in memory).
1,"If this feature is not provided, then mtval is set to zero on an illegal instruction fault."
1,"If the feature is provided, after an illegal instruction trap, mtval will contain the entire faulting instruction provided the instruction is no longer than XLEN bits."
1,"If the instruction is less than XLEN bits long, the upper bits of mtval are cleared to zero."
1,"If the instruction is more than XLEN bits long, mtval will contain the first XLEN bits of the instruction."
0,"Capturing the faulting instruction in mtval reduces the overhead of instruction emulation, potentially avoiding several partial instruction loads if the instruction is misaligned, and likely data cache misses or slow uncached accesses when loads are used to fetch the instruction into a data register."
0,"There is also a problem of atomicity if another agent is manipulating the instruction memory, as might occur in a dynamic translation system."
1, A requirement is that the entire instruction (or at least the first XLEN bits) are fetched into mtval before taking the trap.
1,"This should not constrain implementations, which would typically fetch the entire instruction before attempting to decode the instruction, and avoids complicating software handlers."
1," A value of zero in mtval signifies either that the feature is not supported, or an illegal zero instruction was fetched."
0,"A load from the instruction memory pointed to by mepc can be used to distinguish these two cases (or alternatively, the system configuration information can be interrogated to install the appropriate trap handling before runtime)."
0,mtval is a WARL register that must be able to hold all valid physical and virtual addresses and the value 0.
0,It need not be capable of holding all possible invalid addresses.
0,Implementations may convert some invalid address patterns into other invalid addresses prior to writing them to mtval.
1,"If the feature to return the faulting instruction bits is implemented, mtval must also be able to hold all values less than 2N , where N is the smaller of XLEN and the width of the longest supported instruction."
0,The ECALL instruction is used to make a request to the supporting execution environment.
1,"When executed in U-mode, S-mode, or M-mode, it generates an environment-call-from-U-mode exception, environment-call-from-S-mode exception, or environment-call-from-M-mode exception, respectively, and performs no other operation."
0,ECALL generates a different exception for each originating privilege mode so that environment call exceptions can be selectively delegated.
0,A typical use case for Unix-like operating systems is to delegate to S-mode the environment-call-from-U-mode exception but not the others.
1,The EBREAK instruction is used by debuggers to cause control to be transferred back to a debugging environment.
0,It generates a breakpoint exception and performs no other operation.
0,"As described in the C Standard Extension for Compressed Instructions in Volume I of this manual, the C.EBREAK instruction performs the same operation as the EBREAK instruction."
1,"ECALL and EBREAK cause the receiving privilege mode's epc register to be set to the address of the ECALL or EBREAK instruction itself, not the address of the following instruction."
0,Instructions to return from trap are encoded under the PRIV minor opcode.
0,"To return after handling a trap, there are separate trap return instructions per privilege level: MRET, SRET, and URET."
0,"MRET is always provided, while SRET must be provided if supervisor mode is supported."
0,URET is only provided if user-mode traps are supported.
0,"An x RET instruction can be executed in privilege mode x or higher, where executing a lower-privilege x RET instruction will pop the relevant lower-privilege interrupt enable and privilege mode stack."
0,"In addition to manipulating the privilege stack as described in Section 3.1.7, x RET sets the pc to the value stored in the x epc register."
0,"Previously, there was only a single ERET instruction (which was also earlier known as SRET)."
0,"To support the addition of user-level interrupts, we needed to add a separate URET instruction to continue to allow classic virtualization of OS code using the ERET instruction."
0,It then became more orthogonal to support a different xRET instruction per privilege level.
0,The Wait for Interrupt instruction (WFI) provides a hint to the implementation that the current hart can be stalled until an interrupt might need servicing.
0,Execution of the WFI instruction can also be used to inform the hardware platform that suitable interrupts should preferentially be routed to this hart.
0,"WFI is available in all of the supported S and M privilege modes, and optionally available to U-mode for implementations that support U-mode interrupts."
1,"If an enabled interrupt is present or later becomes present while the hart is stalled, the interrupt exception will be taken on the following instruction, i.e., execution resumes in the trap handler and mepc=pc + 4."
1,"The following instruction takes the interrupt exception and trap, so that a simple return from the trap handler will execute code after the WFI instruction."
0,"The WFI instruction is just a hint, and a legal implementation is to implement WFI as a NOP."
1,"will be taken on some instruction in the idle loop containing the WFI, and on a simple return from the handler, the idle loop will resume execution."
1,"We have removed the earlier requirement that implementations ignore the rs1 and rd fields, so non-zero values in these fields should now raise illegal instruction exceptions."
1,The WFI instruction can also be executed when interrupts are disabled.
1,"The operation of WFI must be unaffected by the global interrupt bits in mstatus (MIE/SIE/UIE) and the delegation registers [m|s|u]ideleg (i.e., the hart must resume if a locally enabled interrupt becomes pending, even if it has been delegated to a less-privileged mode), but should honor the individual interrupt enables (e.g, MTIE) (i.e., implementations should avoid resuming the hart if the interrupt is pending but not individually enabled)."
1,"WFI is also required to resume execution for locally enabled interrupts pending at any privilege level, regardless of the global interrupt enable at each privilege level."
1,"If the event that causes the hart to resume execution does not cause an interrupt to be taken, execution will resume at pc + 4, and software must determine what action to take, including looping back to repeat the WFI if there was no actionable event."
1,"By allowing wakeup when interrupts are disabled, an alternate entry point to an interrupt handler can be called that does not require saving the current context, as the current context can be saved or discarded before the WFI is executed."
0," As implementations are free to implement WFI as a NOP, software must explicitly check for any relevant pending but disabled interrupts in the code following an WFI, and should loop back to the WFI if no suitable interrupt was detected."
0,"The mip, sip, or uip registers can be interrogated to determine the presence of any interrupt in machine, supervisor, or user mode respectively."
0,The operation of WFI is unaffected by the delegation register settings.
0," WFI is defined so that an implementation can trap into a higher privilege mode, either immediately on encountering the WFI or after some interval to initiate a machine-mode transition to a lower power state, for example."
0,"The same wait-for-event template might be used for possible future extensions that wait on memory locations changing, or message arrival."
1,"Upon reset, a hart's privilege mode is set to M, the mstatus fields MIE and MPRV are reset to S."
0,The pc is set to an implementation-defined reset vector.
0,The mcause register is set to a value indicating the cause of the reset.
0,All other hart state is undefined.
1,"The mcause values after reset have implementation-specific interpretation, but the value 0 should be returned on implementations that do not distinguish different reset conditions."
1,"Implementations that distinguish different reset conditions should only use 0 to indicate the most complete reset (e.g., hard reset)."
0,"Some designs may have multiple causes of reset (e.g., power-on reset, external hard reset, brownout detected, watchdog timer elapse, sleep-mode wakeup), which machine-mode software and debuggers may wish to distinguish."
0, mcause reset values may alias mcause values following synchronous exceptions.
0,"There is no ambiguity in this overlap, since on reset the pc is set to a different value than on other traps."
0,"Non-maskable interrupts (NMIs) are only used for hardware error conditions, and cause an immediate jump to an implementation-defined NMI vector running in M-mode regardless of the state of a hart's interrupt enable bits."
0,"The mepc register is written with the address of the next instruction to be executed at the time the NMI was taken, and mcause is set to a value indicating the source of the NMI."
0,The NMI can thus overwrite state in an active machine-mode interrupt handler.
1,"The values written to mcause on an NMI are implementation-defined, but a value of 0 is reserved to mean unknown cause and implementations that do not distinguish sources of NMIs via the mcause register should return 0."
0,"Unlike resets, NMIs do not reset processor state, enabling diagnosis, reporting, and possible containment of the hardware error."
0,"Some memory regions might not support reads, writes, or execution; some might not support subword or subblock accesses; some might not support atomic operations; and some might not support cache coherence or might have different memory models."
0,"Similarly, memorymapped control registers vary in their supported access widths, support for atomic operations, and whether read and write accesses have associated side effects."
0,"In RISC-V systems, these properties and capabilities of each region of the machine's physical address space are termed physical memory attributes (PMAs)."
0,This section describes RISC-V PMA terminology and how RISC-V systems implement and check PMAs.
0,PMAs are inherent properties of the underlying hardware and rarely change during system operation.
0,"Unlike physical memory protection values described in Section 3.6, PMAs do not vary by execution context."
0,"The PMAs of some memory regions are fixed at chip design time-for example, for an on-chip ROM."
0,"Others are fixed at board design time, depending, for example, on which other chips are connected to off-chip buses."
0,Off-chip buses might also support devices that could be changed on every power cycle (cold pluggable) or dynamically while the system is running (hot pluggable).
0,"Some devices might be configurable at run time to support different uses that imply different PMAs-for example, an on-chip scratchpad RAM might be cached privately by one core in one end-application, or accessed as a shared non-cached memory in another end-application."
0,"Most systems will require that at least some PMAs are dynamically checked in hardware later in the execution pipeline after the physical address is known, as some operations will not be supported at all physical memory addresses, and some operations require knowing the current setting of a configurable PMA attribute."
0,"While many other systems specify some PMAs in the virtual memory page tables and use the TLB to inform the pipeline of these properties, this approach injects platform-specific information into a virtualized layer and can cause system errors unless attributes are correctly initialized in each page-table entry for each physical memory region."
0,"In addition, the available page sizes might not be optimal for specifying attributes in the physical memory space, leading to address-space fragmentation and inefficient use of expensive TLB entries."
0,"For RISC-V, we separate out specification and checking of PMAs into a separate hardware structure, the PMA checker."
0,"In many cases, the attributes are known at system design time for each physical address region, and can be hardwired into the PMA checker."
0,"Where the attributes are run-time configurable, platform-specific memory-mapped control registers can be provided to specify these attributes at a granularity appropriate to each region on the platform (e.g., for an on-chip SRAM that can be flexibly divided between cacheable and uncacheable uses)."
0,"PMAs are checked for any access to physical memory, including accesses that have undergone virtual to physical memory translation."
0,"To aid in system debugging, we strongly recommend that, where possible, RISC-V processors precisely trap physical memory accesses that fail PMA checks."
0,"Precisely trapped PMA violations manifest as load, store, or instruction-fetch access exceptions, distinct from virtualmemory page-fault exceptions."
0,"Precise PMA traps might not always be possible, for example, when probing a legacy bus architecture that uses access failures as part of the discovery mechanism."
0,"In this case, error responses from slave devices will be reported as imprecise bus-error interrupts."
0,"PMAs must also be readable by software to correctly access certain devices or to correctly configure other hardware components that access memory, such as DMA engines."
0,"As PMAs are tightly tied to a given physical platform's organization, many details are inherently platform-specific, as is the means by which software can learn the PMA values for a platform."
0,The configuration string (Chapter 8) can encode PMAs for on-chip devices and might also describe on-chip controllers for offchip buses that can be dynamically interrogated to discover attached device PMAs.
0,"particularly legacy buses, do not support discovery of PMAs and so will give error responses or time out if an unsupported access is attempted."
0,"Typically, platform-specific machine-mode code will extract PMAs and ultimately present this information to higher-level less-privileged software using some standard representation."
0,"Where platforms support dynamic reconfiguration of PMAs, an interface will be provided to set the attributes by passing requests to a machine-mode driver that can correctly reconfigure the platform."
0,"For example, switching cacheability attributes on some memory regions might involve platform-specific operations, such as cache flushes, that are available only to machine-mode."
0,"The most important characterization of a given memory address range is whether it holds regular main memory, or I/O devices, or is empty."
1,"Regular main memory is required to have a number of properties, specified below, whereas I/O devices can have a much broader range of attributes."
0,"Memory regions that do not fit into regular main memory, for example, device scratchpad RAMs, are categorized as I/O regions."
0,Empty regions are also classified as I/O regions but with attributes specifying that no accesses are supported.
0,"Access types specify which access widths, from 8-bit byte to long multi-word burst, are supported, and also whether misaligned accesses are supported for each access width."
0,"Although software running on a RISC-V hart cannot directly generate bursts to memory, software might have to program DMA engines to access I/O devices and might therefore need to know which access sizes are supported."
0,"Main memory regions always support read, write, and execute of all access widths required by the attached devices."
0,"In some cases, the design of a processor or device accessing main memory might support other widths, but must be able to function with the types supported by the main memory."
0,"I/O regions can specify which combinations of read, write, or execute accesses to which data widths are supported."
0,Atomicity PMAs describes which atomic instructions are supported in this address region.
0,Main memory regions must support the atomic operations required by the processors attached.
0,I/O regions may only support a subset or none of the processor-supported atomic operations.
0,Support for atomic instructions is divided into two categories: LR/SC and AMOs.
0,"AMOs, there are four levels of support: AMONone, AMOSwap, AMOLogical, and AMOArithmetic."
0,AMONone indicates that no AMO operations are supported.
0,AMOSwap indicates that only amoswap instructions are supported in this address range.
0,"AMOLogical indicates that swap instructions plus all the logical AMOs (amoand, amoor, amoxor) are supported."
0,AMOArithmetic indicates that all RISC-V AMOs are supported.
1,"For each level of support, naturally aligned AMOs of a given width are supported if the underlying memory region supports reads and writes of that width."
0,Table 3.7: Classes of AMOs supported by I/O regions.
0,Main memory regions must always support all AMOs required by the processor.
0,We recommend providing at least AMOLogical support for I/O regions where possible.
0,"Most I/O regions will not support LR/SC accesses, as these are most conveniently built on top of a cache-coherence scheme."
0,Regions of the address space are classified as either main memory or I/O for the purposes of ordering by the FENCE instruction and atomic-instruction ordering bits.
0,"Accesses by one hart to main memory regions are observable not only by other harts but also by other devices with the capability to initiate requests in the main memory system (e.g., DMA engines)."
0,Main memory regions always have the standard RISC-V relaxed memory model.
0,"Accesses by one hart to the I/O space are observable not only by other harts and bus mastering devices, but also by targeted slave I/O devices."
0,"Within I/O, regions may further be classified as implementing either relaxed or strong ordering."
0,A relaxed I/O region has no ordering guarantees on how memory accesses made by one hart are observable by different harts or I/O devices beyond those enforced by FENCE and AMO instructions.
0,A strongly ordered I/O region ensures that all accesses made by a hart to that region are only observable in program order by all other harts or I/O devices.
0,"Each strongly ordered I/O region specifies a numbered ordering channel, which is a mechanism by which ordering guarantees can be provided between different I/O regions."
0,"Channel 0 is used to indicate point-to-point strong ordering only, where only accesses by the hart to the single associated I/O region are strongly ordered."
0,Channel 1 is used to provide global strong ordering across all I/O regions.
0,"Any accesses by a hart to any I/O region associated with channel 1 can only be observed to have occurred in program order by all other harts and I/O devices, including relative to accesses made by that hart to relaxed I/O regions or strongly ordered I/O regions with different channel numbers."
0,"In other words, any access to a region in channel 1 is equivalent to executing a fence io,io instruction before and after the instruction."
0,Other larger channel numbers provide program ordering to accesses by that hart across any regions with the same channel number.
0,Systems might support dynamic configuration of ordering properties on each memory region.
0,increased performance compared to insertion of explicit ordering instructions when the implementation is known to not reorder accesses.
0, Local strong ordering (channel 0) is the default form of strong ordering as it is often straightforward to provide if there is only a single in-order communication path between the hart and the I/O device.
0," Generally, different strongly ordered I/O regions can share the same ordering channel without additional ordering hardware if they share the same interconnect path and the path does not reorder requests."
0,"Coherence is a property defined for a single physical address, and indicates that writes to that address by one agent will eventually be made visible to other agents in the system."
0,"Coherence is not to be confused with the memory consistency model of a system, which defines what values a memory read can return given the previous history of reads and writes to the entire memory system."
0,"In RISC-V platforms, the use of hardware-incoherent regions is discouraged due to software complexity, performance, and energy impacts."
1,"The cacheability of a memory region should not affect the software view of the region except for differences reflected in other PMAs, such as main memory versus I/O classification, memory ordering, supported accesses and atomic operations, and coherence."
0,"For this reason, we treat cacheability as a platform-level setting managed by machine-mode software only."
1,"Where a platform supports configurable cacheability settings for a memory region, a platformspecific machine-mode routine will change the settings and flush caches if necessary, so the system is only incoherent during the transition between cacheability settings."
0,This transitory state should not be visible to lower privilege levels.
0,"We categorize RISC-V caches into three types: master-private, shared, and slave-private."
0,"Master-private caches are attached to a single master agent, i.e., one that issues read/write requests to the memory system."
1,Shared caches are located inbetween masters and slaves and may be hierarchically organized.
1,"Slave-private caches do not impact coherence, as they are local to a single slave and do not affect other PMAs at a master, so are not considered further here."
0, Coherence is straightforward to provide for a shared memory region that is not cached by any agent.
0,The PMA for such a region would simply indicate it should not be cached in a private or shared cache.
0," Coherence is also straightforward for read-only regions, which can be safely cached by multiple agents without requiring a cache-coherence scheme."
0,"The PMA for this region would indicate that it can be cached, but that writes are not supported."
0," Some read-write regions might only be accessed by a single agent, in which case they can be cached privately by that agent without requiring a coherence scheme."
0,The PMA for such regions would indicate they can be cached.
1,"The data can also be cached in a shared cache, as other agents should not access the region."
1," If an agent can cache a read-write region that is accessible by other agents, whether caching or non-caching, a cache-coherence scheme is required to avoid use of stale values."
0,"In regions lacking hardware cache coherence (hardware-incoherent regions), cache coherence can be implemented entirely in software, but software coherence schemes are notoriously difficult to implement correctly and often have severe performance impacts due to the need for conservative software-directed cache-flushing."
0,"Hardware cache-coherence schemes require more complex hardware and can impact performance due to the cache-coherence probes, but are otherwise invisible to software."
0," For each hardware cache-coherent region, the PMA would indicate that the region is coherent and which hardware coherence controller to use if the system has multiple coherence controllers."
0,"For some systems, the coherence controller might be an outer-level shared cache, which might itself access further outer-level cache-coherence controllers hierarchically."
0," Most memory regions within a platform will be coherent to software, because they will be fixed as either uncached, read-only, hardware cache-coherent, or only accessed by one agent."
0,Idempotency PMAs describe whether reads and writes to an address region are idempotent.
0,Main memory regions are assumed to be idempotent.
0,"For I/O regions, idempotency on reads and writes can be specified separately (e.g., reads are idempotent but writes are not)."
1,"If accesses are nonidempotent, i.e., there is potentially a side effect on any read or write access, then speculative or redundant accesses must be avoided."
0,"For the purposes of defining the idempotency PMAs, changes in observed memory ordering created by redundant accesses are not considered a side effect."
1,"While hardware should always be designed to avoid speculative or redundant accesses to memory regions marked as non-idempotent, it is also necessary to ensure software or compiler optimizations do not generate spurious accesses to non-idempotent memory regions."
0,"Non-idempotent regions might not support misaligned accesses, in which case software might emulate misaligned accesses as a sequence of aligned accesses, each possibly causing side effects."
0,"Therefore, portable software should not issue misaligned accesses to non-idempotent regions."
0,"To support secure processing and contain faults, it is desirable to limit the physical addresses accessible by software running on a hart."
0,"An optional physical memory protection (PMP) unit provides per-hart machine-mode control registers to allow physical memory access privileges (read, write, execute) to be specified for each physical memory region."
0,The PMP values are checked in parallel with the PMA checks described in Section 3.5.
0,"The granularity of PMP access control settings are platform-specific and within a platform may vary by physical memory region, but the standard PMP encoding supports regions as small as four bytes."
0,"Certain regions' privileges can be hardwired-for example, some regions might only ever be visible in machine mode but in no lower-privilege layers."
0,"Platforms vary widely in demands for physical memory protection, and some platforms may provide other PMP structures in addition to or instead of the scheme described in this section."
0,"PMP checks are applied to all accesses when the hart is running in S or U modes, and for loads and stores when the MPRV bit is set in the mstatus register and the MPP field in the mstatus register contains S or U. PMP checks are also applied to page-table accesses for virtual-address translation, for which the effective privilege mode is S. Optionally, PMP checks may additionally apply to M-mode accesses, in which case the PMP registers themselves are locked, so that even M-mode software cannot change them without a system reset."
0,"In effect, PMP can grant permissions to S and U modes, which by default have none, and can revoke permissions from M-mode, which by default has full permissions."
0,PMP entries are described by an 8-bit configuration register and one XLEN-bit address register.
0,Some PMP settings additionally use the address register associated with the preceding PMP entry.
0,Up to 16 PMP entries are supported.
1,"If any PMP entries are implemented, then all PMP CSRs must be implemented, but all PMP CSR fields are WARL and may be hardwired to zero."
0,PMP CSRs are only accessible to M-mode.
0,The PMP configuration registers are densely packed into CSRs to minimize context-switch time.
0,"For RV32, four CSRs, pmpcfg0-pmpcfg3, hold the configurations pmp0cfg-pmp15cfg for the 16 PMP entries, as shown in Figure 3.23."
0,"For RV64, pmpcfg0 and pmpcfg2 hold the configurations for the 16 PMP entries, as shown in Figure 3.24; pmpcfg1 and pmpcfg3 are illegal."
0,"RV64 systems use pmpcfg2, rather than pmpcfg1, to hold configurations for PMP entries 8-15."
0,"This design reduces the cost of supporting multiple M-XLEN values, since the configurations for PMP entries 8-11 appear in pmpcfg2[31:0] for both RV32 and RV64."
0,The PMP address registers are CSRs named pmpaddr0-pmpaddr15.
0,"Each PMP address register encodes bits 33-2 of a 34-bit physical address for RV32, as shown in Figure 3.25."
0,"For RV64, each PMP address register encodes bits 55-2 of a 56-bit physical address, as shown in Figure 3.26."
0,"Not all physical address bits may be implemented, and so the pmpaddr registers are WARL."
0,"The Sv32 page-based virtual-memory scheme described in Section 4.3 supports 34-bit physical addresses for RV32, so the PMP scheme must support addresses wider than XLEN for RV32."
0,"The Sv39 and Sv48 page-based virtual-memory schemes described in Sections 4.4 and 4.5 support a 56-bit physical address space, so the RV64 PMP address registers impose the same limit."
0,Figure 3.27 shows the layout of a PMP configuration register.
0,"The R, W, and X bits, when set, indicate that the PMP entry permits read, write, and instruction execution, respectively."
0,"When one of these bits is clear, the corresponding access type is denied."
0,"The remaining two fields, A and L, are described in the following sections."
0,The A field in a PMP entry's configuration register encodes the address-matching mode of the associated PMP address register.
0,The encoding of this field is shown in Table 3.8.
1,"When A=0, this PMP entry is disabled and matches no addresses."
0,"Two other address-matching modes are supported: naturally aligned power-of-2 regions (NAPOT), including the special case of naturally aligned four-byte regions (NA4); and the top boundary of an arbitrary range (TOR)."
0,These modes support four-byte granularity.
0,"NAPOT ranges make use of the low-order bits of the associated address register to encode the size of the range, as shown in Table 3.9."
1,"If TOR is selected, the associated address register forms the top of the address range, and the preceding PMP address register forms the bottom of the address range."
1,"If PMP entry i's A field is set to TOR, the entry matches any address a such that pmpaddri-1=a < pmpaddri."
1,"If PMP entry 0's A field is set to TOR, zero is used for the lower bound, and so it matches any address a < pmpaddr0."
1,"The L bit indicates that the PMP entry is locked, i.e., writes to the configuration register and associated address registers are ignored."
1,Locked PMP entries may only be unlocked with a system reset.
1,"If PMP entry i is locked, writes to pmpicfg and pmpaddri are ignored."
1,"Additionally, if pmpicfg.A is set to TOR, writes to pmpaddri-1 are ignored."
0,"In addition to locking the PMP entry, the L bit indicates whether the R/W/X permissions are enforced on M-mode accesses."
1,"When the L bit is set, these permissions are enforced for all privilege modes."
1,"When the L bit is clear, any M-mode access matching the PMP entry will succeed; the R/W/X permissions apply only to S and U modes."
0,PMP entries are statically prioritized.
0,The lowest-numbered PMP entry that matches any byte of an access determines whether that access succeeds or fails.
0,"The matching PMP entry must match all bytes of an access, or the access fails, irrespective of the L, R, W, and X bits."
1,"For example, if a PMP entry is configured to match the four-byte range 0xC-0xF, then an 8-byte access to the range 0x8-0xF will fail, assuming that PMP entry is the highest-priority entry that matches those addresses."
1,"If a PMP entry matches all bytes of an access, then the L, R, W, and X bits determine whether the access succeeds or fails."
1,"If the L bit is clear and the privilege mode of the access is M, the access succeeds."
1,"Otherwise, if the L bit is set or the privilege mode of the access is S or U, then the access succeeds only if the R, W, or X bit corresponding to the access type is set."
1,"If no PMP entry matches an M-mode access, the access succeeds."
1,"If no PMP entry matches an S-mode or U-mode access, but at least one PMP entry is implemented, the access fails."
1,"Failed accesses generate a load, store, or instruction access exception."
0,"Note that a single instruction may generate multiple accesses, which may not be mutually atomic."
1,"An access exception is generated if at least one access generated by an instruction fails, though other accesses generated by that instruction may succeed with visible side effects."
0,"Notably, instructions that reference virtual memory are decomposed into multiple accesses."
0,"On some implementations, misaligned loads, stores, and instruction fetches may also be decomposed into multiple accesses, some of which may succeed before an access exception occurs."
0,"In particular, a portion of a misaligned store that passes the PMP check may become visible, even if another portion fails the PMP check."
0,"The same behavior may manifest for floating-point stores wider than XLEN bits (e.g., the FSD instruction in RV32D), even when the store address is naturally aligned."
0,"This chapter describes the RISC-V supervisor-level architecture, which contains a common core that is used with various supervisor-level address translation and protection schemes."
0,Supervisorlevel code relies on a supervisor execution environment to initialize the environment and enter the supervisor code at an entry point defined by the system binary interface (SBI).
0,The SBI also defines function entry points that provide supervisor environment services for supervisor-level code.
0,"Supervisor mode is deliberately restricted in terms of interactions with underlying physical hardware, such as physical memory and device interrupts, to support clean virtualization."
0,"In particular, there is no information about the existence (or non-existence) of higher privilege levels (hypervisor or machine) visible in the CSRs accessible by the supervisor."
0," Many supervisor CSRs are a subset of the equivalent machine-mode CSR, and the machinemode chapter should be read first to help understand the supervisor-level CSR descriptions."
0,The sstatus register is an XLEN-bit read/write register formatted as shown in Figure 4.1 for RV32 and Figure 4.2 for RV64 and RV128.
0,The sstatus register keeps track of the processor's current operating state.
0,The SPP bit indicates the privilege level at which a hart was executing before entering supervisor mode.
0,"When a trap is taken, SPP is set to 0 if the trap originated from user mode, or 1 otherwise."
1,"When an SRET instruction (see Section 3.2.2) is executed to return from the trap handler, the privilege level is set to user mode if the SPP bit is 0, or supervisor mode if the SPP bit is 1; SPP is then set to 0."
0,Figure 4.2: Supervisor-mode status register (sstatus) for RV64 and RV128.
0,The SIE bit enables or disables all interrupts in supervisor mode.
1,"When SIE is clear, interrupts are not taken while in supervisor mode."
1,"When the hart is running in user-mode, the value in SIE is ignored, and supervisor-level interrupts are enabled."
0,The supervisor can disable indivdual interrupt sources using the sie register.
0,The SPIE bit indicates whether supervisor interrupts were enabled prior to trapping into supervisor mode.
1,"When a trap is taken into supervisor mode, SPIE is set to SIE, and SIE is set to 0."
1,"When an SRET instruction is executed, SIE is set to SPIE, then SPIE is set to 1."
0,The UIE bit enables or disables user-mode interrupts.
0,User-level interrupts are enabled only if UIE is set and the hart is running in user-mode.
0,The UPIE bit indicates whether user-level interrupts were enabled prior to taking a user-level trap.
1,"When a URET instruction is executed, UIE is set to UPIE, and UPIE is set to 1."
0,User-level interrupts are optional.
1,"If omitted, the UIE and UPIE bits are hardwired to zero."
0,The sstatus register is a subset of the mstatus register.
0,"In a straightforward implementation, reading or writing any field in sstatus is equivalent to reading or writing the homonymous field in mstatus."
0,"The UXL field controls the value of XLEN for U-mode, termed U-XLEN, which may differ from the value of XLEN for S-mode, termed S-XLEN."
0,"The encoding of UXL is the same as that of the MXL field of misa, shown in Table 3.1."
0,"For RV32 systems, the UXL field does not exist, and U-XLEN=32."
0,"For RV64 and RV128 systems, it is a WARL field that encodes the current value of U-XLEN."
0,"In particular, the implementation may hardwire UXL so that U-XLEN=S-XLEN."
1,"If U-XLEN=S-XLEN, instructions executed in the narrower mode must ignore source register operand bits above the configured XLEN, and must sign-extend results to fill the widest supported XLEN in the destination register."
1,The MXR (Make eXecutable Readable) bit modifies the privilege with which loads access virtual memory.
1,"When MXR=0, only loads from pages marked readable (R=1 in Figure 4.15) will succeed."
1,"When MXR=1, loads from pages marked either readable or executable (R=1 or X=1) will succeed."
1,MXR has no effect when page-based virtual memory is not in effect.
0,"The SUM (permit Supervisor User Memory access) bit modifies the privilege with which S-mode loads, stores, and instruction fetches access virtual memory."
1,"When SUM=0, S-mode memory accesses to pages that are accessible by U-mode (U=1 in Figure 4.15) will fault."
1,"When SUM=1, these accesses are permitted."
0,"SUM has no effect when page-based virtual memory is not in effect, nor when executing in U-mode."
0,The SUM mechanism prevents supervisor software from inadvertently accessing user memory.
0,Operating systems can execute the majority of code with SUM clear; the few code segments that should access user memory can temporarily set SUM.
0,"The stvec register is an XLEN-bit read/write register that holds trap vector configuration, consisting of a vector base address (BASE) and a vector mode (MODE)."
0,"The BASE field in stvec is a WARL field that can hold any valid virtual or physical address, subject to the following alignment constraints: the address must always be at least 4-byte aligned, and the MODE setting may impose additional alignment constraints on the value in the BASE field."
0,The encoding of the MODE field is shown in Table 4.1.
1,"When MODE=Direct, all traps into"
1,supervisor mode cause the pc to be set to the address in the BASE field.
1,"When MODE=Vectored, all synchronous exceptions into supervisor mode cause the pc to be set to the address in the BASE field, whereas interrupts cause the pc to be set to the address in the BASE field plus four times the interrupt cause number."
0,"For example, a supervisor-mode timer interrupt (see Table 4.2) causes the pc to be set to BASE+0x14."
0,"Setting MODE=Vectored may impose an additional alignment constraint on BASE, requiring up to 4XLEN-byte alignment."
1,"When vectored interrupts are enabled, interrupt cause 0, which corresponds to user-mode software interrupts, are vectored to the same location as synchronous exceptions."
0,"This ambiguity does not arise in practice, since user-mode software interrupts are either disabled or delegated to user mode."
0,"The sip register is an XLEN-bit read/write register containing information on pending interrupts, while sie is the corresponding XLEN-bit read/write register containing interrupt enable bits."
0,"Three types of interrupts are defined: software interrupts, timer interrupts, and external interrupts."
0,A supervisor-level software interrupt is triggered on the current hart by writing 1 to its supervisor software interrupt-pending (SSIP) bit in the sip register.
1,A pending supervisor-level software interrupt can be cleared by writing 0 to the SSIP bit in sip.
1,Supervisor-level software interrupts are disabled when the SSIE bit in the sie register is clear.
0,"Interprocessor interrupts are sent to other harts by means of SBI calls, which will ultimately cause the SSIP bit to be set in the recipient hart's sip register."
0,A user-level software interrupt is triggered on the current hart by writing 1 to its user software interrupt-pending (USIP) bit in the sip register.
0,A pending user-level software interrupt can be cleared by writing 0 to the USIP bit in sip.
1,User-level software interrupts are disabled when the USIE bit in the sie register is clear.
1,"If user-level interrupts are not supported, USIP and USIE are hardwired to zero."
1,"All bits besides SSIP, USIP, and UEIP in the sip register are read-only."
1,A supervisor-level timer interrupt is pending if the STIP bit in the sip register is set.
1,Supervisorlevel timer interrupts are disabled when the STIE bit in the sie register is clear.
0,An SBI call to the SEE may be used to clear the pending timer interrupt.
1,A user-level timer interrupt is pending if the UTIP bit in the sip register is set.
1,User-level timer interrupts are disabled when the UTIE bit in the sie register is clear.
1,"If user-level interrupts are supported, the ABI should provide a facility for scheduling timer interrupts in terms of real-time counter values."
1,"If user-level interrupts are not supported, UTIP and UTIE are hardwired to zero."
1,A supervisor-level external interrupt is pending if the SEIP bit in the sip register is set.
1,Supervisorlevel external interrupts are disabled when the SEIE bit in the sie register is clear.
0,"The SBI should provide facilities to mask, unmask, and query the cause of external interrupts."
0,The UEIP field in sip contains a single read-write bit.
0,UEIP may be written by S-mode software to indicate to U-mode that an external interrupt is pending.
0,"Additionally, the platform-level interrupt controller may generate user-level external interrupts."
0,The logical-OR of the software-writeable bit and the signal from the external interrupt controller are used to generate external interrupts for user mode.
0,"When the UEIP bit is read with a CSRRW, CSRRS, or CSRRC instruction, the value returned in the rd destination register contains the logical-OR of the software-writable bit and the interrupt signal from the interrupt controller."
0,"However, the value used in the read-modify-write sequence of a CSRRS or CSRRC instruction is only the software-writable UEIP bit, ignoring the interrupt value from the external interrupt controller."
0,"Analogous to SEIP, the UIEP field behavior is designed to allow a higher privilege layer to mimic external interrupts without losing any real external interrupts."
1,User-level external interrupts are disabled when the UEIE bit in the sie register is clear.
1,"If the N extension for user-level interrupts is not implemented, UEIP and UEIE are hardwired to zero."
0,The sip and sie registers are subsets of the mip and mie registers.
0,"Reading any field, or writing any writable field, of sip/sie effects a read or write of the homonymous field of mip/mie."
0,"Supervisor software uses the same hardware performance monitoring facility as user-mode software, including the time, cycle, and instret CSRs."
0,The SBI should provide a mechanism to modify the counter values.
0,The counter-enable register scounteren controls the availability of the hardware performance monitoring counters to U-mode.
1,"When the CY, TM, IR, or HPMn bit in the scounteren register is clear, attempts to read the cycle, time, instret, or hpmcountern register while executing in U-mode will cause an illegal instruction exception."
1,"When one of these bits is set, access to the corresponding register is permitted."
0,scounteren must be implemented.
0,"However, any of the bits may contain a hardwired value of zero, indicating reads to the corresponding counter will cause an exception when executing in U-mode."
0,"The sscratch register is an XLEN-bit read/write register, dedicated for use by the supervisor."
0,"Typically, sscratch is used to hold a pointer to the hart-local supervisor context while the hart is executing user code."
0,"At the beginning of a trap handler, sscratch is swapped with a user register to provide an initial working register."
0,sepc is an XLEN-bit read/write register formatted as shown in Figure 4.8.
0,The low bit of sepc (sepc[0]) is always zero.
0,"On implementations that do not support instruction-set extensions with 16-bit instruction alignment, the two low bits (sepc[1:0]) are always zero."
0,sepc is a WARL register that must be able to hold all valid physical and virtual addresses.
0,It need not be capable of holding all possible invalid addresses.
0,Implementations may convert some invalid address patterns into other invalid addresses prior to writing them to sepc.
1,"When a trap is taken into S-mode, sepc is written with the virtual address of the instruction that encountered the exception."
0,"Otherwise, sepc is never written by the implementation, though it may be explicitly written by software."
0,The scause register is an XLEN-bit read-write register formatted as shown in Figure 4.9.
1,"When a trap is taken into S-mode, scause is written with a code indicating the event that caused the trap."
0,"Otherwise, scause is never written by the implementation, though it may be explicitly written by software."
1,The Interrupt bit in the scause register is set if the contains a code identifying the last exception.
0,"Table 4.2 lists the possible exception codes for the current supervisor ISAs, in descending order of priority."
0,"The Exception Code is an WLRL field, so is only guaranteed to hold supported exception codes."
0,The stval register is an XLEN-bit read-write register formatted as shown in Figure 4.10.
1,"When a trap is taken into S-mode, stval is written with exception-specific information to assist software in handling the trap."
0,"Otherwise, stval is never written by the implementation, though it may be explicitly written by software."
0,"When a hardware breakpoint is triggered, or an instruction-fetch, load, or store access or page-fault exception occurs, or an instruction-fetch or AMO address-misaligned exception occurs, stval is written with the faulting address."
0,"For other exceptions, stval is set to zero, but a future standard may redefine stval's setting for other exceptions."
0,"For instruction-fetch access faults and page faults on RISC-V systems with variable-length instructions, stval will point to the portion of the instruction that caused the fault while sepc will point to the beginning of the instruction."
0,The stval register can optionally also be used to return the faulting instruction bits on an illegal instruction exception (sepc points to the faulting instruction in memory).
1,"If this feature is not provided, then stval is set to zero on an illegal instruction fault."
1,"If the feature is provided, after an illegal instruction trap, stval will contain the entire faulting instruction provided the instruction is no longer than XLEN bits."
1,"If the instruction is less than XLEN bits long, the upper bits of stval are cleared to zero."
1,"If the instruction is more than XLEN bits long, stval will contain the first XLEN bits of the instruction."
0,stval is a WARL register that must be able to hold all valid physical and virtual addresses and the value 0.
0,It need not be capable of holding all possible invalid addresses.
0,Implementations may convert some invalid address patterns into other invalid addresses prior to writing them to stval.
1,"If the feature to return the faulting instruction bits is implemented, stval must also be able to hold all values less than 2N , where N is the smaller of XLEN and the width of the longest supported instruction."
0,"The satp register is an XLEN-bit read/write register, formatted as shown in Figure 4.11 for RV32 and Figure 4.12, which controls supervisor-mode address translation and protection."
0,"This register holds the physical page number (PPN) of the root page table, i.e., its supervisor physical address divided by 4 KiB; an address space identifier (ASID), which facilitates address-translation fences on a per-address-space basis; and the MODE field, which selects the current address-translation scheme."
0,Figure 4.11: RV32 Supervisor address translation and protection register satp.
0,We store the ASID and the page table base address in the same CSR to allow the pair to be changed atomically on a context switch.
0,"Swapping them non-atomically could pollute the old virtual address space with new translations, or vice-versa."
0,This approach also slightly reduces the cost of a context switch.
0,"Figure 4.12: RV64 Supervisor address translation and protection register satp, for MODE values Sv39 and Sv48."
0,Table 4.3 shows the encodings of the MODE field for RV32 and RV64.
0,"supervisor virtual addresses are equal to supervisor physical addresses, and there is no additional memory protection beyond the physical memory protection scheme described in Section 3.6."
0,"In this case, the remaining fields in satp have no effect."
0,"For RV32, the only other valid setting for MODE is Sv32, a paged virtual-memory scheme described in Section 4.3."
0,"For RV64, two paged virtual-memory schemes are defined: Sv39 and Sv48, described in Sections 4.4 and 4.5, respectively."
0,"Two additional schemes, Sv57 and Sv64, will be defined in a later version of this specification."
0,The remaining MODE settings are reserved for future use and may define different interpretations of the other fields in satp.
1,"Implementations are not required to support all MODE settings, and if satp is written with an unsupported MODE, the entire write has no effect; no fields in satp are modified."
0,The number of supervisor physical address bits is implementation-defined; any unimplemented address bits are hardwired to zero in the satp register.
0,The number of ASID bits is also
0,implementation-defined and may be zero.
0,"The number of implemented ASID bits, termed"
0,"ASIDLEN, may be determined by writing one to every bit position in the ASID field, then reading back the value in satp to see which bit positions in the ASID field hold a one."
1,"The least-significant bits of ASID are implemented first: that is, if ASIDLEN > 0, ASID[ASIDLEN-1:0] is writable."
0,"The maximal value of ASIDLEN, termed ASIDMAX, is 9 for Sv32 or 16 for Sv39 and Sv48"
0,"For many applications, the choice of page size has a substantial performance impact."
0,"A large page size increases TLB reach and loosens the associativity constraints on virtually-indexed, physically-tagged caches."
0,"At the same time, large pages exacerbate internal fragmentation, wasting physical memory and possibly cache capacity."
0," After much deliberation, we have settled on a conventional page size of 4 KiB for both RV32 and RV64."
0,We expect this decision to ease the porting of low-level runtime software and device drivers.
0,The TLB reach problem is ameliorated by transparent superpage support in modern operating systems [2].
0,"Additionally, multi-level TLB hierarchies are quite inexpensive relative to the multi-level cache hierarchies whose address space they map."
0,Note that writing satp does not imply any ordering constraints between page-table updates and subsequent address translations.
1,"If the new address space's page tables have been modified, it may be necessary to execute an SFENCE.VMA instruction (see Section 4.2.1) prior to writing satp."
0,"Not imposing upon implementations to flush address-translation caches upon satp writes reduces the cost of context switches, provided a sufficiently large ASID space."
0,"In addition to the SRET instruction defined in Section 3.2.2, one new supervisor-level instruction is provided."
0,The supervisor memory-management fence instruction SFENCE.VMA is used to synchronize updates to in-memory memory-management data structures with current execution.
0,"Instruction execution causes implicit reads and writes to these data structures; however, these implicit references are ordinarily not ordered with respect to loads and stores in the instruction stream."
0,Executing an SFENCE.VMA instruction guarantees that any stores in the instruction stream prior to the SFENCE.VMA are ordered before all implicit references subsequent to the SFENCE.VMA.
0,The SFENCE.VMA is used to flush any local hardware caches related to address translation.
0,It is specified as a fence rather than a TLB flush to provide cleaner semantics with respect to which instructions are affected by the flush operation and to support a wider variety of dynamic caching structures and memory-management schemes.
0,SFENCE.VMA is also used by higher privilege levels to synchronize page table writes and the address translation hardware.
0,"Note the instruction has no effect on the translations of other RISC-V threads, which must be notified separately."
0,"One approach is to use 1) a local data fence to ensure local writes are visible globally, then 2) an interprocessor interrupt to the other thread, then 3) a local SFENCE.VMA in the interrupt handler of the remote thread, and finally 4) signal back to originating thread that operation is complete."
0,"This is, of course, the RISC-V analog to a TLB shootdown."
0,"Alternatively, implementations might provide direct hardware support for remote TLB invalidation."
0,TLB shootdowns are handled by an SBI call to hide implementation details.
0,"For the common case that the translation data structures have only been modified for a single address mapping (i.e., one page or superpage), rs1 can specify a virtual address within that mapping to effect a translation fence for that mapping only."
0,"Furthermore, for the common case that the translation data structures have only been modified for a single address-space identifier, rs2 can specify the address space."
0,The behavior of SFENCE.VMA depends on rs1 and rs2 as follows:
0," If rs1=x0 and rs2=x0, the fence orders all reads and writes made to any level of the page tables, for all address spaces."
1,"If rs1=x0 and rs2=x0, the fence orders all reads and writes made to any level of the page tables, but only for the address space identified by integer register rs2."
0,Accesses to global mappings (see Section 4.3.1) are not ordered.
1,"If rs1=x0 and rs2=x0, the fence orders only reads and writes made to the leaf page table entry corresponding to the virtual address in rs1, for all address spaces."
1,"If rs1=x0 and rs2=x0, the fence orders only reads and writes made to the leaf page table entry corresponding to the virtual address in rs1, for the address space identified by integer register rs2."
0,Accesses to global mappings are not ordered.
1,"When rs2=x0, bits XLEN-1:ASIDMAX of the value held in rs2 are reserved for future use and should be zeroed by software and ignored by current implementations."
1,"Furthermore, if ASI DLEN < ASIDMAX, the implementation shall ignore bits ASIDMAX-1:ASIDLEN of the value held in rs2."
0,Simpler implementations can ignore the virtual address in rs1 and the ASID value in rs2 and always perform a global fence.
1,"When Sv32 is written to the MODE field in the satp register (see Section 4.1.12), the supervisor operates in a 32-bit paged virtual-memory system."
1,Sv32 is supported on RV32 systems and is designed to include mechanisms sufficient for supporting modern Unix-based operating systems.
0,The initial RISC-V paged virtual-memory architectures have been designed as straightforward implementations to support existing operating systems.
0,We have architected page table layouts to support a hardware page-table walker.
0,"Software TLB refills are a performance bottleneck on high-performance systems, and are especially troublesome with decoupled specialized coprocessors."
0,An implementation can choose to implement software TLB refills using a machine-mode trap handler as an extension to M-mode.
0,"Sv32 implementations support a 32-bit virtual address space, divided into 4 KiB pages."
0,"An Sv32 virtual address is partitioned into a virtual page number (VPN) and page offset, as shown in"
1,"When Sv32 virtual memory mode is selected in the MODE field of the satp register, supervisor virtual addresses are translated into supervisor physical addresses via a two-level page table."
0,"The 20-bit VPN is translated into a 22-bit physical page number (PPN), while the 12bit page offset is untranslated."
0,"The resulting supervisor-level physical addresses are then checked using any physical memory protection structures (Sections 3.6), before being directly converted to machine-level physical addresses."
0,"Sv32 page tables consist of 210 page-table entries (PTEs), each of four bytes."
0,A page table is exactly the size of a page and must always be aligned to a page boundary.
0,The physical page number of the root page table is stored in the satp register.
0,The PTE format for Sv32 is shown in Figures 4.15.
1,"The V bit indicates whether the PTE is valid; if it is 0, bits 31-1 of the PTE are don't-cares and may be used freely by software."
0,"The permission bits, R, W, and X, indicate whether the page is readable, writable, and executable, respectively."
1,"When all three are zero, the PTE is a pointer to the next level of the page table; otherwise, it is a leaf PTE."
0,Writable pages must also be marked readable; the contrary combinations are reserved for future use.
0,Table 4.4 summarizes the encoding of the permission bits.
0,The U bit indicates whether the page is accessible to user mode.
0,U-mode software may only access the page when U=1.
1,"If the SUM bit in the sstatus register is set, supervisor mode software may also access pages with U=1."
0,"However, supervisor code normally operates with the SUM bit clear, in which case, supervisor code will fault on accesses to user-mode pages."
0,An alternative PTE format would support different permissions for supervisor and user.
0,We omitted this feature because it would be largely redundant with the SUM mechanism (see Section 4.1.3) and would require more encoding space in the PTE.
0,The G bit designates a global mapping.
0,Global mappings are those that exist in all address spaces.
0,"For non-leaf PTEs, the global setting implies that all mappings in the subsequent levels of the page table are global."
0,"Note that failing to mark a global mapping as global merely reduces performance, whereas marking a non-global mapping as global is an error."
0,"Additionally, they need not be flushed from local address-translation caches when an The RSW field is reserved for use by supervisor software; the implementation shall ignore this field."
0,Each leaf PTE contains an accessed (A) and dirty (D) bit.
0,"The A bit indicates the virtual page has been read, written, or fetched from since the last time the A bit was cleared."
0,The D bit indicates the virtual page has been written since the last time the D bit was cleared.
0," When a virtual page is accessed and the A bit is clear, or is written and the D bit is clear, the implementation sets the corresponding bit in the PTE."
0,"The PTE update must be atomic with respect to other accesses to the PTE, and must atomically check that the PTE is valid and grants sufficient permissions."
0,"The PTE update must be exact (i.e., not speculative), and observed in program order by the local hart."
0,The ordering on loads and stores provided by FENCE instructions and the acquire/release bits on atomic instructions also orders the PTE updates associated with those loads and stores as observed by remote harts.
1,"When a virtual page is accessed and the A bit is clear, or is written and the D bit is clear, a page-fault exception is raised."
0,Standard supervisor software should be written to assume either or both PTE update schemes may be in effect.
0,"Mandating that the PTE updates to be exact, atomic, and in program order simplifies the specification, and makes the feature more useful for system software."
0,Simple implementations may instead generate page-fault exceptions.
0, The A and D bits are never cleared by the implementation.
1,"If the supervisor software does not rely on accessed and/or dirty bits, e.g. if it does not swap memory pages to secondary storage or if the pages are being used to map I/O space, it should always set them to 1 in the PTE to improve performance."
0,"Any level of PTE may be a leaf PTE, so in addition to 4 KiB pages, Sv32 supports 4 MiB megapages."
0,A megapage must be virtually and physically aligned to a 4 MiB boundary; a page-fault exception is raised if the physical address is insufficiently aligned.
0,"For non-leaf PTEs, the D, A, and U bits are reserved for future use and must be cleared by software for forward compatibility."
0,"Let a be satp.ppn  PAGESIZE, and let i=LEVELS 1."
0,"(For Sv32, PAGESIZE=212 and LEVELS=2.)"
0,Let pte be the value of the PTE at address a+va.vpn[i]PTESIZE.
0,"(For Sv32, PTESIZE=4.)"
1,"If accessing pte violates a PMA or PMP check, raise an access exception."
1,"If pte.v=0, or if pte.r=0 and pte.w=1, stop and raise a page-fault exception."
0,"4.Otherwise, the PTE is valid."
1,"If pte.r=1 or pte.x=1, go to step 5."
0,"Otherwise, this PTE is a pointer to the next level of the page table."
1,"If i < 0, stop and raise a page-fault exception."
1,"Otherwise, let a=pte.ppn  PAGESIZE and go to step 2."
0,5.A leaf PTE has been found.
0,"Determine if the requested memory access is allowed by the pte.r, pte.w, pte.x, and pte.u bits, given the current privilege mode and the value of the SUM and MXR fields of the mstatus register."
0,"If not, stop and raise a page-fault exception."
1,"If i > 0 and pa.ppn[i 1 : 0]=0, this is a misaligned superpage; stop and raise a page-fault exception."
0,"If	pte.a=0, or if the memory access is a store and pte.d=0, either raise a page-fault exception or:"
1,"Set pte.a to 1 and, if the memory access is a store, also set pte.d to 1."
1,"If this access violates a PMA or PMP check, raise an access exception."
0,"This update and the loading of pte in step 2 must be atomic; in particular, no intervening store to the PTE may be perceived to have occurred in-between."
0,The translation is successful.
0,The translated physical address is given as follows:
1,"If i > 0, then this is a superpage translation and pa.ppn[i 1 : 0]=va.vpn[i 1 : 0]."
0,pa.ppn[LEVELS 1 : i]=pte.ppn[LEVELS 1 : i].
0,"This section describes a simple paged virtual-memory system designed for RV64 systems, which supports 39-bit virtual address spaces."
0,"The design of Sv39 follows the overall scheme of Sv32, and this section details only the differences between the schemes."
0,We specified multiple virtual memory systems for RV64 to relieve the tension between providing a large address space and minimizing address-translation cost.
0,"For many systems, 512 GiB of virtual-address space is ample, and so Sv39 suffices."
0,"Sv48 increases the virtual address space to 256 TiB, but increases the physical memory capacity dedicated to page tables, the latency of page-table traversals, and the size of hardware structures that store virtual addresses."
0,"Sv39 implementations support a 39-bit virtual address space, divided into 4 KiB pages."
0,An Sv39 address is partitioned as shown in Figure 4.16.
0,"Load and store effective addresses, which are 64 bits, must have bits 63-39 all equal to bit 38, or else a page-fault exception will occur."
0,"The 27-bit VPN is translated into a 44-bit PPN via a three-level page table, while the 12-bit page offset is untranslated."
0,"Sv39 page tables contain 29 page table entries (PTEs), eight bytes each."
0,A page table is exactly the size of a page and must always be aligned to a page boundary.
0,The physical page number of the root page table is stored in the satp register's PPN field.
0,The PTE format for Sv39 is shown in Figure 4.18.
0,Bits 9-0 have the same meaning as for Sv32.
0,Bits 63-54 are reserved for future use and must be zeroed by software for forward compatibility.
0,"We reserved several PTE bits for a possible extension that improves support for sparse address spaces by allowing page-table levels to be skipped, reducing memory usage and TLB refill latency."
0,These reserved bits may also be used to facilitate research experimentation.
0,"The cost is reducing the physical address space, but 64 PiB is presently ample."
1,"When it no longer suffices, the reserved bits that remain unallocated could be used to expand the physical address space."
0,"Any level of PTE may be a leaf PTE, so in addition to 4 KiB pages, Sv39 supports 2 MiB megapages and 1 GiB gigapages, each of which must be virtually and physically aligned to a boundary equal to its size."
0,A page-fault exception is raised if the physical address is insufficiently aligned.
0,"The algorithm for virtual-to-physical address translation is the same as in Section 4.3.2, except LEVELS equals 3 and PTESIZE equals 8."
0,"This section describes a simple paged virtual-memory system designed for RV64 systems, which supports 48-bit virtual address spaces."
0,Sv48 is intended for systems for which a 39-bit virtual address space is insufficient.
0,"It closely follows the design of Sv39, simply adding an additional level of page table, and so this chapter only details the differences between the two schemes."
0,"Sv48 implementations support a 48-bit virtual address space, divided into 4 KiB pages."
0,An Sv48 address is partitioned as shown in Figure 4.19.
0,"Load and store effective addresses, which are 64 bits, must have bits 63-48 all equal to bit 47, or else a page-fault exception will occur."
0,"The 36-bit VPN is translated into a 44-bit PPN via a four-level page table, while the 12-bit page offset is untranslated."
0,The PTE format for Sv48 is shown in Figure 4.21.
0,Bits 9-0 have the same meaning as for Sv32.
0,"Any level of PTE may be a leaf PTE, so in addition to 4 KiB pages, Sv48 supports 2 MiB megapages, 1 GiB gigapages, and 512 GiB terapages, each of which must be virtually and physically aligned to a boundary equal to its size."
0,A page-fault exception is raised if the physical address is insufficiently aligned.
0,"The algorithm for virtual-to-physical address translation is the same as in Section 4.3.2, except LEVELS equals 4 and PTESIZE equals 8."
0,This chapter is a placeholder for RISC-V hypervisor support with an extended S-mode.
0,"where a guest OS is run at user-level, as the few privileged instructions can be easily detected and trapped."
0,This chapter presents instruction set listings for all instructions defined in the RISC-V Privileged Architecture.
0,"This chapter describes the general architecture for the RISC-V platform-level interrupt controller (PLIC), which prioritizes and distributes global interrupts in a RISC-V system."
0,Figure 7.1 provides a quick overview of PLIC operation.
0,"The PLIC connects global interrupt sources, which are usually I/O devices, to interrupt targets, which are usually hart contexts."
0,"The PLIC contains multiple interrupt gateways, one per interrupt source, together with a PLIC core that performs interrupt prioritization and routing."
0,"Global interrupts are sent from their source to an interrupt gateway that processes the interrupt signal from each source and sends a single interrupt request to the PLIC core, which latches these in the core interrupt pending bits (IP)."
0,Each interrupt source is assigned a separate priority.
0,The PLIC core contains a matrix of interrupt enable (IE) bits to select the interrupts that are enabled for each target.
0,"The PLIC core forwards an interrupt notification to one or more targets if the targets have any pending interrupts enabled, and the priority of the pending interrupts exceeds a per-target threshold."
1,"When the target takes the external interrupt, it sends an interrupt claim request to retrieve the identifier of the highestpriority global interrupt source pending for that target from the PLIC core, which then clears the corresponding interrupt source pending bit."
1,"After the target has serviced the interrupt, it sends the associated interrupt gateway an interrupt completion message and the interrupt gateway can now forward another interrupt request for the same source to the PLIC."
0,"The rest of this chapter describes each of these components in detail, though many details are necessarily platform specific."
0,RISC-V harts can have both local and global interrupt sources.
0,Only global interrupt sources are handled by the PLIC.
0,Figure 7.1: Platform-Level Interrupt Controller (PLIC) conceptual block diagram.
0,"The figure shows the first two of potentially many interrupt sources, and the first two of potentially many interrupt targets."
0,"The figure is just intended to show the logic of the PLIC's operation, not to represent a realistic implementation strategy."
0,"Each hart has a number of local interrupt sources that do not pass through the PLIC, including the standard software interrupts and timer interrupts for each privilege level."
0,"Local interrupts can be serviced quickly since there will be minimal latency between the source and the servicing hart, no arbitration is required to determine which hart will service the request, and the servicing hart can quickly determine the interrupt source using the mcause register."
0,"All local interrupts follow a level-based model, where an interrupt is pending if the corresponding bit in mip is set."
0,The interrupt handler must clear the hardware condition that is causing the mip bit to be set to avoid retaking the interrupt after re-enabling interrupts on exit from the interrupt handler.
0,"Additional non-standard local interrupt sources can be made visible to machine-mode by adding them to the high bits of the mip/mie registers, with corresponding additional cause values returned in the mcause register."
0,"These additional non-standard local interrupts may also be made visible to lower privilege levels, using the corresponding bits in the mideleg register."
0,"The priority of nonstandard local interrupt sources relative to external, timer, and software interrupts is platformspecific."
0,Global interrupt sources are those that are prioritized and distributed by the PLIC.
0,"Depending on the platform-specific PLIC implementation, any global interrupt source could be routed to any hart context."
0,"Global interrupt sources can take many forms, including level-triggered, edge-triggered, and message-signalled."
0,Some sources might queue up a number of interrupt requests.
0,All global interrupt sources are converted to a common interrupt request format for the PLIC.
0,"Interrupt targets are usually hart contexts, where a hart context is a given privilege mode on a given hart (though there are other possible interrupt targets, such as DMA engines)."
1,"Not all hart contexts need be interrupt targets, in particular, if a processor core does not support delegating external interrupts to lower-privilege modes, then the lower-privilege hart contexts will not be interrupt targets."
0,Interrupt notifications generated by the PLIC appear in the meip/seip/ueip bits of the mip/sip/uip registers for M/S/U modes respectively.
1,The notifications only appear in lower-privilege xip registers if external interrupts have been delegated to the lower-privilege modes.
0,Each processor core must define a policy on how simultaneous active interrupts are taken by multiple hart contexts on the core.
0,"the simple case of a single stack of hart contexts, one"
0,"for each supported privileged mode, interrupts for higher-privilege contexts can preempt execution of interrupt handlers for lower-privilege contexts."
0,A multithreaded processor core could run multiple independent interrupt handlers on different hart contexts at the same time.
0,"A processor core could also provide hart contexts that are only used for interrupt handling to reduce interrupt service latency, and these might preempt interrupt handlers for other harts on the same core."
0,The PLIC treats each interrupt target independently and does not take into account any interrupt prioritization scheme used by a component that contains multiple interrupt targets.
0,"As a result, the PLIC provides no concept of interrupt preemption or nesting so this must be handled by the cores hosting multiple interrupt target contexts."
0,"The interrupt gateways are responsible for converting global interrupt signals into a common interrupt request format, and for controlling the flow of interrupt requests to the PLIC core."
0,"At most one interrupt request per interrupt source can be pending in the PLIC core at any time, indicated by setting the source's IP bit."
0,The gateway only forwards a new interrupt request to the PLIC core after receiving notification that the interrupt handler servicing the previous interrupt request from the same source has completed.
1,"If the global interrupt source uses level-sensitive interrupts, the gateway will convert the first assertion of the interrupt level into an interrupt request, but thereafter the gateway will not forward an additional interrupt request until it receives an interrupt completion message."
1,"On receiving an interrupt completion message, if the interrupt is level-triggered and the interrupt is still asserted, a new interrupt request will be forwarded to the PLIC core."
0,The gateway does not have the facility to retract an interrupt request once forwarded to the PLIC core.
1,"If a level-sensitive interrupt source deasserts the interrupt after the PLIC core accepts the request and before the interrupt is serviced, the interrupt request remains present in the IP bit of the PLIC core and will be serviced by a handler, which will then have to determine that the interrupt device no longer requires service."
1,"If the global interrupt source was edge-triggered, the gateway will convert the first matching signal edge into an interrupt request."
0,"Depending on the design of the device and the interrupt handler, inbetween sending an interrupt request and receiving notice of its handler's completion, the gateway might either ignore additional matching edges or increment a counter of pending interrupts."
0,"In either case, the next interrupt request will not be forwarded to the PLIC core until the previous completion message has been received."
1,"If the gateway has a pending interrupt counter, the counter will be decremented when the interrupt request is accepted by the PLIC core."
0,"Unlike dedicated-wire interrupt signals, message-signalled interrupts (MSIs) are sent over the system interconnect via a message packet that describes which interrupt is being asserted."
0,"The message is decoded to select an interrupt gateway, and the relevant gateway then handles the MSI similar to an edge-triggered interrupt."
1,"Global interrupt sources are assigned small unsigned integer identifiers, beginning at the value 1."
0,An interrupt ID of 0 is reserved to mean no interrupt.
0,Interrupt identifiers are also used to break ties when two or more interrupt sources have the same assigned priority.
0,Smaller values of interrupt ID take precedence over larger values of interrupt ID.
0,"Interrupt priorities are small unsigned integers, with a platform-specific maximum number of supported levels."
1,"The priority value 0 is reserved to mean never interrupt, and interrupt priority increases with increasing integer values."
0,Each global interrupt source has an associated interrupt priority held in a platform-specific memorymapped register.
0,Different interrupt sources need not support the same set of priority values.
0,A valid implementation can hardwire all input priority levels.
0,"Interrupt source priority registers should be WARL fields to allow software to determine the number and position of read-write bits in each priority specification, if any."
0,"To simplify discovery of supported priority values, each priority register must support any combination of values in the bits that are variable within the register, i.e., if there are two variable bits in the register, all four combinations of values in those bits must operate as valid priority levels."
0,"In the degenerate case, all priorities can be hardwired to the value 1, in which case input priorities are effectively determined by interrupt ID."
0, The supported priority values can be determined as follows: 1) write all zeros to the priority register then 2) read back the value.
0,Any set bits are hardwired to 1.
0,"to the register, and 4) read back the value."
0,Any clear bits are hardwired to 0.
0,Any set bits that were not found to be hardwired in step 2 are variable.
0,The supported priority levels are the set of values obtained by substituting all combinations of ones and zeros in the variable bits within the priority field.
0,"Each target has a vector of interrupt enable (IE) bits, one per interrupt source."
0,The target will not receive interrupts from sources that are disabled.
0,The IE bits for a single target should be packed together as a bit vector in platform-specific memory-mapped control registers to support rapid context switching of the IE bits for a target.
1,IE bits are WARL fields that can be hardwired to either 0 or 1.
1,A large number of potential IE bits might be hardwired to zero in cases where some interrupt sources can only be routed to a subset of targets.
0, A larger number of bits might be wired to 1 for an embedded device with fixed interrupt routing.
0,"Interrupt priorities, thresholds, and hart-internal interrupt masking provide considerable flexibility in ignoring external interrupts even if a global interrupt source is always enabled."
0,"Each interrupt target has an associated priority threshold, held in a platform-specific memorymapped register."
0,Only active interrupts that have a priority strictly greater than the threshold will cause a interrupt notification to be sent to the target.
0,Different interrupt targets need not support the same set of priority threshold values.
0,Interrupt target threshold registers should be WARL fields to allow software to determine the supported thresholds.
0,"A threshold register should always be able to hold the value zero, in which case, no interrupts are masked."
1,"If implemented, the threshold register will usually also be able to hold the maximum priority level, in which case all interrupts are masked."
1,"A simple valid implementation is to hardwire the threshold to zero, in which case it has no effect, and the individual enable bits will have to be saved and restored to attain the same effect."
1,"While the function of the threshold can be achieved by changing the interrupt-enable bits, manipulating a single threshold value avoids the target having to consider the individual priority levels of each interrupt source, and saving and restoring all the interrupt enables."
0,Changing the threshold quickly might be especially important for systems that move frequently between power states.
0,Each interrupt target has an external interrupt pending (EIP) bit in the PLIC core that indicates that the corresponding target has a pending interrupt waiting for service.
0,"The value in EIP can change as a result of changes to state in the PLIC core, brought on by interrupt sources, interrupt targets, or other agents manipulating register values in the PLIC."
0,The value in EIP is communicated to the destination target as an interrupt notification.
1,"If the target is a RISC-V hart context, the interrupt notifications arrive on the meip/seip/ueip bits depending on the privilege level of the hart context."
0,"In simple systems, the interrupt notifications will be simple wires connected to the processor implementing a hart."
0,"In more complex platforms, the notifications might be routed as messages across a system interconnect."
0,"The PLIC hardware only supports multicasting of interrupts, such that all enabled targets will receive interrupt notifications for a given active interrupt."
1,"Multicasting provides rapid response since the fastest responder claims the interrupt, but can be wasteful in high-interrupt-rate scenarios if multiple harts take a trap for an interrupt that only one can successfully claim."
0,"Software can modulate the PLIC IE bits as part of each interrupt handler to provide alternate policies, such as interrupt affinity or round-robin unicasting."
0,"Depending on the platform architecture and the method used to transport interrupt notifications, these might take some time to be received at the targets."
0,"The PLIC is guaranteed to eventually deliver all state changes in EIP to all targets, provided there is no intervening activity in the PLIC core."
0,The value in an interrupt notification is only guaranteed to hold an EIP value that was valid at some point in the past.
0,"In particular, a second target can respond and claim an interrupt while a notification to the first target is still in flight, such that when the first target tries to claim the interrupt it finds it has no active interrupts in the PLIC core."
0,"Sometime after a target receives an interrupt notification, it might decide to service the interrupt."
0,"The target sends an interrupt claim message to the PLIC core, which will usually be implemented as a non-idempotent memory-mapped I/O control register read."
0,"On receiving a claim message, the PLIC core will atomically determine the ID of the highest-priority pending interrupt for the target and then clear down the corresponding source's IP bit."
0,The PLIC core will then return the ID to the target.
1,"The PLIC core will return an ID of zero, if there were no pending interrupts for the target when the claim was serviced."
1,"After the highest-priority pending interrupt is claimed by a target and the corresponding IP bit is cleared, other lower-priority pending interrupts might then become visible to the target, and so the PLIC EIP bit might not be cleared after a claim."
0,"The interrupt handler can check the local meip/seip/ueip bits before exiting the handler, to allow more efficient service of other interrupts without first restoring the interrupted context and taking another interrupt trap."
1,It is always legal for a hart to perform a claim even if the EIP is not set.
0,"In particular, a hart could set the threshold value to maximum to disable interrupt notifications and instead poll for active interrupts using periodic claim requests, though a simpler approach to implement polling would be to clear the external interrupt enable in the corresponding xie register for privilege mode x."
1,"After a handler has completed service of an interrupt, the associated gateway must be sent an interrupt completion message, usually as a write to a non-idempotent memory-mapped I/O control register."
0,The gateway will only forward additional interrupts to the PLIC core after receiving the completion message.
0,Figure 7.2 shows the messages flowing between agents when handling interrupts via the PLIC.
0,"The gateway will only forward a single interrupt request at a time to the PLIC, and not forward subsequent interrupts requests until an interrupt completion is received."
1,"The PLIC will set the IP bit once it accepts an interrupt request from the gateway, and sometime later forward an interrupt notification to the target."
1,"The target might take a while to respond to a new interrupt arriving, but will then send an interrupt claim request to the PLIC core to obtain the interrupt ID."
0,"The PLIC core will atomically return the ID and clear the corresponding IP bit, after which no other target can claim the same interrupt request."
0,"Once the handler has processed the interrupt, it sends an interrupt completion message to the gateway to allow a new interrupt request."
0,Write Register: A message containing a register write request is dequeued.
1,"One of the internal registers is written, where an internal register can be a priority, an interrupt-enable (IE), or a threshold."
1,"Accept Request: If the IP bit corresponding to the interrupt source is clear, a message containing an interrupt request from a gateway is dequeued and the IP bit is set."
0,Process Claim: An interrupt claim message is dequeued.
1,"A claim-response message is enqueued to the requester with the ID of the highest-priority active interrupt for that target, and the IP bit corresponding to this interrupt source is cleared."
0,The value in the EIP bit is determined as a combinational function of the PLIC Core state.
1,Interrupt notifications are sent via an autonomous process that ensures the EIP value is eventually reflected at the target.
0,Note that the operation of the interrupt gateways is decoupled from the PLIC core.
1,A gateway can handle parsing of interrupt signals and processing interrupt completion messages concurrently with other operations in the PLIC core.
0,Figure 7.1 is a high-level conceptual view of the PLIC design.
0,The PLIC core can be implemented in many ways provided its behavior can always be understood as following from some sequential ordering of these atomic actions.
0,"In particular, the PLIC might process multiple actions in a single clock cycle, or might process each action over many clock cycles."
0,"In the expected use case, only machine mode accesses the source priority, source pending, and target interrupt enables to configure the interrupt subsystem."
0,Lower-privilege modes access these features via ABI or SBI calls.
0,The interrupt enables act as a protection mechanism where a target can only signal completion to an interrupt gateway that is currently enabled for that target.
0,"Interrupt handlers that run with lower than machine-mode privilege need only be able to perform a claim read and a completion write, and to set their target threshold value."
0,"The memory map for these registers should allow machine mode to protect different targets from each other's accesses, using either physical memory protection or virtual memory page protections."
0,"To reduce porting effort for OS boots, we have reverted back to using Device Trees to communicate platform information to the kernel, so this chapter is out of date."
0,"Config string was designed for other uses in addition, but for now, we are staying with a standard device tree model."
0,"RISC-V platforms may contain myriad devices, processor cores, and configuration parameters."
0,"To support higher-level software, including bootloaders and operating systems, it is recommended that hardware platforms embed a description of their components in read-only memory that is directly accessible after processor reset for use by low-level system software, external debuggers, or manufacturing test procedures."
0,We call this low-level embedded information a configuration description.
0,"We define here a standard mechanism to encode and locate the configuration information, and to determine the format of the configuration information."
0,"The platform must describe how to locate a pointer to find this string, for example, by specifying a fixed physical address at which the pointer resides."
0,"To support a wide variety of platforms, configuration formats, and chips with manufacturing-time programming of configuration options, a flexible search procedure is defined to locate the configuration information seeded by the initial pointer specified by the platform."
0,The configuration string pointer provided by the platform points to an initial memory address at which the search for configuration string begins.
1,"The configuration string cannot begin with a padding byte, where a padding byte is defined to contain either 0x0 or 0xff, but can be preceded by up to 63 padding bytes that are ignored."
1,"If 64 padding bytes are encountered, then the search terminates without finding a config string."
0,The padding bytes represent common values returned by unpopulated memory or bus regions or unprogrammed non-volatile memory.
0,"Configuration strings can therefore include pointers to regions that are optionally populated or programmed, and these regions will be ignored if there is nothing present."
0,The padding bytes also support alignment of binary data structures.
0,Otherwise the first non-padding byte is the beginning of the configuration information.
0,"For example, configuration information in Device Tree String format would begin with a /dts-v1/."
0,Configuration information in the config string format would begin with /cs-v1/.
0,specs exist) but can include additional configuration information in other memory regions.
0,Development of the RISC-V architecture and implementations has been partially funded by the following sponsors.
0, Par Lab: Research supported by Microsoft (Award #024263) and Intel (Award #024894) funding and by matching funding by U.C.
0,Discovery (Award #DIG07-10227).
0,"Additional support came from Par Lab affiliates Nokia, NVIDIA, Oracle, and Samsung."
0,"ASPIRE Lab: DARPA PERFECT program, Award HR0011-12-2-0016."
0,DARPA POEM program Award HR0011-11-C-0100.
0,"The Center for Future Architectures Research (C-FAR), a STARnet center funded by the Semiconductor Research Corporation."
0,"Additional support from ASPIRE industrial sponsor, Intel, and ASPIRE affiliates, Google, Huawei, Nokia, NVIDIA, Oracle, and Samsung."
0,The content of this paper does not necessarily reflect the position or the policy of the US government and no official endorsement should be inferred.
0,[1]Robert P. Goldberg.
0,Survey of virtual machine research.
0,"Computer, 7(6):34-45, June 1974."
0,"[2]Juan Navarro, Sitararn Iyer, Peter Druschel, and Alan Cox."
0,"Practical, transparent operating system support for superpages."
0,"Rev., 36(SI):89-104, December 2002."
0,"Two weeks ago, we released a blog, where we discussed the evolution of data center security, and how the OCP Security workgroup has been chartered to come up with a set of specifications."
0,"These specifications will help open compute systems meet the evolving hardware security requirements of the NIST SP 800-193 firmware resilience guidelines, and protect, detect and recover from firmware attacks."
0,"In this blog, we would like to share more details and point you at the set of OCP Security specs."
0,"The OCP model for protecting a platform is based on the concept that every device must first have a Root of Trust (RoT) that is responsible for verifying the device firmware at boot, keeping it authentic during updates, and recovering it when a corruption occurs."
0,"The Device/Peripherals are various extension cards, such as NICs, HBAs, SSDs, etc."
0,Platform Firmware typically resides on a set of SPI Flash components and is loaded into the CPU and/or BMC of the system during boot.
0,"Device Firmware, which typically resides on and executed on the device."
0,The Platform Active RoT (PA RoT) is the main RoT for the platform.
0,"It is responsible for verifying the system firmware, and for verifying the integrity of the peripherals."
0,"The Active Component RoT (AC RoT) resides on every peripheral, verifies the integrity of that specific peripheral, and should report back, in a process called attestation, to the platform to prove its integrity."
0,The process for doing that is called peripheral attestation.
0,"When a system boots, each component (each device, as well as each peripheral) must first boot securely, using the RoT to ensure authenticity of its firmware, by verifying the firmwares cryptographic signatures, and matching that to a policy that is defined by the system owner for authorizing only valid firmware signers."
0,"Then, the PA RoT is responsible for requiring all devices in the system to attest to prove in an irrefutable way that the firmware it is running is indeed what is expected."
0,"This process basically collects firmware measurements from all the devices, in a secure protocol, matching them also with a unique identity that each device is required to have, and policies to define what measurements are acceptable."
0,"Once a PA RoT has booted the platform successfully, and has attested all devices, the platform is considered to be secured."
0,"It is worth noting that in a typical data center, the whole platform also usually needs to attest to some external management fabric before being allowed to access other critical resources on the network."
0,"This platform-level attestation is usually handled with a TPM on the motherboard, using protocols that are defined by the Trusted Computing Group (TCG)."
0,The OCP Security group embraces these protocols and does not aim at replacing them in any way.
0,Secure Boot covers the requirements needed in order to be able to verify firmware integrity during boot.
0,"Peripheral Attestation covers the requirements for having a unique identity for every device, and the ability to securely communicate device measurements from the AC RoT to the PA RoT."
0,"Threats Scope a document that explains the various threat vectors being defended against, and helps map each of them to relevant feature requirements in the specs."
0,"This document also has, in the appendix, a conformance checklist that vendors will be expected to provide to the OCP community."
0,"Keeping firmware integrity is critically important, but security is not complete until the firmware itself is improved to minimize chances of vulnerabilities."
0,"To that end, OCP has partnered with the Cloud Security Industry Summit organization (CSIS), and together published a Secure Firmware Development Best Practices Document residing in the OCP Github, that outlines critical requirements for developing secure firmware, along with a checklist that any firmware developer should follow."
0,We encourage the community to contribute to this document and make it a living piece of information that continuously incorporates new and improved best practices.
0,"As part of the Open Compute initiative to help customers know what to expect from compliant systems, there will be a new system to get OSF compliance badges."
0,"Similarly, OCP Security has defined a three-level badge that vendors can claim compliance to."
0,We expect the badge system to take effect during 2021.
0,"Bronze For platforms and devices that implement all secure boot and attestation mandatory features support, and have provided the necessary conformance statement based on the threats that they have addressed."
0,"Silver For platforms that, in addition to meeting the Bronze requirements, have also implemented platform recovery, and are willing to open parts of their solution to the community."
0,"Gold For platforms that have implemented all the silver requirements, have implemented the optional features in the OCP specifications, and are fully open sourcing their root-of-trust firmware for community scrutiny."
0,"The badge system will be updated on a yearly basis, and OCP will look forward to seeing many OCP platforms going after the gold badge for 2021."
0,"Many member companies have contributed to these specs, and we would like to use this opportunity to thank everyone for their contributions."
0,The OCP Security work is not complete.
0,"We are now working on the next round of specs, which will cover Secure Firmware Updates and Recovery, Platform Requirements, and more."
0,You can expect these to be released in the coming months.
0,You are also invited to join the security sessions during Tech Week.
0,"Just go to the event agenda, and select the Security track sessions to see whats happening."
0,VCC is the main power supply.
0,It is driven from an external source and is used to power the internal VCMAIN and VCAON power domains.
0,VCC must always be present when the device is functioning; VCC is also used to power a number of pads that must be always on when the device is functioning.
0,Analog blocks power supply.
0,AVCC and AGND are analog supply and ground signals for the AST analog functions.
0,They mainly serve for ADC and USB clock functionality.
0,AVCC is expected to be driven by the same voltage regulator and have similar power availability as VCC.
0,AVCC and AGND have dedicated package balls/pins.
0,"In the future, package pins sharing with VCC and GND may be considered based on post-silicon test results."
0,The core supplies are generated from the VCC supply.
0,There are two core supply domains: VCMAIN and VCAON.
0,"VCAON, as its name implies, is the always-on core supply used to power components that stay active during device low power states."
0,"VCMAIN on the other hand, powers most chip logic such as RISC-V processor, crypto modules and almost all memories and peripherals."
0,"The VCMAIN supply can be turned off when requested, VCAON on the other hand, is active whenever VCC is active."
0,AST core logic is powered by VCAON.
0,VCMAIN is the only supply that can be directly influenced by OpenTitan.
0,The power manager can request VCMAIN to shutdown through main_pd_ni.
0,The state of VCMAIN is reflected by the vcmain_pok_o signal.
0,The root clocks and resets are generated inside AST.
0,"However, the clocks go through gating and optional division in the OpenTitan top level and propagate back into AST as feedback clocks, each with associated synchronized reset de-assertion to ensure it can synchronize with the various comportable modules."
0,The input resets are used for the different AST interface functions.
0,"For further details about AST resets, see Resets section."
0,The leaf clocks may be divided down from the root clock and that frequency is used to drive the interface.
0,"For example, clk_src_io_clk_o is 96MHz, but comportable modules use either 48MHz or 24MHz."
0,The leaf clocks and root clocks have very different clock tree depths and may be difficult for timing closure if they interacted directly.
0,Decouple AST internal design from OpenTitan top-level interfaces clock and reset selection.
0,"In PROD*/DEV Lifecycle states, the ROM code must copy all AST REGA registers values from OTP to AST."
0,"During other Lifecycle states, the ROM code may also copy all AST REGA registers."
0,It is recommended for the ROM code to condition the copy by a digest verification of the register values.
0,"If such a digest is too complicated, a simple tag can be used to condition the copy instead."
0,The AST register copy operation must be performed in order and must include all REGA registers (starting from REGA0 and ending at the last REGA).
0,AST sets the ast_init_done_o signal after the copy completion.
0,"After the copy, ROM code can either poll for ast_init_done_o assertion with 100 us timeout (in practice, it should take way less) or ignore it and let the next SW layers handle it."
0,It is recommended to set an OTP field for determining the ROM code action.
0,The boot code is expected to check all AST output alert signals before handing over the control to the next code layer (ROM_EXT).
0,The ROM code response per alert should be defined in a dedicated OTP space.
0,"Recommended response types (per alert): Note that in TEST_UNLOCK*/RMA state, the booter should always act per #1 regardless of the OTP setting."
0,It is recommended to redundantly code the OTP fields that control the ROM code branching and also to protect the branching code from fault injection.
0,AST contains an analog to digital converter that can be used to sample various input signals.
0,For OpenTitan this will primarily be used for debug cable detection.
0,"To activate the ADC, the corresponding comportable module must first activate the ADC through adc_pd_i."
0,"Once activated, it should select the channel to sample."
0,Channel transition from zero to non-zero value starts the ADC conversion.
0,The ADC output is synchronous to the ADC controller.
0,AST consumes entropy for defensive purposes.
0,"However, AST does not consume its raw entropy directly."
0,"Instead, AST receives entropy from the Entropy Distribution Network (EDN)."
0,Note that entropy_ack and entropy_i are packed into enropy_rsp_i in the interface.
0,"Also note that once entropy_req_o is set, it will remain set until ack or until reset."
0,"ASTs sensors and detectors, when triggered, output alert events to a sensor controller."
0,The event signals are level until acknowledged by the controller.
0,"Further, the events are differentially encoded to ensure they cannot be hard-wired or faulted to either 1 or 0."
0,"Inside the sensor controller, the events are then converted into alerts as part of the wider OpenTitan alert handling system."
0,Outgoing alert events are level.
0,Incoming event ack signals clear the alert event (similar to an interrupt).
0,"Outgoing alert events should be ORd inside the sensor or power manager (depending on what level of deep sleep support is needed) to generate wakeup, that way AST does not need to do any additional handling for wakeups during low power mode."
0,"The AST defines each alert signal in both positive (P) and negative (N) polarity (see ast_dif_t typedef with p and n signals), however, the P and N signals are not necessarily fully differential, for example, at times, it might occur that both P and N are at the same value."
0,"For alert_o case, the correct way to treat it is to propagate an alert signal if either P is high or N is low."
0,Most countermeasure enablement is controlled by Nuvoton via the registers interface.
0,Clock jitter is an exception because there is a reasoning for dynamically turning it on and off (security/performance tradeoff).
0,"Unless stated otherwise, countermeasures are active in all modes but deep-sleep."
0,This document specifies the Cryptographically Secure Random Number Generator (CSRNG) hardware IP functionality.
0,"Due to the importance of secure random number generation (RNG), it is a topic which is extensively covered in security standards."
0,"This IP targets compliance with both BSIs AIS31 recommendations for Common Criteria (CC), as well as NISTs SP 800-90A and NISTs SP 800-90C (Second Draft), both of which are referenced in FIPS 140-3."
0,"Since these two standards use significantly different terminology, it is recommended that the reader refer to our RNG compliance strategy document for an overview of the various RNG classes and equivalencies between the two standards."
0,The CSRNG IP supports both of these standards for both deterministic (DRNG) and true random number generation (TRNG).
0,"In NIST terms, it works with the Entropy Source IP to satisfy the requirements as a deterministic random bit generator (DRBG) or non-deterministic random bit generator (NRBG)."
0,"In AIS31 language, this same implementation can be used to satisfy either the DRG.3 requirements for deterministic generation, or the PTG.3 requirements for cryptographically processed physical generation."
0,In this document the terms DRNG and TRNG are used most generally to refer to deterministic or true random number generation functionalities implemented to this specification.
0,"However, the terms DRBG or NRBG are specifically used when respectively referring to SP 800-90A or SP 800-90C requirements."
0,"Meanwhile, when addressing requirements which originate from AIS31 we refer to the specific DRG.3 or PTG.3 classes of RNGs."
0,"This IP block is attached to the chip interconnect bus as a peripheral module conforming to the comportability definition and specification, but also has direct hardware links to other IPs for secure and software-inaccessible transmission of random numbers."
0,The bus connections to peripheral modules are done using the CSRNG application interface.
0,"This interface allows peripherals to manage CSRNG instances, and request the CSRNG module to return obfuscated entropy."
0,"Provides support for both deterministic (DRNG) and true random number generation (TRNG), when combined with a secure entropy source (i.e."
0,"one constructed and implemented in compliance with SP 800-90A,B,C and AIS31)."
0,The TRNG mode is provided directly by the entropy source.
0,Compliant with NIST and BSI recommendations for random number generation.
0,Hardware peripherals and software applications issue commands to dedicated RNG instances through a common application interface.
0,"In deterministic mode, meets the requirements given in AIS31 for a DRG.3 class deterministic random number generator (DRNG) meaning it provides Forward Secrecy and Enhanced Backward Secrecy."
0,"Utilizes the CTR_DRBG construction specified in NIST SP 800-90A, qualifying it as a NIST-approved deterministic random bit generator (DRBG)."
0,"Each instance has its own internal state, control, reseed counters and IO pins."
0,The number of CSRNG instances is set via a module parameter.
0,"One instance, Instance N-1, is always accessible from the bus through device registers."
0,"All other instances route to other hardware peripherals (e.g. the key manager, obfuscation engines, etc.)"
0,and in normal operation these other instances are inaccessible from software.
0,The IP may be configured to support debug mode wherein all instances can be accessed by software.
0,For security reasons this mode may be permanently disabled using one-time programmable (OTP) memory.
0,The IP interfaces with external entropy sources to obtain any required non-deterministic seed material (entropy) and nonces.
0,"Requires an external entropy source which is compliant with NIST SP 800-90B, and which also satisfies the requirements for a PTG.2 class physical non-deterministic random number generator as defined in AIS31."
0,Dedicated hardware interface with external entropy source satisfies requirements for get_entropy_input() interface as defined in SP 800-90A.
0,This block does not use a derivation function and requires full entropy from the entropy source.
0,Also supports the optional use of personalization strings or other application inputs (e.g. OTP memory values) during instantiation.
0,"Assuming a continuously-live entropy source, each instance can also optionally be used as a non-deterministic TRNG (true random number generator, also called a non-deterministic random bit generator or NRBG in SP 800-90C)."
0,"In this mode, an instance also meets the requirements laid out for a PTG.3 class RNG, the strongest class laid out in AIS31."
0,"Implementation follows the NRBG Oversampling Construction approved by SP 800-90C, to meet both Common Criteria (CC, ISO/IEC 15408) and FIPS TRNG constructions."
0,"In addition to the approved DRNG mode, any instance can also operate in Fully Deterministic mode, meaning the seed depends entirely on application inputs or personalization strings."
0,"This provides an approved means of seed construction in FIPS 140-2 as described in the FIPS 140-2 Implementation Guidance, section 7.14, resolution point 2(a)."
0,"Though the recommendations in AIS31 are based around broad functional requirements, the recommendations in SP 800-90 are very prescriptive in nature, outlining the exact constructs needed for approval."
0,"Thus the interface and implementation are largely driven by these explicit constructs, particularly the CTR_DRBG construct."
0,"Every DRNG requires some initial seed material, and the requirements for the generation of that seed material varies greatly between standards, and potentially between Common Criteria security targets."
0,"In all standards considered, DRNGs require some entropy from an external source to create the initial seed."
0,"However, the rules for obtaining said entropy differ."
0,Furthermore the required delivery mechanisms differ.
0,For this reason we must make a clear distinction between Physical (or Live or True) entropy and Factory Entropy.
0,"This distinction is most important when considering the creation of IP which is both compatible with both the relatively new SP 800-90 recommendations, as well as the well-established FIPS 140-2 guidelines."
0,Physical entropy is the only type of entropy described in SP 800-90.
0,The means of generation is described in SP 800-90B.
0,"One statistical test requirement is that physical entropy must be unique between reboot cycles, ruling out sources such as one-time programmable (OTP) memories."
0,"In SP 800-90A, the delivery mechanism must come through a dedicated interface and not be provided by the consuming application."
0,"Factory entropy is a type of entropy described in the FIPS 140-2 implementation guidance (IG) section 7.14, resolution point 2(a)."
0,"It can be stored in a persistent memory, programmed at the factory."
0,"In some use cases, the consuming application needs to explicitly load this entropy itself and process it to establish the expected seed."
0,This document aims to make the distinction between physical entropy and factory entropy wherever possible.
0,"However, if used unqualified, the term entropy should be understood to refer to physical entropy strings which are obtained in accordance with SP 800-90C."
0,"That is either physical entropy, or the output of a DRNG which itself has been seeded (and possibly reseeded) with physical entropy."
0,"In AIS31 terms, entropy strings (when used in this document without a qualifier) should be understood to come from either a PTG.2 or PTG.3 class RNG."
0,All module assets and countermeasures performed by hardware are listed in the hjson countermeasures section.
0,Labels for each instance of asset and countermeasure are located throughout the RTL source code.
0,The bus integrity checking for genbits is different for software and hardware.
0,Only the application interface software port will have a hardware check on the genbits data bus.
0,This is done to make sure repeated values are not occurring.
0,"Only 64 bits (out of 128 bits) are checked, since this is statistically significant, and more checking would cost more silicon."
0,The application interface hardware port will not have this check.
0,It is expected that the requesting block (EDN) will do an additional hardware check on the genbits data bus.
0,"Every DRNG requires some initial seed material, and the requirements for the generation of that seed material varies greatly between standards, and potentially between Common Criteria security targets."
0,"In all standards considered, DRNGs require some entropy from an external source to create the initial seed."
0,"However, the rules for obtaining said entropy differ."
0,Furthermore the required delivery mechanisms differ.
0,For this reason we must make a clear distinction between Physical (or Live or True) entropy and Factory Entropy.
0,"This distinction is most important when considering the creation of IP which is both compatible with both the relatively new SP 800-90 recommendations, as well as the well-established FIPS 140-2 guidelines."
0,Physical entropy is the only type of entropy described in SP 800-90.
0,The means of generation is described in SP 800-90B.
0,"One statistical test requirement is that physical entropy must be unique between reboot cycles, ruling out sources such as one-time programmable (OTP) memories."
0,"In SP 800-90A, the delivery mechanism must come through a dedicated interface and not be provided by the consuming application."
0,"Factory entropy is a type of entropy described in the FIPS 140-2 implementation guidance (IG) section 7.14, resolution point 2(a)."
0,"It can be stored in a persistent memory, programmed at the factory."
0,"In some use cases, the consuming application needs to explicitly load this entropy itself and process it to establish the expected seed."
0,This document aims to make the distinction between physical entropy and factory entropy wherever possible.
0,"However, if used unqualified, the term entropy should be understood to refer to physical entropy strings which are obtained in accordance with SP 800-90C."
0,"That is either physical entropy, or the output of a DRNG which itself has been seeded (and possibly reseeded) with physical entropy."
0,"In AIS31 terms, entropy strings (when used in this document without a qualifier) should be understood to come from either a PTG.2 or PTG.3 class RNG."
0,All module assets and countermeasures performed by hardware are listed in the hjson countermeasures section.
0,Labels for each instance of asset and countermeasure are located throughout the RTL source code.
0,The bus integrity checking for genbits is different for software and hardware.
0,Only the application interface software port will have a hardware check on the genbits data bus.
0,This is done to make sure repeated values are not occurring.
0,"Only 64 bits (out of 128 bits) are checked, since this is statistically significant, and more checking would cost more silicon."
0,The application interface hardware port will not have this check.
0,It is expected that the requesting block (EDN) will do an additional hardware check on the genbits data bus.
0,This block is compatible with NISTs SP 800-90A and BSIs AIS31 recommendations for Common Criteria.
0,The CSRNG block has been constructed to follow the NIST recommendation for a DRBG mechanism based on block ciphers.
0,"Specifically, it is a CTR_DRBG that uses an approved block cipher algorithm in counter mode."
0,"As such, the block diagram below makes reference to hardware blocks that either directly or closely follow NIST descriptions for the equivalent functions."
0,There are two major hardware interfaces: the application interface and the entropy request interface.
0,"The application interface, which is described in more detail later, is provided for an application to manage an instance in CSRNG."
0,"Once setup, the application interface user can request for entropy bits to be generated, as well as other functions."
0,"The application interface supports up to 15 hardware interfaces, and one software interface."
0,"Regarding command processing, all commands process immediately except for the generate command."
0,The command generate length count (glen) is kept in the cmd_stage block.
0,"Because each request is pipelined, requests from other cmd_stage blocks can be processed before the original generate command is completely done."
0,This provides some interleaving of commands since a generate command can be programmed to take a very long time.
0,The block_encrypt block is where the aes_cipher_core block is located.
0,This is the same block used in the AES design.
0,Parameters are selected such that this is the unmasked version.
0,The software application interface uses a set of TL-UL registers to send commands and receive generated bits.
0,"Since the registers are 32-bit words wide, some sequencing will need to be done by firmware to make this interface work properly."
0,"This section describes the application interface, which is required for performing any operations using a CSRNG instance (i.e."
0,"instantiation, reseeding, RNG generation, or uninstantiation)."
0,"Each CSRNG instance corresponds to a unique application interface port, which implements the application interface described here."
0,Any hardware peripherals which require complete control of an instance may connect directly to a dedicated interface port.
0,Meanwhile peripherals without any special requirements (i.e.
0,"personalization strings or non-FIPS-approved, fully-deterministic number sequences) may share access to an instance via the entropy distribution network (EDN) IP."
0,"The EDNs manage the instantiation and reseeding of CSRNG instances for general use-cases, providing either on-demand or timed-delivery entropy streams to hardware peripherals."
0,"Firmware applications can obtain access to random bit sequences directly through application interface port 0, which is directly mapped to a set of TL-UL registers."
0,"The total number of application interface ports (for TL-UL, directly attached peripherals or EDN instances) is determined by the NHwApp parameter."
0,"The command bus operates like a FIFO, in which a command is pushed into the interface."
0,"An optional stream of additional data may follow, such as seed material for an instantiate application command."
0,"For the generate application command, the obfuscated entropy will be returned on the genbits bus."
0,"This bus also operates like a FIFO, and the receiving module can provide back pressure to the genbits bus."
0,"There is one instance of a firmware application interface, and it uses the TL-UL registers."
0,"For more details on how the application interface works, see the Theory of Operations section above."
0,"In general, users of the application interface are either firmware or some hardware module entity."
0,"For hardware, a module can either directly control the application interface, or it can connect to an EDN module."
0,Attaching to an EDN module allows for a simpler interface connection to a more layout-friendly distributed-chip network.
0,"The general format for the application interface is a 32-bit command header, optionally followed by additional data, such as a personalization string, typically twelve 32-bit words in length."
0,"Depending on the command, these strings are typically required to be 384-bits in length, to match the size of the seed-length when operating with 256-bit security-strength."
0,The exact function of the additional data field depends in the command.
0,"However, in general, the additional data can be any length as specified by the command length field."
0,The command header is defined below.
0,Note that the last table entry (flag0 is set and clen is set to non-zero) is intended for known answer testing (KAT).
0,The Reseed command only takes in one group (a maximum of twelve 32 bit words) of generic additional data.
0,The glen field defines how many 128-bit words are to be returned to the application interface.
0,The glen field needs to be a minimum value of one.
0,The NIST reference to the prediction_resistance_flag is not directly supported as a flag.
0,It is the responsibility of the calling application to reseed as needed before the Generate command to properly support prediction resistance.
0,"Once a command has been completed, successfully or unsuccessfully, the CSRNG responds with a single cycle pulse on the csrng_rsp_ack signal associated with the same application interface port."
0,In addition to the command response signals there is a bus for returning the generated bits.
0,"This 129-bit bus consists of 128-bits, genbits_bus, for the random bit sequence itself, along with a single bit flag, genbits_fips, indicating whether the bits were considered fully in accordance with FIPS standards."
0,"Early in the boot sequence, the ENTROPY_SRC generates a seed from the first 384 bits pulled from the noise source."
0,"This initial seed is tested to ensure some minimum quality for obfuscation usecases, but this boot seed is not expected to be full-entropy nor do these health checks meet the 1024-bit requirement for start-up health checks required by NIST 800-90B."
0,"Such a seed will be created only using factory-entropy and will lack the physical-entropy required by NIST SP 800-90A, and thus this DRBG instance will not be FIPS compliant."
0,The genbits data is considered successfully transmitted whenever genbits_valid and genbits_ready are asserted in the same clock cycle.
0,A requester must always be ready to receive csrng_req_sts signals.
0,(There is no ready signal for command response messages sent to hardware.)
0,The following waveform shows an example of how the entropy source hardware interface works.
0,Setting this field to kMultiBitBool4True will enable the CSRNG module.
0,"The modules of the entropy complex may only be enabled and disabled in a specific order, see Programmers Guide for details."
0,Setting this field to kMultiBitBool4True will enable reading from the GENBITS register.
0,Setting this field to kMultiBitBool4True will enable reading from the INT_STATE_VAL register.
0,Writing this request with defined CSRNG commands will initiate all possible CSRNG actions.
0,This bit indicates when the command interface is ready to accept commands.
0,This one bit field is the status code returned with the application command ack.
0,It is updated each time a command ack is asserted on the internal application interface for software use.
0,0b0: Request completed successfully 0b1: Request completed with an error.
0,Reading this register will get the generated bits that were requested with the generate request.
0,This register must be four times for each request number made.
0,"For example, a application command generate request with a creq value of 4 requires this register to be read 16 times to get all of the data out of the FIFO path."
0,Setting this field will set the number for which internal state can be selected for a read access.
0,Up to 16 internal state values can be chosen from this register.
0,The actual number of valid internal state fields is set by parameter NHwApps plus 1 software app.
0,"For those selections that point to reserved locations (greater than NHwApps plus 1), the returned value will be zero."
0,Writing this register will also reset the internal read pointer for the INT_STATE_VAL register.
0,Note: This register should be read back after being written to ensure that the INT_STATE_VAL read back is accurate.
0,Reading this register will dump out the contents of the selected internal state field.
0,"Since the internal state field is 448 bits wide, it will require 14 reads from this register to gather the entire field."
0,"Once 14 reads have been done, the internal read pointer (selects 32 bits of the 448 bit field) will reset to zero."
0,"The INT_STATE_NUM can be re-written at this time (internal read pointer is also reset), and then another internal state field can be read."
0,"Tim Newsome <tim@sifive.com>, SiFive, Inc. Megan Wachs <megan@sifive.com>, SiFive, Inc."
0,"Contributors to all versions of the spec in alphabetical order (please contact editors to suggest corrections): Bruce Ableidinger, Krste Asanovi´c, Allen Baum, Mark Beal, Alex Bradbury, Chuanhua Chang, Zhong-Ho Chen, Monte Dalrymple, Vyacheslav Dyachenko, Peter Egold, Markus Goehrle, Robert Golla, John Hauser, Richard Herveille, Yung-ching Hsiao, Po-wei Huang, Scott Johnson, Jean-Luc Nagel, Aram Nahidipour, Rishiyur Nikhil, Gajinder Panesar, Deepak Panwar, Antony Pavlov, Klaus Kruse Pedersen, Ken Pettit, Joe Rahmeh, Gavin Stark, Wesley Terpstra, Jan-Willem van de Waerdt, Stefan Wallentowitz, Ray Van De Walker, Andrew Waterman, Andy Wright, and Bryan Wyatt."
0,4.3 Virtual address in DPC upon Debug Mode Entry	44
0,"When a design progresses from simulation to hardware implementation, a user's control and understanding of the system's current state drops dramatically."
0,"To help bring up and debug low level software and hardware, it is critical to have good debugging support built into the hardware."
0,"When a robust OS is running on a core, software can handle many debugging tasks."
0,"However, in many scenarios, hardware support is essential."
0,This document outlines a standard architecture for external debug support on RISC-V platforms.
0,"This architecture allows a variety of implementations and tradeoffs, which is complementary to the wide range of RISC-V implementations."
0,"At the same time, this specification defines common interfaces to allow debugging tools and components to target a variety of platforms based on the RISC-V ISA."
0,"System designers may choose to add additional hardware debug support, but this specification defines a standard interface for common functionality."
0,A platform is a single integrated circuit consisting of one or more components.
0,"Some components may be RISC-V cores, while others may have a different function."
0,Typically they will all be connected to a single system bus.
0,"A single RISC-V core contains one or more hardware threads, called harts."
0,"DXLEN of a hart is its widest supported XLEN, ignoring the current value of MXL in misa."
0,"The RISC-V Instruction Set Manual, Volume I: User-Level ISA, Document Version 2.2 (the ISA Spec)"
0,"The RISC-V Instruction Set Manual, Volume II: Privileged Architecture, Version 1.10 (the Privileged Spec)"
0,Version 0.13 of this document was ratified by the RISC-V Foundation's board.
0,Versions 0.13.x are bug fix releases to that ratified specification.
0,Version 0.14 will be forwards and backwards compatible with Version 0.13.
0,This document contains two parts.
0,"The main part of the document is the specification, which is given in the numbered sections."
0,The second part of the document is a set of appendices.
0,"The information in the appendices is intended to clarify and provide examples, but is not part of the actual specification."
0,All register definitions in this document follow the format shown below.
0,A simple graphic shows which fields are in the register.
0,The upper and lower bit indices are shown to the top left and top right of each field.
0,The total number of bits in the field are shown below it.
0,"After the graphic follows a table which for each field lists its name, description, allowed accesses, and reset value."
0,The allowed accesses are listed in Table1.2.
0,The reset value is either a constant or Preset.
0,The latter means it is an implementation-specific legal value.
0,"Names of registers and their fields are hyperlinks to their definition, and are also listed in the index on page82."
0,"There are several use cases for dedicated debugging hardware, both internal to a CPU core and with an external connection."
0,This specification addresses the use cases listed below.
0,"Implementations can choose not to implement every feature, which means some use cases might not be supported."
0,Debugging low-level software in the absence of an OS or other software.
0,"Bootstrapping a system to test, configure, and program components before there is any executable code path in the system."
0,Accessing hardware on a system without a working CPU.
0,"In addition, even without a hardware debugging interface, architectural support in a RISC-V CPU can aid software debugging and performance analysis by allowing hardware triggers and breakpoints."
0,The debug interface described in this specification supports the following features: 1.All hart registers (including CSRs) can be read/written.
0,"Memory can be accessed either from the hart's point of view, through the system bus directly, 4."
0,Any hart in the platform can be independently debugged.
0,"5.A debugger can discover almost 1 everything it needs to know itself, without user configuration."
0,1Notable exceptions include information about the memory map and peripherals.
0,6.Each hart can be debugged from the very first instruction executed.
0,7.A RISC-V hart can be halted when a software breakpoint instruction is executed.
0,8.Hardware single-step can execute one instruction at a time.
0,Debug functionality is independent of the debug transport used.
0,The debugger does not need to know anything about the microarchitecture of the harts it is debugging.
0,Arbitrary subsets of harts can be halted and resumed simultaneously.
0,(Optional) 12.Arbitrary instructions can be executed on a halted hart.
0,That means no new debug function-
0,exist programs that can move that state into GPRs.
0,(Optional) 13.Registers can be accessed without halting.
0,"(Optional) 14.A running hart can be directed to execute a short sequence of instructions, with little overhead."
0,(Optional) 15.A system bus master allows memory access without involving any hart.
0,"16.A RISC-V hart can be halted when a trigger matches the PC, read/write address/data, or an instruction opcode."
0,"This document does not suggest a strategy or implementation for hardware test, debugging or error detection techniqes."
0,"are out of scope of this specification, but this specification does not intend to limit their use in RISC-V systems."
0,"It is possible to debug code that uses software threads, but there is no special debug support for it."
0,Figure2.1shows the main components of External Debug Support.
0,Blocks shown in dotted lines are optional.
0,"The user interacts with the Debug Host (e.g. laptop), which is running a debugger (e.g."
0,"The debugger communicates with a Debug Translator (e.g. OpenOCD, which may include a hardware driver) to communicate with Debug Transport Hardware (e.g."
0,Olimex USB-JTAG adapter).
0,The Debug Transport Hardware connects the Debug Host to the Platform's Debug Transport Module (DTM).
0,The DTM provides access to one or more Debug Modules (DMs) using the Debug Module Interface (DMI).
0,Each hart in the platform is controlled by exactly one DM.
0,Harts may be heterogeneous.
0,"There is no further limit on the hart-DM mapping, but usually all harts in a single core are controlled by the same DM."
0,In most platforms there will only be one DM that controls all the harts in the platform.
0,DMs provide run control of their harts in the platform.
0,Abstract commands provide access to GPRs.
0,Additional registers are accessible through abstract commands or by writing programs to the optional Program Buffer.
0,The Program Buffer allows the debugger to execute arbitrary instructions on a hart.
0,This mechanism can also be used to access memory.
0,An optional system bus access block allows memory accesses without using a RISC-V hart to perform the access.
0,Each RISC-V hart may implement a Trigger Module.
1,"When trigger conditions are met, harts will halt and inform the debug module that they have halted."
0,The Debug Module implements a translation interface between abstract debug operations and their specific implementation.
0,It might support the following operations:
0,Give the debugger necessary information about the implementation.
0,(Required) 2.Allow any individual hart to be halted and resumed.
0,Provide abstract read and write access to a halted hart's GPRs.
1,Provide access to a reset signal that allows debugging from the very first instruction after reset.
0,Provide a mechanism to allow debugging harts immediately out of reset (regardless of the reset cause).
0,Provide a Program Buffer to force the hart to execute arbitrary instructions.
0,"(Optional) 9.Allow multiple harts to be halted, resumed, and/or reset at the same time."
0,(Optional) 10.Allow memory access from a hart's point of view.
0,(Optional) In order to be compliant with this specification an implementation must: 1.Implement all the required features listed above.
0,"Implement at least one of Program Buffer, System Bus Access, or Abstract Access Memory (b) Implement abstract access to all registers that are visible to software running on the hart including all the registers that are present on the hart and listed in Table3.3."
0,"(c)Implement abstract access to at least all GPRs, dcsr, and dpc, and advertise the implementation as conforming to the Minimal RISC-V Debug Specification 0.13.2, instead"
0,Debug Modules are slaves to a bus called the Debug Module Interface (DMI).
0,The master of the bus is the Debug Transport Module(s).
0,"The Debug Module Interface can be a trivial bus with one master and one slave, or use a more full-featured bus like TileLink or the AMBA Advanced Peripheral Bus."
0,The details are left to the system designer.
0,The DMI uses between 7 and 32 address bits.
0,It supports read and write operations.
0,The bottom of the address space is used for the first (and usually only) DM.
0,"Extra space can be used for custom debug devices, other cores, additional DMs, etc."
0,"If there are additional DMs on this DMI, the base address of the next DM in the DMI address space is given in nextdm."
0,The Debug Module is controlled via register accesses to its DMI address space.
0,"The Debug Module controls a global reset signal, ndmreset (non-debug module reset), which can reset, or hold in reset, every component in the platform, except for the Debug Module and Debug Transport Modules."
0,"Exactly what is affected by this reset is implementation dependent, as long as it is possible to debug programs from the first instruction executed."
0,The Debug Module's own state and registers should only be reset at power-up and while dmactive in dmcontrol is 0.
1,"The halt state of harts should be maintained across system reset provided that dmactive is 1, although trigger CSRs may be cleared."
0,"Due to clock and power domain crossing issues, it may not be possible to perform arbitrary DMI accesses across system reset."
1,"While ndmreset or any external reset is asserted, the only supported DM operation is accessing dmcontrol."
0,The behavior of other accesses is undefined.
0,There is no requirement on the duration of the assertion of ndmreset.
1,The implementation must ensure that a write of ndmreset to 1 followed by a write of ndmreset to 0 triggers system reset.
0,"The system may take an arbitrarily long time to come out of reset, as reported by allunavail, anyunavail."
0,"Individual harts (or several at once) can be reset by selecting them, setting and then clearing hartreset."
0,In this case an implementation may reset more harts than just the ones that are selected.
1,"When harts have been reset, they must set a sticky havereset state bit."
0,The conceptual havereset state bits can be read for selected harts in anyhavereset and allhavereset in dmstatus.
0,These bits must be set regardless of the cause of the reset.
1,The havereset bits for the selected harts can be cleared by writing 1 to ackhavereset in dmcontrol.
1,The havereset bits may or may not be cleared when dmactive is low.
1,"When a hart comes out of reset and haltreq or resethaltreq are set, the hart will immediately enter Debug Mode."
0,Otherwise it will execute normally.
0,Up to 220 harts can be connected to a single DM.
0,"The debugger selects a hart, and then subsequent halt, resume, reset, and debugging commands are specific to that hart."
0,"To enumerate all the harts, a debugger must first determine HARTSELLEN by writing all ones to hartsel (assuming the maximum size) and reading back the value to see which bits were actually set."
1,"Then it selects each hart starting from 0 until either anynonexistent in dmstatus is 1, or the highest index (depending on HARTSELLEN) is reached."
0,"The debugger can discover the mapping between hart indices and mhartid by using the interface to read mhartid, or by reading the system's configuration string."
0,All debug modules must support selecting a single hart.
0,The debugger can select a hart by writing its index to hartsel.
1,Hart indexes start at 0 and are contiguous until the final index.
0,Debug Modules may implement a Hart Array Mask register to allow selecting multiple harts at once.
0,The nth bit in the Hart Array Mask register applies to the hart with index n. If the bit is 1 then the hart is selected.
0,"Usually a DM will have a Hart Array Mask register exactly wide enough to select all the harts it supports, but it's allowed to tie any of these bits to 0."
1,"The debugger can set bits in the hart array mask register using hawindowsel and hawindow, then apply actions to all selected harts by setting hasel."
1,"If this feature is supported, multiple harts can be halted, resumed, and reset simultaneously."
1,The state of the hart array mask register is not affected by setting or clearing hasel.
0,"Only the actions initiated by dmcontrol can apply to multiple harts at once, Abstract Commands apply only to the hart selected by hartsel."
0,Every hart that can be selected is in exactly one of four states.
0,"Which state the selected harts are in is reflected by allnonexistent, anynonexistent, allunavail, anyunavail, allrunning, anyrunning, allhalted, and anyhalted."
1,"Harts are nonexistent if they will never be part of this system, no matter how long a user waits."
0,"in a simple single-hart system only one hart exists, and all others are nonexistent."
0,Debuggers may assume that a system has no harts with indexes higher than the first nonexistent one.
0,"Harts are unavailable if they might exist/become available at a later time, or if there are other harts with higher indexes than this one."
0,Harts may be unavailable for a variety of reasons including being
0,"reset, temporarily powered down, and not being plugged into the system."
0,"Systems with very large number of harts may permanently disable some during manufacturing, leaving holes in the otherwise continuous hart index space."
0,"In order to let the debugger discover all harts, they must show up as unavailable even if there is no chance of them ever becoming available."
1,"Harts are running when they are executing normally, as if no debugger was attached."
0,"This includes being in a low power mode or waiting for an interrupt, as long as a halt request will result in the hart being halted."
1,"Harts are halted when they are in Debug Mode, only performing tasks on behalf of the debugger."
0,Which states a hart that is reset goes through is implementation dependent.
1,"Harts may be unavailable while reset is asserted, and some time after reset is deasserted."
1,They might transition to running for some time after reset is deasserted.
0,"Finally they end up either running or halted,"
0,"For every hart, the Debug Module tracks 4 conceptual bits of state: halt request, resume ack, halton-reset request, and hart reset."
0,(The hart reset and halt-on-reset request bits are optional.)
1,"These 4 bits reset to 0, except for resume ack, which may reset to either 0 or 1."
0,"The DM receives halted, running, and havereset signals from each hart."
0,"The debugger can observe the state of resume ack in allresumeack and anyresumeack, and the state of halted, running, and havereset signals in allhalted, anyhalted, allrunning, anyrunning, allhavereset, and anyhavereset."
0,The state of the other bits cannot be observed directly.
0,"When a debugger writes 1 to haltreq, each selected hart's halt request bit is set."
1,"When a running hart, or a hart just coming out of reset, sees its halt request bit high, it responds by halting, deasserting its running signal, and asserting its halted signal."
0,Halted harts ignore their halt request bit.
0,"When a debugger writes 1 to resumereq, each selected hart's resume ack bit is cleared and each selected, halted hart is sent a resume request."
0,"Harts respond by resuming, clearing their halted signal, and asserting their running signal."
0,At the end of this process the resume ack bit is set.
0,"These status signals of all selected harts are reflected in allresumeack, anyresumeack, allrunning, and anyrunning."
0,Resume requests are ignored by running harts.
1,"When halt or resume is requested, a hart must respond in less than one second, unless it is unavailable."
0,(How this is implemented is not further specified.
0,A few clock cycles will be a more typical latency).
1,"The DM can implement optional halt-on-reset bits for each hart, which it indicates by setting hasresethaltreq to 1."
0,This means the DM implements the setresethaltreq and clrresethaltreq bits.
1,Writing 1 to setresethaltreq sets the halt-on-reset request bit for each selected hart.
0,"When a hart's halt-on-reset request bit is set, the hart will immediately enter debug mode on the next deassertion of its reset."
0,This is true regardless of the reset's cause.
0,"The hart's halt-on-reset request bit remains set until cleared by the debugger writing 1 to clrresethaltreq while the hart is selected, or by DM reset."
0,"The DM supports a set of abstract commands, most of which are optional."
0,"Depending on the implementation, the debugger may be able to perform some abstract commands even when the selected hart is not halted."
0,Debuggers can only determine which abstract commands are supported by a given hart in a given state by attempting them and then looking at cmderr in abstractcs to see if they were successful.
0,"Commands may be supported with some options set, but not with other options set."
0,"If a command has unsupported options set, the DM must set cmderr to 2 (not supported)."
0,"Example: Every system must support the Access Register command, but may not support accessing CSRs."
0,"If the debugger requests to read a CSR in that case, the command will return not supported."
0,Debuggers execute abstract commands by writing them to command.
1,They can determine whether an abstract command is complete by reading busy in abstractcs.
1,"After completion, cmderr indicates whether the command was successful or not."
0,"Commands may fail because a hart is not halted, not running, unavailable, or because they encounter an error during execution."
1,"If the command takes arguments, the debugger must write them to the data registers before writing to command."
1,"If a command returns results, the Debug Module must ensure they are placed in the data registers before busy is cleared."
0,Which data registers are used for the arguments is described in Table3.1.
0,In all cases the least-significant word is placed in the lowest-numbered data register.
0,"The argument width depends on the command being executed, and is DXLEN where not explicitly specified."
0,"The Abstract Command interface is designed to allow a debugger to write commands as fast as possible, and then later check whether they completed without error."
0,"In the common case the debugger will be much slower than the target and commands succeed, which allows for maximum throughput."
0,"If there is a failure, the interface ensures that no commands execute after the failing one."
0,"To discover which command failed, the debugger has to look at the state of the DM (e.g. contents of data0) or hart (e.g."
0,contents of a register modified by a Program Buffer program) to determine which one failed.
1,"While an abstract command is executing (busy in abstractcs is high), a debugger must not change hartsel, and must not write 1 to haltreq, resumereq, ackhavereset, setresethaltreq, or clrresethaltreq."
1,"If an abstract command does not complete in the expected time and appears to be hung, the following procedure can be attempted to abort the command: First the debugger resets the hart (using hartreset or ndmreset), and then it resets the Debug Module (using dmactive)."
1,"If an abstract command is started while the selected hart is unavailable or if a hart becomes unavailable while executing an abstract command, then the Debug Module may terminate the abstract command, setting busy low, and cmderr to 4 (halt/resume)."
0,"Alternatively, the command could just appear to be hung (busy never goes low)."
0,This section describes each of the different abstract commands and how their fields should be interpreted when they are written to command.
0,Each abstract command is a 32-bit value.
0,The top 8 bits contain cmdtype which determines the kind of command.
0,Table3.2lists all commands.
0,This command gives the debugger access to CPU registers and allows it to execute the Program Buffer.
0,It performs the following sequence of operations: 1.
1,"If write is clear and transfer is set, then copy data from the register specified by regno into the arg0 region of data, and perform any side effects that occur when this register is read from M-mode."
0,"If write is set and transfer is set, then copy data from the arg0 region of data into the register"
0,"specified by regno, and perform any side effects that occur when this register is written from M-mode."
0,"If aarpostincrement is set, increment regno."
0,"4.Execute the Program Buffer, if postexec is set."
1,"If any of these operations fail, cmderr is set and none of the remaining steps are executed."
1,"An implementation may detect an upcoming failure early, and fail the overall command before it reaches the step that would cause failure."
1,"If the failure is that the requested register does not exist in the hart, cmderr must be set to 3 (exception)."
1,Debug Modules must implement this command and must support read and write access to all GPRs when the selected hart is halted.
1,"Debug Modules may optionally support accessing other registers, or accessing registers when the hart is running."
0,"Each individual register (aside from GPRs) may be supported differently across read, write, and halt status."
0,The encoding of aarsize was chosen to match sbaccess in sbcs.
0,This command modifies arg0 only when a register is read.
0,The other data registers are not changed.
0,2: Access the lowest 32 bits of the register.
0,3: Access the lowest 64 bits of the register.
0,4: Access the lowest 128 bits of the register.
0,"actual size, then the access must fail."
0,"If a register is accessible, then reads of aarsize less than or equal to the register's actual size must be supported."
0,"1: After a successful register access, regno is incremented (wrapping around to 0)."
0,Supporting 0: No effect.
0,"This variant must be supported, and is the only supported one if progbufsize is 0."
0,"1: Execute the program in the Program Buffer exactly once after performing the transfer, if any."
0,0: Don't do the operation specified by write.
0,1: Do the operation specified by write.
0,When transfer is set: 0: Copy data from the specified register into arg0 portion of data.
0,"Number of the register to access, as described in Table3.3."
0,dpc may be used as an alias for PC if
1,"If the hart is halted, the command sets cmderr to halt/resume and does not continue."
1,"If the hart halts for some other reason (e.g. breakpoint), the command sets cmderr to halt/resume and does not continue."
0,Execute the Program Buffer.
0,"If an exception occurs,	cmderr is set to exception and the program buffer execution ends, but the quick access command continues."
0,"This command lets the debugger perform memory accesses, with the exact same memory view and permissions as the selected hart has."
0,"This includes access to hart-local memory-mapped registers, etc."
0,The command performs the following sequence of operations: 1.
0,"Copy data from the memory location specified in arg1 into the arg0 portion of data, if write 2."
0,"Copy data from the arg0 portion of data into the memory location specified in arg1, if write"
1,"If any of these operations fail, cmderr is set and none of the remaining steps are executed."
1,"An access may only fail if the hart, running M-mode code, might encounter that same failure when it attempts the same access."
1,"An implementation may detect an upcoming failure early, and fail the overall command before it reaches the step that would cause failure."
1,Debug Modules may optionally implement this command and may support read and write access to memory locations when the selected hart is running or halted.
1,"If this command supports memory accesses while the hart is running, it must also support memory accesses while the hart is halted."
0,The encoding of aamsize was chosen to match sbaccess in sbcs.
0,This command modifies arg0 only when memory is read.
0,It modifies arg1 only if aampostincrement
0,"An implementation does not have to implement both virtual and physical accesses, but it must fail accesses that it doesn't support."
0,0: Access the lowest 8 bits of the memory location.
0,1: Access the lowest 16 bits of the memory location.
0,2: Access the lowest 32 bits of the memory location.
0,3: Access the lowest 64 bits of the memory location.
0,0: Copy data from the memory location specified in arg1 into arg0 portion of data.
0,"To support executing arbitrary instructions on a halted hart, a Debug Module can include a Program Buffer that a debugger can write small programs to."
0,Systems that support all necessary functionality using abstract commands only may choose to omit the Program Buffer.
0,"A debugger can write a small program to the Program Buffer, and then execute it exactly once with the Access Register Abstract Command, setting the postexec bit in command."
0,"The debugger can write whatever program it likes (including jumps out of the Program Buffer), but the program must end with ebreak or c.ebreak."
0,An implementation may support an implied ebreak that is executed when a hart runs off the end of the Program Buffer.
0,This is indicated by impebreak.
0,"With this feature, a Program Buffer of just 2 32-bit words can offer efficient debugging."
0,"If progbufsize is 1, impebreak must be 1."
0,"It is possible that the Program Buffer can hold only one 32or 16-bit instruction, so the debugger must only write a single instruction in this case, regardless of its size."
0,"This instruction can be a 32-bit instruction, or a compressed instruction in the lower 16 bits accompanied by a compressed nop in the upper 16 bits."
0,"The slightly inconsistent behavior with a Program Buffer of size 1 is to accommodate hardware designs that prefer to stuff instructions directly into the pipeline when halted, instead of having the Program Buffer exist in the address space somewhere."
0,"While these programs are executed, the hart does not leave Debug Mode (see Section4.1)."
0,"an exception is encountered during execution of the Program Buffer, no more instructions are executed, the hart remains in Debug Mode, and cmderr is set to 3 (exception error)."
0,"If the debugger executes a program that doesn't terminate with an ebreak instruction, the hart will remain in Debug Mode and the debugger will lose control of the hart."
0,Executing the Program Buffer may clobber dpc.
1,"If that is the case, it must be possible to read/write dpc using an abstract command with postexec not set."
1,"The debugger must attempt to save dpc between halting and executing a Program Buffer, and then restore dpc before leaving Debug Mode."
0,"Allowing Program Buffer execution to clobber dpc allows for direct implementations that don't have a separate PC register, and do need to use the PC when executing the Program Buffer."
0,The Program Buffer may be implemented as RAM which is accessible to the hart.
0,A debugger can determine if this is the case by executing small programs that attempt to write and read back relative to pc while executing from the Program Buffer.
0,"If so, the debugger has more flexibility in what it can do with the program buffer."
0,"Figure3.1shows a conceptual view of the states passed through by a hart during run/halt debugging as influenced by the different fields of dmcontrol, abstractcs, abstractauto, and command."
0,Figure 3.1: Run/Halt Debug State Machine for single-hart systems.
0,"As only a small amount of state is visibile to the debugger, the states and transitions are conceptual."
0,A debugger can access memory from a hart's point of view using a Program Buffer or the Abstract Access Memory command.
0,(Both these features are optional.)
0,"A Debug Module may also include a System Bus Access block to provide memory access without involving a hart, regardless of whether Program Buffer is implemented."
0,The System Bus Access block uses physical addresses.
0,"The System Bus Access block may support 8-, 16-, 32-, 64-, and 128-bit accesses."
0,Table3.7shows which bits in sbdata are used for each access size.
0,"Depending on the microarchitecture, data accessed through System Bus Access may not always be coherent with that observed by each hart."
0,It is up to the debugger to enforce coherency if the implementation does not.
0,This specification does not define a standard way to do this.
0,"Possibilities may include writing to special memory-mapped locations, or executing special instructions via the Program Buffer."
0,Implementing a System Bus Access block has several benefits even when a Debug Module also implements a Program Buffer.
0,"First, it is possible to access memory in a running system with minimal impact."
0,"Second, it may improve performance when accessing memory."
0,"Third, it may provide access to devices that a hart does not have access to."
0,"Depending on the task it is performing, some harts can only be halted very briefly."
0,There are several mechanisms that allow accessing resources in such a running system with a minimal impact on the running hart.
1,"First, an implementation may allow some abstract commands to execute without halting the hart."
1,"Second, the Quick Access abstract command can be used to halt a hart, quickly execute the contents of the Program Buffer, and let the hart run again."
0,"Combined with instructions that allow Program Buffer code to access the data registers, as described in3.12.3, this can be used to quickly perform a memory or register access."
0,"For some systems this will be too intrusive, but many systems that can't be halted can bear an occasional hiccup of a hundred or less cycles."
1,"Third, if the System Bus Access block is implemented, it can be used while a hart is running to access system memory."
0,To protect intellectual property it may be desirable to lock access to the Debug Module.
0,"To allow access during a manufacturing process and not afterwards, a reasonable solution could be to add a fuse bit to the Debug Module that can be used to be permanently disable it."
0,"Since this is technology specific, it is not further addressed in this spec."
0,Another option is to allow the DM to be unlocked only by users who have an access key.
0,"Between authenticated, authbusy, and authdata arbitrarily complex authentication mechanism can be supported."
1,"When authenticated is clear, the DM must not interact with the rest of the platform, nor expose details about the harts connected to the DM."
0,"All DM registers should read 0, while writes should be ignored, with the following mandatory exceptions:"
0,The registers described in this section are accessed over the DMI bus.
0,Each DM has a base address (which is 0 for the first DM).
0,The register addresses below are offsets from this base address.
0,"When read, unimplemented Debug Module DMI Registers return 0."
0,Writing them has no effect.
0,"For each register it is possible to determine that it is implemented by reading it and getting a non-zero value (e.g. sbcs), or by checking bits in another register (e.g."
0,"This register reports status for the overall Debug Module as well as the currently selected harts, as defined in hasel."
0,"Its address will not change in the future, because it contains version."
0,"If 1, then there is an implicit ebreak instruction at the non-existent word immediately after the Program Buffer."
0,"This saves the debugger from having to write the ebreak itself, and allows the Program Buffer to be one word smaller."
0,0: The authentication module is ready to process the next read/write to authdata.
0,1: The authentication module is busy.
0,Accessing authdata results in unspecified behavior.
0,authbusy only becomes set in immediate response 0: confstrptr0-confstrptr3 hold information which is not relevant to the configuration string.
0,1: confstrptr0-confstrptr3 hold the address
0,1: There is a Debug Module and it conforms to version 0.11 of this specification.
0,2: There is a Debug Module and it conforms to version 0.13 of this specification.
0,"This register controls the overall Debug Module as well as the currently selected harts, as defined in hasel."
0,"Throughout this document we refer to hartsel, which is hartselhi combined with hartsello."
0,"While the spec allows for 20 hartsel bits, an implementation may choose to implement fewer than that."
0,The actual width of hartsel is called HARTSELLEN.
0,It must be at least 0 and at most 20.
1,A debugger should discover HARTSELLEN by writing all ones to hartsel (assuming the maximum size) and reading back the value to see which bits were actually set.
1,Debuggers must not change hartsel while an abstract command is executing.
0,"There are separate setresethaltreq and clrresethaltreq bits so that it is possible to write dmcontrol without changing the halt-on-reset request bit for each selected hart, when not all selected harts have the same configuration."
1,"On any given write, a debugger may only write 1 to at most one of the following bits: resumereq, hartreset, ackhavereset, setresethaltreq, and clrresethaltreq."
0,The others must be written 0.
1,"resethaltreq is an optional internal bit of per-hart state that cannot be read, but can be written with setresethaltreq and clrresethaltreq."
0,Writing 0 clears the halt request bit for all currently selected harts.
0,This may cancel outstanding halt requests for those harts.
0,Running harts will halt whenever their halt request bit is set.
0,Writes apply to the new value of hartsel and hasel.
0,"Writing 1 causes the currently selected harts to resume once, if they are halted when the write occurs."
0,It also clears the resume ack bit for those harts.
0,Writes apply to the new value of hartsel and hasel.
0,This optional field writes the reset bit for all the currently selected harts.
0,"To perform a reset the debugger writes 1, and then writes 0 to deassert the reset signal."
0,"If this feature is not implemented, the bit always stays 0, so after writing 1 the debugger can read the register back to see if the feature is supported."
0,Writes apply to the new value of hartsel and hasel.
0,Writes apply to the new value of hartsel and hasel.
0,Selects the definition of currently selected harts.
0,"0: There is a single currently selected hart, that is selected by hartsel."
0,"the hart selected by hartsel, plus those selected by the hart array mask register."
0,An implementation which does not implement the hart array mask register must tie this field to 0.
0,A debugger which wishes to use the hart array mask register feature should set this bit and read The low 10 bits of hartsel: the DM-specific index of the hart to select.
0,This hart is always part of The high 10 bits of hartsel: the DM-specific index of the hart to select.
0,"This hart is always part of This optional field writes the halt-on-reset request bit for all currently selected harts, unless clrresethaltreq is simultaneously set to 1."
0,"When set to 1, each selected hart will halt upon the next deassertion of its reset."
0,The halt-on-reset request bit is not automatically cleared.
0,The debugger must write to clrresethaltreq to clear it.
0,Writes apply to the new value of hartsel and hasel.
0,This optional field clears the halt-on-reset request bit for all currently selected harts.
0,Writes apply to the new value of hartsel and hasel.
0,This bit controls the reset signal from the DM to the rest of the system.
0,"The signal should reset every part of the system, including every hart, except for the DM and any logic required to access the DM."
0,"To perform a system reset the debugger writes 1, and then writes 0 to deassert the reset."
0,This bit serves as a reset signal for the Debug Module itself.
0,"0: The module's state, including authentication mechanism, takes its reset values (the dmactive bit is the only bit which can be written to something other than its reset value)."
0,"No other mechanism should exist that may result in resetting the Debug Module after power up, with the possible (but not recommended) exception of a global reset signal that resets the entire platform."
0,bug Module into a known state.
0,"Implementations may pay attention to this bit to further aid debugging, for example by preventing the Debug Module from being power gated while"
0,This register gives information about the hart currently selected by hartsel.
0,This register is optional.
0,If it is not present it should read all-zero.
1,"If this register is included, the debugger can do more with the Program Buffer by writing programs which explicitly access the data and/or dscratch registers."
0,"Number of dscratch registers available for the debugger to use during program buffer execution, starting from dscratch0."
0,The debugger can make no assumptions about the contents of these regis-
0,0: The data registers are shadowed in the hart by CSRs.
0,"Each CSR is DXLEN bits in size, and corresponds to a single argument, per Table3.1."
0,1: The data registers are shadowed in the hart's memory map.
0,Each register takes up 4 bytes in If dataaccess is 0: Number of CSRs dedicated to shadowing the data registers.
0,If dataaccess is 1: Number of 32-bit words in the memory map dedicated to shadowing the data registers.
0,If dataaccess is 0: The number of the first CSR dedicated to shadowing the data registers.
0,This register selects which of the 32-bit portion of the hart array mask register (see Section3.3.2) is accessible in hawindow.
0,"The high bits of this field may be tied to 0, depending on how large the array mask register is."
0,on a system with 48 harts only bit 0 of this
0,This register provides R/W access to a 32-bit portion of the hart array mask register (see Section3.3.2).
1,The position of the window is determined by hawindowsel.
0,"bit 0 refers to hart hawindowsel * 32, while bit 31 refers to hart hawindowsel * 32 + 31."
0,"Since some bits in the hart array mask register may be constant 0, some bits in this register may be constant 0, depending on the current value of hawindowsel."
1,Writing this register while an abstract command is executing causes cmderr to be set to 1 (busy) if it is 0.
0,"datacount must be at least 1 to support RV32 harts, 2 to support RV64 harts, or 4 to support RV128 harts."
0,Gets set if an abstract command fails.
0,The bits in this field remain set until they are cleared by writing 1 to them.
0,No abstract command is started until the value is reset to 0.
0,This field only contains a valid value if busy is 0.
0,"1 (busy): An abstract command was executing while command, abstractcs, or abstractauto was written, or when one of the data or progbuf registers was read or written."
0,This status is only written if cmderr contains 0.
0,"supported, regardless of whether the hart is running or not."
0,3 (exception): An exception occurred while executing the command (e.g. while executing the Program Buffer).
0,"execute because the hart wasn't in the required state (running/halted), or unavailable."
0,"5 (bus): The abstract command failed due to a bus error (e.g. alignment, access size, or timeout)."
0,7 (other): The command failed for another rea- Number of data registers that are implemented as part of the abstract command interface.
0,Writes to this register cause the corresponding abstract command to be executed.
1,Writing this register while an abstract command is executing causes cmderr to be set to 1 (busy) if it is 0.
1,"If cmderr is non-zero, writes to this register are ignored."
0,"sons, send several commands to be executed in a row without checking cmderr in between."
0,They can safely do so and check cmderr at the end without worrying that one command failed but then a later command (which might have depended on the previous one succeeding) passed.
0,This register is optional.
0,Including it allows more efficient burst accesses.
0,A debugger can detect whether it is support by setting bits and reading them back.
1,Writing this register while an abstract command is executing causes cmderr to be set to 1 (busy) if it is 0.
1,"When confstrptrvalid is set, reading this register returns bits 31:0 of the configuration string pointer."
1,Reading the other confstrptr registers returns the upper bits of the address.
1,"When system bus mastering is implemented, this must be an address that can be used with the System Bus Access module."
1,"Otherwise, this must be an address that can be used to access the configuration string from the hart with ID 0."
1,"If confstrptrvalid is 0, then the confstrptr registers hold identifier information which is not further specified in this document."
0,The configuration string itself is described in the Privileged Spec.
0,This entire register is read-only.
1,"If there is more than one DM accessible on this DMI, this register contains the base address of the next one in the chain, or 0 if this is the last one in the chain."
1,data0 through data11 are basic read/write registers that may be read or changed by abstract commands.
1,"datacount indicates how many of them are implemented, starting at data0, counting up."
0,Table3.1shows how abstract commands use these registers.
1,Accessing these registers while an abstract command is executing causes cmderr to be set to 1 (busy) if it is 0.
1,Attempts to write them while busy is set does not change their value.
0,The values in these registers may not be preserved after an abstract command is executed.
0,The only guarantees on their contents are the ones offered by the command in question.
1,"If the command fails, no assumptions can be made about the contents of these registers."
0,progbuf0 through progbuf15 provide read/write access to the optional program buffer.
0,"progbufsize indicates how many of them are implemented starting at progbuf0, counting up."
1,Accessing these registers while an abstract command is executing causes cmderr to be set to 1 (busy) if it is 0.
1,Attempts to write them while busy is set does not change their value.
0,This register serves as a 32-bit serial port to/from the authentication module.
0,"When authbusy is clear, the debugger can communicate with the authentication module by reading or writing this register."
0,There is no separate mechanism to signal overflow/underflow.
0,Each bit in this read-only register indicates whether one specific hart is halted or not.
0,Unavailable/nonexistent harts are not considered to be halted.
0,"The LSB reflects the halt status of hart {hartsel[19:5],5'h0}, and the MSB reflects halt status of hart {hartsel[19:5],5'h1f}."
1,Each bit in this read-only register indicates whether any of a group of harts is halted or not.
0,Unavailable/nonexistent harts are not considered to be halted.
0,This register may not be present in systems with fewer than 33 harts.
0,"The LSB reflects the halt status of harts {hartsel[19:10],10'h0} through {hartsel[19:10],10'h1f}."
0,"The MSB reflects the halt status of harts {hartsel[19:10],10'h3e0} through {hartsel[19:10],10'h3ff}."
1,Each bit in this read-only register indicates whether any of a group of harts is halted or not.
0,Unavailable/nonexistent harts are not considered to be halted.
0,This register may not be present in systems with fewer than 1025 harts.
0,"The LSB reflects the halt status of harts {hartsel[19:15],15'h0} through {hartsel[19:15],15'h3ff}."
0,"The MSB reflects the halt status of harts {hartsel[19:15],15'h7c00} through {hartsel[19:15],15'h7fff}."
1,Each bit in this read-only register indicates whether any of a group of harts is halted or not.
0,Unavailable/nonexistent harts are not considered to be halted.
0,This register may not be present in systems with fewer than 32769 harts.
0,The LSB reflects the halt status of harts 20'h0 through 20'h7fff.
0,The MSB reflects the halt status of harts 20'hf8000 through 20'hfffff.
0,"3.12.18 System Bus Access Control and Status (sbcs, at 0x38)"
0,"0: The System Bus interface conforms to mainline drafts of this spec older than 1 January, 2018."
0,1: The System Bus interface conforms to this version of the spec.
0,"Set when the debugger attempts to read data while a read is in progress, or when the debugger initiates a new access while one is already in progress (while sbbusy is set)."
0,It remains set until it's explicitly cleared by the debugger.
0,"When 1, indicates the system bus master is busy."
0,"(Whether the system bus itself is busy is related, but not the same thing.)"
0,"This bit goes high immediately when a read or write is requested for any reason, and does not go low until the access is fully completed."
0,Select the access size to use for system bus accesses.
0,"When the Debug Module's system bus master encounters an error, this field gets set."
0,The bits in this field remain set until they are cleared by writing 1 to them.
0,"While this field is non-zero, no more system bus accesses can be initiated by the Debug Module."
0,0: There was no bus error.
0,1: There was a timeout.
0,2: A bad address was accessed.
0,3: There was an alignment error.
1,"If sbasize is 0, then this register is not present."
0,"When the system bus master is busy, writes to this register will set sbbusyerror and don't do anything else."
0,"If sberror is 0, sbbusyerror is 0, and sbreadonaddr is set then writes to this register start the following: 1.Set sbbusy."
0,Perform a bus read from the new value of sbaddress.
0,"If the read succeeded and sbautoincrement is set, increment sbaddress."
1,"If sbasize is less than 33, then this register is not present."
0,"When the system bus master is busy, writes to this register will set sbbusyerror and don't do anything else."
1,"If sbasize is less than 65, then this register is not present."
0,"When the system bus master is busy, writes to this register will set sbbusyerror and don't do anything else."
1,"If sbasize is less than 97, then this register is not present."
0,"When the system bus master is busy, writes to this register will set sbbusyerror and don't do anything else."
1,"If all of the sbaccess bits in sbcs are 0, then this register is not present."
0,Any successful system bus read updates sbdata.
1,"If the width of the read access is less than the width of sbdata, the contents of the remaining high bits may take on any value."
0,If sberror or sbbusyerror both aren't 0 then accesses do nothing.
0,"If the bus master is busy then accesses set sbbusyerror, and don't do anything else."
0,Writes to this register start the following: 2.
0,Perform a bus write of the new value of sbdata to sbaddress.
1,"If the write succeeded and sbautoincrement is set, increment sbaddress."
0,Reads from this register start the following: 1.Return the data.
1,"If sbreadondata is set, perform a system bus read from the address contained in sbaddress, placing the result in sbdata."
0,Only sbdata0 has this behavior.
0,The other sbdata registers have no side effects.
0,"On systems that have buses wider than 32 bits, a debugger should access sbdata0 after accessing the other sbdata registers."
1,"If sbaccess64 and sbaccess128 are 0, then this register is not present."
0,"If the bus master is busy then accesses set sbbusyerror, and don't do anything else."
0,"If the bus master is busy then accesses set sbbusyerror, and don't do anything else."
0,"If the bus master is busy then accesses set sbbusyerror, and don't do anything else."
0,Modifications to the RISC-V core to support debug are kept to a minimum.
0,There is a special execution mode (Debug Mode) and a few extra CSRs.
0,The DM takes care of the rest.
0,In order to be compliant with this specification an implementation must implement everything described in this section that is not explicitly listed as optional.
0,Debug Mode is a special processor mode used only when a hart is halted for external debugging.
0,How Debug Mode is implemented is not specified here.
0,"All operations are executed at machine mode privilege level, except that MPRV in mstatus 3."
0,Exceptions don't update any registers.
0,"That includes cause, epc, tval, dpc, and mstatus."
0,"Counters may be stopped, depending on stopcount in dcsr."
0,"6.Timers may be stopped, depending on stoptime in dcsr."
0,Almost all instructions that change the privilege level have undefined behavior.
0,"This includes ecall, mret, sret, and uret."
0,"(To change the privilege level, the debugger can write prv in dcsr)."
0,The only exception is ebreak.
1,"When that is executed in Debug Mode, it halts the hart again but without updating dpc or dcsr."
0,Completing Program Buffer execution is considered output for the purpose of fence instruc-
1,All control transfer instructions may act as illegal instructions if their destination is in the Program Buffer.
0,"If one such instruction acts as an illegal instruction, all such instructions"
1,All control transfer instructions may act as illegal instructions if their destination is outside the Program Buffer.
1,"If one such instruction acts as an illegal instruction, all such instructions must act as an illegal instruction."
0,Instructions that depend on the value of the PC (e.g. auipc) may act as illegal instructions.
0,"In general, the debugger is expected to be able to simulate all the effects of MPRV."
0,"The exception is the case of Sv32 systems, which need MPRV functionality in order to access 34-bit physical addresses."
0,Other systems are likely to tie mprven to 0.
1,The reservation registered by an lr instruction on a memory address may be lost when entering Debug Mode or while in Debug Mode.
1,This means that there may be no forward progress if Debug Mode is entered between lr and sc pairs.
0,This is a behavior that debug users must be aware of.
0,"If they have a breakpoint set between a lr and sc pair, or are stepping through such code, the sc may never succeed."
0,"Fortunately in general use there will be very few instructions in such a sequence, and anybody debugging it will quickly notice that the reservation is not occurring."
0,The solution in that case is to set a breakpoint on the first instruction after the sc and run to it.
0,A higher level debugger may choose to automate this.
0,"If halt is requested while wfi is executing, then the hart must leave the stalled state, completing this instruction's execution, and then enter Debug Mode."
1,A debugger can cause a halted hart to execute a single instruction and then re-enter Debug Mode by setting step before setting resumereq.
1,"If executing or fetching that instruction causes an exception, Debug Mode is re-entered immediately after the PC is changed to the exception handler and the appropriate tval and cause registers are updated."
1,"If executing or fetching the instruction causes a trigger to fire, Debug Mode is re-entered immediately after that trigger has fired."
0,In that case cause is set to 2 (trigger) instead of 4 (single step).
0,Whether the instruction is executed or not depends on the specific configuration of the trigger.
1,"If the instruction that is executed causes the PC to change to an address where an instruction fetch causes an exception, that exception does not occurr until the next time the hart is resumed."
1,"Similarly, a trigger at the new address does not fire until the hart actually attempts to execute that instruction."
1,"If the instruction being stepped over is wfi and would normally stall the hart, then instead the instruction is treated as nop."
0,"If the halt signal (driven by the hart's halt request bit in the Debug Module) or resethaltreq are asserted when a hart comes out of reset, the hart must enter Debug Mode before executing any instructions, but after performing any initialization that would usually happen before the first instruction is executed."
0,"To return from Debug Mode, a new instruction is defined: dret."
0,It has an encoding of 0x7b200073.
1,"On harts which support this instruction, executing dret in Debug Mode changes pc to the value stored in dpc."
0,The current privilege level is changed to that specified by prv in dcsr.
0,The hart is no longer in debug mode.
0,Executing dret outside of Debug Mode causes an illegal instruction exception.
0,"It is not necessary for the debugger to know whether an implementation supports dret, as the Debug Module will ensure that it is executed if necessary."
0,It is defined in this specification only to reserve the opcode and allow for reusable Debug Module implementations.
0,"While in Debug Mode, XLEN is DXLEN."
0,It is up to the debugger to determine the XLEN during normal program execution (by looking at misa) and to clearly communicate this to the user.
0,The supported Core Debug Registers must be implemented for each hart that can be debugged.
0,"They are CSRs, accessible using the RISC-V csr opcodes and optionally also using abstract debug commands."
0,cause priorities are assigned such that the least predictable events have the highest priority.
0,4: External debug support exists as it is described in this document.
0,0: ebreak instructions in M-mode behave as described in the Privileged Spec.
0,0: ebreak instructions in S-mode behave as described in the Privileged Spec.
0,0: ebreak instructions in U-mode behave as described in the Privileged Spec.
0,0: Interrupts are disabled during single stepping.
0,1: Interrupts are enabled during single stepping.
0,Implementations may hard wire this bit to 0.
0,In that case interrupt behavior can be emulated by the debugger.
0,1: Don't increment any counters while in Debug Mode or on ebreak instructions that cause entry into Debug Mode.
0,These counters include the cycle and instret CSRs.
0,This is preferred for most debugging scenarios.
0,1: Don't increment any hart-local timers while in Debug Mode.
0,"When there are multiple reasons to enter Debug Mode in a single cycle, hardware should set cause to the cause with the highest priority."
0,2: The Trigger Module caused a breakpoint exception.
0,"(priority 4, highest) 3: The debugger requested entry to Debug Mode using haltreq."
0,(priority 1) 4: The hart single stepped because step was set.
0,"(priority 0, lowest) 5: The hart halted directly out of reset due to resethaltreq."
0,It is also acceptable to report 3 when this happens.
0,(priority 2) 0: MPRV in mstatus is ignored in Debug Mode.
0,1: MPRV in mstatus takes effect in Debug Mode.
0,Implementing this bit is optional.
0,"It may be tied When set, there is a Non-Maskable-Interrupt (NMI) pending for the hart."
0,"Since an NMI can indicate a hardware error condition, reliable debugging may no longer be possible once this bit becomes set."
0,This is implementation-
0,"When set and not in Debug Mode, the hart will only execute a single instruction and then enter Debug Mode."
0,"If the instruction does not complete due to an exception, the hart will immediately enter Debug Mode before executing the trap handler, with appropriate exception registers set."
0,The debugger must not change the value of this Contains the privilege level the hart was operating in when Debug Mode was entered.
0,The encoding is described in Table4.5.
0,A debugger can change this value to change the hart's privilege level when exiting Debug Mode.
0,"Upon entry to debug mode, dpc is updated with the virtual address of the next instruction to be executed."
0,The behavior is described in more detail in Table4.3.
0,Table 4.3: Virtual address in DPC upon Debug Mode Entry
0,"When resuming, the hart's PC is updated to the virtual address stored in dpc."
0,A debugger may write dpc to change where the hart resumes.
0,Optional scratch register that can be used by implementations that need it.
1,A debugger must not write to this register unless hartinfo explicitly mentions it (the Debug Module may use this register internally).
0,Optional scratch register that can be used by implementations that need it.
1,A debugger must not write to this register unless hartinfo explicitly mentions it (the Debug Module may use this register internally).
0,"A virtual register is one that doesn't exist directly in the hardware, but that the debugger exposes as if it does."
0,"Debug software should implement them, but hardware can skip this section."
0,Virtual registers exist to give users access to functionality that's not part of standard debuggers without requiring them to carefully modify debug registers while the debugger is also accessing those same registers.
1,Users can read this register to inspect the privilege level that the hart was running in when the hart halted.
1,Users can write this register to change the privilege level that the hart will run in when it resumes.
0,"This register contains prv from dcsr, but in a place that the user is expected to access."
1,"The user should not access dcsr directly, because doing so might interfere with the debugger."
0,Contains the privilege level the hart was operating in when Debug Mode was entered.
0,"The encoding is described in Table4.5, and matches the privilege level encoding from the Privileged Spec."
0,A user can write this value to change the hart's
0,"Triggers can cause a breakpoint exception, entry into Debug Mode, or a trace action without having to execute a special instruction."
0,This makes them invaluable when debugging code from ROM.
0,"They can trigger on execution of instructions at a given memory address, or on the address/data in loads/stores."
0,"These are all features that can be useful without having the Debug Module present, so the Trigger Module is broken out as a separate piece that can be implemented separately."
0,"A hart can be compliant with this specification without implementing any trigger functionality at all, but if it is implemented then it must conform to this section."
0,Each trigger may support a variety of features.
0,A debugger can build a list of all triggers and their features as follows:
1,Read back tselect and check that it contains the written value.
1,"If not, exit the loop."
1,"If that caused an exception, the debugger must read tdata1 to discover the type."
0,"(If type is 0, this trigger doesn't exist."
0,"If info is 1, this trigger doesn't exist."
0,"Otherwise, the selected trigger supports the types discovered in info."
0,"7.Repeat, incrementing the value in tselect."
0,The above algorithm reads back tselect so that implementations which have 2n triggers only need to implement n bits of tselect.
0,The algorithm checks tinfo and type in case the implementation has m bits of tselect but It is possible for a trigger with the enter Debug Mode action (1) and another trigger with the raise a breakpoint exception action (0) to fire at the same time.
0,The preferred behavior is to have both actions take place.
0,It is implementation-dependent which of the two happens first.
0,This ensures both that the presence of an external debugger doesn't affect execution and that a trigger set by user code doesn't affect the external debugger.
1,"If this is not implemented, then the hart must enter Debug Mode and ignore the breakpoint exception."
0,"In the latter case, hit of the trigger"
0,"whose action is 0 must still be set, giving a debugger an opportunity to handle this case."
0,What happens with trace actions when triggers with different actions are also firing is left to the trace specification.
0,Triggers can be used for native debugging.
0,On a fully featured system triggers will be set using
0,"u or s, and when firing they can cause a breakpoint exception to trap to a more privileged mode."
0,It is possible to set triggers natively to fire in M mode as well.
0,In that case there is no higher privilege mode to trap to.
1,"When such a trigger causes a breakpoint exception while already in a trap handler, this will leave the system unable to resume normal execution."
0,On full-featured systems this is a remote corner case that can probably be ignored.
0,"On systems that only implement M mode, however, it is recommended to implement one of two solutions to this problem."
0,This way triggers can be useful for native debugging of even M mode code.
1,The simple solution is to have the hardware prevent triggers with action=0 from firing while in M mode and while MIE in mstatus is 0.
0,Its limitation is that interrupts might be disabled at other times when a user might want triggers to fire.
0,A more complex solution is to implement mte and mpte in tcontrol.
0,This solution has the benefit that it only disables triggers during the trap handler.
0,A user setting M mode triggers that cause breakpoint exceptions will have to be aware of any problems that might come up with the particular system they are working on.
0,"These registers are CSRs, accessible using the RISC-V csr opcodes and optionally also using abstract debug commands."
0,Most trigger functionality is optional.
0,All tdata registers follow write-any-read-legal semantics.
1,"If a debugger writes an unsupported configuration, the register will read back a value that is supported (which may simply be a disabled trigger)."
1,"This means that a debugger must always read back values it writes to tdata registers, unless it already knows already what is supported."
0,"Writes to one tdata register may not modify the contents of other tdata registers, nor the configuration of any trigger besides the one that is currently selected."
0,The trigger registers are only accessible in machine and Debug Mode to prevent untrusted user code from causing entry into Debug Mode without the OS's permission.
0,"In this section XLEN means MXLEN when in M-mode, and DXLEN when in Debug Mode."
0,Note that this makes several of the fields in tdata1 move around based on the current execution mode and value of MXLEN.
0,This register determines which trigger is accessible through the other trigger registers.
1,"The set of accessible triggers must start at 0, and be contiguous."
0,Writes of values greater than or equal to the number of supported triggers may result in a different value in this register than what was written.
0,"To verify that what they wrote is a valid index, debuggers can read back the value and check that tselect holds what they wrote."
1,"Since triggers can be used both by Debug Mode and M-mode, the debugger must restore this register if it modifies it."
0,1: The trigger is a legacy SiFive address match trigger.
0,These should not be implemented and aren't further documented here.
0,The remaining bits in this register act as
0,described in mcontrol.
0,3: The trigger is an instruction count trigger.
0,The remaining bits in this register act as described in icount.
0,5: The trigger is an exception trigger.
0,The remaining bits in this register act as described in etrigger.
0,1: Only Debug Mode can write the tdata registers at the selected tselect.
0,Writes from other modes are ignored.
1,"If XLEN is less than DXLEN, writes to this register are sign-extended."
1,"If XLEN is less than DXLEN, writes to this register are sign-extended."
0,One bit for each possible type enumerated in tdata1.
0,"Bit N corresponds to type N. If the bit is set, then that type is supported by the currently selected trigger."
0,"If type is not writable, this register may be unimplemented, in which case reading it causes an illegal instruction exception."
0,In this case the debugger can read the only supported type from
0,This optional register is one solution to a problem regarding triggers with action=0 firing in M-mode trap handlers.
0,See Section5.1for more details.
0,0: Triggers with action=0 do not match/fire while the hart is in M-mode.
0,1: Triggers do match/fire while the hart is in Mmode.
0,"When mret is executed, mte is set to the value"
0,This register is only writable in M mode and Debug Mode.
0,"Machine mode software can write a context number to this register, which can be used to set triggers that only fire in that specific context."
0,bits in this field to 0.
0,"It's recommended to implement no more than 6 bits on RV32, and 13 on"
0,"This register is only writable in S mode, M mode and Debug Mode."
0,"Supervisor mode software can write a context number to this register, which can be used to set triggers that only fire in that specific context."
0,bits in this field to 0.
0,"It's recommended to implement no more than 16 bits on RV32, and 34 on"
0,This register is accessible as tdata1 when type is 2.
0,Address and data trigger implementation are heavily dependent on how the processor core is implemented.
0,"To accommodate various implementations, execute, load, and store address/data triggers may fire at whatever point in time is most convenient for the implementation."
0,may request specific timings as described in timing.
0,Table5.8suggests timings for the best user experience.
0,This trigger type may be limited to address comparisons (select is always 0) only.
1,"If that is the case, then tdata2 must be able to hold all valid virtual addresses but it need not be capable of holding other values."
0,Specifies the largest naturally aligned powers-oftwo (NAPOT) range supported by the hardware when match is 1.
0,The value is the logarithm base 2 of the number of bytes in that range.
0,A value of 0 indicates that only exact value matches are supported (one byte range).
0,"A value of 63 corresponds to the maximum NAPOT range, which is This field only exists if XLEN is greater than 32."
0,In that case it extends size.
0,"If it does not exist If this optional bit is implemented, the hardware sets it when this trigger matches."
0,The trigger's user can set or clear it at any time.
0,It is used to determine which trigger(s) matched.
0,"If the bit is not implemented, it is always 0 and writing it has"
0,"0: The action for this trigger will be taken just before the instruction that triggered it is executed, but after all preceding instructions are committed."
0,ter the instruction that triggered it is executed.
0,"It should be taken before the next instruction is executed, but it is better to implement triggers and not implement that suggestion than to not implement them at all."
0,"the other, possibly dependent on select, execute, load, and store."
0,This bit primarily exists for the hardware to communicate to the debugger what will happen.
0,"Hardware may implement the bit fully writable, in which case the debugger has a little more control."
0,the same load happening again when the debugger lets the hart run.
0,"For data load triggers, debuggers must first attempt to set the breakpoint with timing of 1."
0,timing value will never fire (unless consecutive instructions match the appropriate triggers).
0,This field contains the 2 low bits of size.
0,The high bits come from sizehi.
0,The combined value is interpreted as follows:
0,"The behavior is only well defined if select=0, or if the access size is XLEN."
0,1: The trigger will only match against 8-bit memory accesses.
0,3: The trigger will only match against 32-bit memory accesses or execution of 32-bit instructions.
0,5: The trigger will only match against 64-bit memory accesses or execution of 64-bit instructions.
0,7: The trigger will only match against execution of 96-bit instructions.
0,8: The trigger will only match against execution of 112-bit instructions.
0,"0: When this trigger matches, the configured action is taken."
0,"1: While this trigger does not match, it prevents the trigger with the next index from matching."
0,"A trigger chain starts on the first trigger with chain=1 after a trigger with chain=0, or simply on the first trigger if that has chain=1."
0,It ends on the first trigger after that which has chain=0.
0,This final trigger is part of the chain.
0,The action on all but the final trigger is ignored.
0,The action on that final trigger will be taken if and only if all the triggers in the chain match at the same time.
0,"Because chain affects the next trigger, hardware must zero it in writes to mcontrol that set dmode to 0 if the next trigger has dmode of 1."
0,In addition hardware should ignore writes to mcontrol that set dmode to 1 if the previous trigger has both dmode of 0 and chain of 1.
0,Debuggers must avoid the latter case by checking chain on the previous trigger if they're writing mcontrol.
0,length of a trigger chain (eg.
0,to meet timing requirements) may do so by zeroing chain in writes
0,1: Matches when the top M bits of the value match the top M bits of tdata2.
0,M is XLEN-1 minus the index of the least-significant bit containing 0 in tdata2.
0,4: Matches when the lower half of the value equals the lower half of tdata2 after the lower half of the value is ANDed with the upper half of tdata2.
0,5: Matches when the upper half of the value equals the lower half of tdata2 after the upper half of the value is ANDed with the upper half of tdata2.
0,This register is accessible as tdata1 when type is 3. and for software monitor programs.
0,For that case it is not necessary to support count greater than 1.
0,"The only two combinations of the mode bits that are useful in those scenarios are u by itself, or m, s, and u all set."
0," If the hardware limits count to 1, and changes mode bits instead of decrementing count, this register can be implemented with just 2 bits."
0,"One for u, and one for m and s tied together."
1,"If only the external debugger or only a software monitor needs to be supported, a single bit is enough."
0,"If this optional bit is implemented, the hardware sets it when this trigger matches."
0,The trigger's user can set or clear it at any time.
0,It is used to determine which trigger(s) matched.
0,"If the bit is not implemented, it is always 0 and writing it has When count is decremented to 0, the trigger fires."
0,"Instead of changing count from 1 to 0, it is also acceptable for hardware to clear m, s, and u."
0,This allows count to be hard-wired to 1 if this register
0,This register is accessible as tdata1 when type is 4.
0,This trigger may fire on any of the interrupts configurable in mie (described in the Privileged Spec).
0,The interrupts to fire on are configured by setting the same bit in tdata2 as would be set in mie to enable the interrupt.
0,Hardware may only support a subset of interrupts for this trigger.
0,A debugger must read back tdata2 after writing it to confirm the requested functionality is actually supported.
0,The trigger only fires if the hart takes a trap because of the interrupt.
0,it does not fire when a timer interrupt occurs but that interrupt is not enabled in mie.)
1,"When the trigger fires, all CSRs are updated as defined by the Privileged Spec, and the requested action is taken just before the first instruction of the interrupt/exception handler is executed."
0,"If this optional bit is implemented, the hardware sets it when this trigger matches."
0,The trigger's user can set or clear it at any time.
0,It is used to determine which trigger(s) matched.
0,"If the bit is not implemented, it is always 0 and writing it has"
0,This register is accessible as tdata1 when type is 5.
0,"This trigger may fire on up to XLEN of the Exception Codes defined in mcause (described in the Privileged Spec, with Interrupt=0)."
0,Those causes are configured by writing the corresponding bit in tdata2.
0,"to trap on an illegal instruction, the debugger sets bit 2 in tdata2.)"
0,Hardware may support only a subset of exceptions.
0,A debugger must read back tdata2 after writing it to confirm the requested functionality is actually supported.
1,"When the trigger fires, all CSRs are updated as defined by the Privileged Spec, and the requested action is taken just before the first instruction of the interrupt/exception handler is executed."
0,"If this optional bit is implemented, the hardware sets it when this trigger matches."
0,The trigger's user can set or clear it at any time.
0,It is used to determine which trigger(s) matched.
0,"If the bit is not implemented, it is always 0 and writing it has"
0,"This register is accessible as tdata3 when type is 2, 3, 4, or 5."
0,All functionality in this register is optional.
0,The value bits may tie any number of upper bits to 0.
0,The select bits may only support 0 (ignore).
0,This is the layout of textra if XLEN is 64.
0,"The fields are defined above, in textra32."
0,Debug Transport Modules provide access to the DM over one or more transports (e.g. JTAG or USB).
0,There may be multiple DTMs in a single platform.
0,"Ideally every component that communicates with the outside world includes a DTM, allowing a platform to be debugged through every transport it supports."
0,For instance a USB component could include a DTM.
0,This would trivially allow any platform to be debugged over USB.
0,All that is required is that the USB module already in use also has access to the Debug Module Interface.
0,Using multiple DTMs at the same time is not supported.
0,It is left to the user to ensure this does not happen.
0,This specification defines a JTAG DTM in Section6.1.
0,Additional DTMs may be added in future versions of this specification.
0,An implementation can be compliant with this specification without implementing any of this section.
0,"In that case it must be advertised as conforming to RISC-V Debug Specification 0.13.2, with custom DTM."
0,"If the JTAG DTM described here is implemented, it must be advertised as conforming to the RISC-V Debug Specification 0.13.2, with JTAG DTM."
0,This Debug Transport Module is based around a normal JTAG Test Access Port (TAP).
1,"The JTAG TAP allows access to arbitrary JTAG registers by first selecting one using the JTAG instruction register (IR), and then accessing it through the JTAG data register (DR)."
0,JTAG refers to IEEE Std 1149.1-2013.
0,"It is a standard that defines test logic that can be included in an integrated circuit to test the interconnections between integrated circuits, test the integrated 62"
0,"circuit itself, and observe or modify circuit activity during the components normal operation."
0,This specification uses the latter functionality.
0,"The JTAG standard defines a Test Access Port (TAP) that can be used to read and write a few custom registers, which can be used to communicate with debug hardware in a component."
0,JTAG TAPs used as a DTM must have an IR of at least 5 bits.
1,"When the TAP is reset, IR must default to 00001, selecting the IDCODE instruction."
0,A full list of JTAG registers along with their encoding is in Table6.1.
0,"If the IR actually has more than 5 bits, then the encodings in Table6.1 should be extended with 0's in their most significant bits."
0,"The only regular JTAG registers a debugger might use are BYPASS and IDCODE, but this specification leaves IR space for many other standard JTAG instructions."
0,Unimplemented instructions must select the BYPASS register.
0,This register is selected (in IR) when the TAP state machine is reset.
0,Its definition is exactly as defined in IEEE Std 1149.1-2013.
0,Identifies the designer/manufacturer of this part.
0,Bits 6:0 must be bits 6:0 of the designer/manufacturer's Identification Code as assigned by JEDEC Standard JEP106.
0,Bits 10:7 contain the modulo16 count of the number of continuation characters
0,The size of this register will remain constant in future versions so that a debugger can always determine the version of the DTM.
0,"Writing 1 to this bit does a hard reset of the DTM, causing the DTM to forget about any outstanding DMI transactions."
0,In general this should only be used when the Debugger has reason to expect that the outstanding DMI transaction will never complete (e.g. a reset condition caused an inflight This is a hint to the debugger of the minimum number of cycles a debugger should spend in RunTest/Idle after every DMI scan to avoid a 'busy' return code (dmistat of 3).
0,A debugger must still check dmistat when necessary.
0,1: Enter Run-Test/Idle and leave it immediately.
0,2: Enter Run-Test/Idle and stay there for 1 cycle before leaving.
0,cess was still in progress (resulted in op of 3).
0,0: Version described in spec version 0.11.
0,1: Version described in spec version 0.13.
0,This register allows access to the Debug Module Interface (DMI).
0,"In Capture-DR, the DTM updates data with the result from that operation, updating op if the current op isn't sticky."
0,See SectionB.1and Table	 for examples of how this is used.
0,"scans, which must all be executed or stop as soon as there's a problem."
0, For instance a series of scans may write a Debug Program and execute it.
0,"If one of the writes fails but the execution continues, then the Debug Program may hang or have other unexpected side effects."
0,value is used to access the DM over the DMI.
0,Don't send anything over the DMI during Update-DR.
0,This operation should never result in a busy or error response.
0,The address and data reported in the following Capture-DR are undefined.
0,2: A previous operation failed.
0,The data scanned into dmi in this access will be ignored.
0,This status is sticky and can be cleared by writing dmireset in dtmcs.
0,"There are no specified cases in which the DM would respond with an error, and DMI is not required to support returning errors."
0,quest is still in progress.
0,The data scanned into dmi in this access will be ignored.
0,This status is sticky and can be cleared by writing dmireset in dtmcs.
0,"If a debugger sees this status, it needs to give the target more TCK edges between UpdateDR and Capture-DR."
0,The simplest way to do that
0,1-bit register that has no effect.
1,It is used when a debugger does not want to communicate with this TAP.
0,"To make it easy to acquire debug hardware, this spec recommends a connector that is compatible with the MIPI-10 .05 inch connector specification, as described in the MIPI Alliance Recommendation for Debug and Trace Connectors, Version 1.10.00, 16 March 2011."
0,"The connector has .05 inch spacing, gold-plated male header with .016 inch thick hardened copper or beryllium bronze square posts (SAMTEC FTSH or equivalent)."
0,Female connectors are compatible 20µm gold connectors.
0,"Viewing the male header from above (the pins pointing at your eye), a target's connector looks as it does in Table6.5."
0,The function of each pin is described in Table6.7.
1,If a platform requires nTRST then it is permissible to reuse the nRESET pin as the nTRST signal.
1,"If a platform requires both system reset and TAP reset, the MIPI-20 connector should be used."
0,"Its physical connector is virtually identical to MIPI-10, except that it's twice as long, supporting twice as many pins."
0,Its connector is show in Table6.6.
0,The same connectors can be used for 2-wire cJTAG.
0,"In that case TMS is used for TMSC, and TCK is used for TCKC."
0,Below are two possible implementations.
0,"A designer could choose one, mix and match, or come up with their own design."
0,Muxes on the register file(s) allow for accessing GPRs and CSRs using the Access Register abstract command.
0,Memory is accessed using the Abstract Access Memory command or through System Bus Access.
1,This implementation could allow a debugger to collect information from the hart even when that hart is unable to execute instructions.
0,"This implementation only implements the Access Register abstract command for GPRs on a halted hart, and relies on the Program Buffer for all other operations."
0,It uses the hart's existing pipeline and ability to execute from arbitrary memory locations to avoid modifications to a hart's datapath.
1,"When the halt request bit is set, the Debug Module raises a special interrupt to the selected harts."
0,This interrupt causes each hart to enter Debug Mode and jump to a defined memory region that is serviced by the DM.
1,"When taking this exception, pc is saved to dpc and cause is updated in dcsr."
0,The code in the Debug Module causes the hart to execute a park loop.
0,In the park loop the hart writes its mhartid
0,to a memory location within the Debug Module to indicate that it is halted.
1,"To allow the DM to individually control one out of several halted harts, each hart polls for flags in a DM-controlled memory location to determine whether the debugger wants it to execute the Program Buffer or perform a resume."
0,"To execute an abstract command, the DM first populates some internal words of program buffer according to command."
1,"When transfer is set, the DM populates these words with lw <gpr>, 0x400(zero) or sw 0x400(zero), <gpr>."
0,64and 128-bit accesses use ld/sd and lq/sq respectively.
1,"If transfer is not set, the DM populates these instructions as nops."
1,"If execute is set, execution continues to the debugger-controlled Program Buffer, otherwise the DM causes a ebreak to execute immediately."
1,When ebreak is executed (indicating the end of the Program Buffer code) the hart returns to its park loop.
1,"If an exception is encountered, the hart jumps to a debug exception address within the Debug Module."
0,The code at that address causes the hart to write to an address in the Debug Module which indicates exception.
0,This address is considered I/O for fence instructions (see #9 on page39).
0,Then the hart jumps back to the park loop.
0,"The DM infers from the write that there was an exception, and sets cmderr appropriately."
1,"To resume execution, the debug module sets a flag which causes the hart to execute a dret."
1,"When dret is executed, pc is restored from dpc and normal execution resumes at the privilege set by prv."
0,are mapped into regular memory at an address relative to zero with only a 12-bit imm.
0,The exact address is an implementation detail that a debugger must not rely on.
0,"For additional flexibility, progbuf0, etc."
0,"are mapped into regular memory immediately preceding data0, in order to form a contiguous region of memory which can be used for either program execution or data transfer."
0,This section details how an external debugger might use the described debug interface to perform some common operations on RISC-V cores using the JTAG DTM described in Section6.1.
0,All these examples assume a 32-bit core but it should be easy to adapt the examples to 64or 128-bit cores.
0,"To keep the examples readable, they all assume that everything succeeds, and that they complete faster than the debugger can perform the next access."
0,This will be the case in a typical JTAG setup.
0,"However, the debugger must always check the sticky error status bits after performing a sequence of actions."
1,"If it sees any that are set, then it should attempt the same actions again, possibly while adding in some delay, or explicit checks for status bits."
1,"To read an arbitrary Debug Module register, select dmi, and scan in a value with op set to 1, and address set to the desired register address."
1,"In Update-DR the operation will start, and in Capture-DR its results will be captured into data."
0,"If the operation didn't complete in time, op will be 3 and the value in data must be ignored."
1,"The busy condition must be cleared by writing dmireset in dtmcs, and then the second scan scan must be performed again."
0,This process must be repeated until op returns 0.
0,"In later operations the debugger should allow for more time between Capture-DR and Update-DR. To write an arbitrary Debug Bus register, select dmi, and scan in a value with op set to 2, and address and data set to the desired register address and data respectively."
0,"From then on everything happens exactly as with a read, except that a write is performed instead of the read."
0,"It should almost never be necessary to scan IR, avoiding a big part of the inefficiency in typical JTAG use."
0,A user will want to know as quickly as possible when a hart is halted (e.g. due to a breakpoint).
0,"To efficiently determine which harts are halted when there are many harts, the debugger uses the haltsum registers."
1,"Assuming the maximum number of harts exist, first it checks haltsum3."
1,"For each bit set there, it writes hartsel, and checks haltsum2."
0,This process repeats through haltsum1 and haltsum0.
1,"Depending on how many harts exist, the process should start at one of the lower haltsum registers."
1,"To halt one or more harts, the debugger selects them, sets haltreq, and then waits for allhalted to indicate the harts are halted."
1,"Then it can clear haltreq to 0, or leave it high to catch a hart that resets while halted."
0,"First, the debugger should restore any registers that it has overwritten."
1,Then it can let the selected harts run by setting resumereq.
1,"Once allresumeack is set, the debugger knows the hart has resumed, and it can clear resumereq."
1,Harts might halt very quickly after resuming (e.g. by hitting a software breakpoint) so the debugger cannot use allhalted/anyhalted to check whether the hart resumed.
0,Using the hardware single step feature is almost the same as regular running.
0,The debugger just sets step in dcsr before letting the hart run.
0,"The hart behaves exactly as in the running case, except that interrupts may be disabled (depending on stepie) and it only fetches and executes a single instruction before re-entering Debug Mode."
0,Abstract commands are used to exchange data with GPRs.
0,"Using this mechanism, other registers can be accessed by moving their value into/out of GPRs."
0,"With system bus access, addresses are physical system bus addresses."
0,Read a word from memory using system bus access:
0,"Through the Program Buffer, the hart performs the memory accesses."
0,Addresses are physical or virtual (depending on mprven and other system configuration).
0,"Abstract memory accesses act as if they are performed by the hart, although the actual implementation may differ."
0,"With system bus access, addresses are physical system bus addresses."
0,Write a word to memory using system bus access:
0,"Through the Program Buffer, the hart performs the memory accesses."
0,Addresses are physical or virtual (depending on mprven and other system configuration).
0,"Abstract memory accesses act as if they are performed by the hart, although the actual implementation may differ."
0,A debugger can use hardware triggers to halt a hart when a certain event occurs.
0,"Below are some examples, but as there is no requirement on the number of features of the triggers implemented by a hart, these examples may not be applicable to all implementations."
1,"When a debugger wants to set a trigger, it writes the desired configuration, and then reads back to see if that configuration is supported."
0,Generally the debugger can avoid exceptions by being careful with the programs it writes.
0,"Sometimes they are unavoidable though, e.g. if the user asks to access memory or a CSR that is not implemented."
0,"A typical debugger will not know enough about the platform to know what's going to happen, and must attempt the access to determine the outcome."
1,"When an exception occurs while executing the Program Buffer, cmderr becomes set."
0,The debugger can check this field to see whether a program encountered an exception.
0,"If there was an exception, it's left to the debugger to know what must have caused it."
0,There are a variety of instructions to transfer data between GPRs and the data registers.
0,They are either loads/stores or CSR reads/writes.
0,The specific addresses also vary.
0,This is all specified in hartinfo.
0,"The examples here use the pseudo-op transfer dest, src to represent all these options."
0,This shows an example of setting the m bit in mcontrol to enable a hardware breakpoint in Mmode.
0,Similar quick access instructions could have been used previously to configure the trigger that is being enabled here:
0,"Since the ratification of 0.13, the following bugs have been fixed in 0.13.1:"
0,The third paragraph of Section 3.5 has a mistake.
0,"At the end of the process described there, the resume ack bit is set."
0,"The Argument Width of the Access Memory abstract command defined in Section 3.7.1.3 is determined by DXLEN, and not by aamsize."
0,"The order of operations listed in Section 3.12.23, describing reads from sbdata0, is incorrect."
0,It should read: Reads from this register start the following: 1.Return the data.
0,"If sbreadondata is set, perform another system bus read."
0,"4.If sbautoincrement is set, increment sbaddress."
0,"When a hart comes out of reset and haltreq is set, the hart will immediately enter Debug Mode."
0,The definition of mte in Section 5.2.6 should state that mte only affects triggers whose action is 0.
0,"In Section 5.2.13, when sselect is 0 it ignores svalue."
0,"In the last example in Section B.9, the value for tdata2 1 should be 0xefff8675."
0,Fixed a formatting issue that caused step 1 in the Quick Access description to be missing from the document.
0,This document describes the functionality of the reset controller and its interaction with the rest of the OpenTitan system.
0,The OpenTitan reset topology and reset controller block diagram are shown in the diagram below.
0,"The reset controller is closely related to the power controller, please refer to that spec for details on how reset controller inputs are controlled."
0,The test domain does not have sub reset trees.
0,TRSTn is used directly by all components in the domain.
0,"The Core domain consists of all remaining logic and contains 4 sub reset trees, see table below.This IP block implements a Full-Speed device according to the USB 2.0 specification."
0,It is attached to the chip interconnect bus as a peripheral module and conforms to the Comportable guideline for peripheral functionality.
0,Isochronous transfers larger than 64 bytes are currently not supported.
0,This feature might be added in a later version of this IP.
0,The USB device module is a simple software-driven generic USB device interface for Full-Speed USB 2.0 operation.
0,"The IP includes the physical layer interface, the low level USB protocol and a packet buffer interface to the software."
0,The physical layer interface features multiple transmit and receive paths to allow interfacing with a variety of USB PHYs or regular 3.3V IO pads for FPGA prototyping.
0,The USB device programming interface is not based on any existing interface.
0,"A useful quick reference for USB Full-Speed is USB Made Simple, Part 3 Data Flow."
0,The block diagram shows a high level view of the USB device including the main register access paths.
0,The USB Full-Speed interface runs at a data rate of 12 MHz.
0,The interface runs at four times this frequency and must be clocked from an accurate 48 MHz clock source.
0,"The USB specification for a Full-Speed device requires the average bit rate is 12 Mbps +/0.25%, so the clock needs to support maximum error of 2,500 ppm."
0,The maximum allowable integrated jitter is +/1 ns over 1 to 7 bit periods.
0,This module features the following output signals to provide a reference for synchronizing the 48 MHz clock source: usb_ref_pulse_o indicates the reception of a start of frame (SOF) packet.
0,The host is required to send a SOF packet every 1 ms.
0,It is set to one after the first SOF packet is received and remains high as long as usb_ref_pulse_o continues to behave as expected.
0,"As soon as it is detected that SOF will not be received as expected (usually because the link is no longer active), usb_ref_val_o deasserts to zero until after the next usb_ref_pulse_o."
0,Both these signals are synchronous to the 48 MHz clock.
0,"To successfully receive SOF packets without errors and thereby enabling clock synchronization, the initial accuracy of the 48 MHz clock source should be within 3.2% or 32,000 ppm."
0,This requirement comes from the fact that the SOF packet has a length of 24 bits (plus 8-bit sync field).
0,The first 8 bits are used to transfer the SOF packet ID (8b01011010).
0,"Internally, the USB device dynamically adjusts the sampling point based on observed line transitions."
0,"Assuming the last bit of the SOF packet ID is sampled in the middle of the eye, the drift over the remaining 16 bits of the packet must be lower than half a bit (10^6 * (0.5/16)=32,000 ppm)."
0,"To externally monitor the 48 MHz clock, the USB device supports an oscillator test mode which can be enabled by setting phy_config.tx_osc_test_mode to 1."
0,"In this mode, the device constantly transmits a J/K pattern but no longer receives SOF packets."
0,"Consequently, it does not generate reference pulses for clock synchronization."
0,Control transfers pass through synchronous FIFOs or have a ready bit synchronized across the clock domain boundary.
0,"A dual-port synchronous buffer SRAM is used for data transfers, and the bus clock and USB clock come from the same 48 MHz input."
0,"The wake detection module is clocked by a separate clock, and a couple registers are used to interface with it."
0,"Any bus-related clock domain crossings must happen outside the core, except for the transition between the 48 MHz clock and the wake detection modules clock."
0,The 48 MHz clock must be enabled to reach the registers in usbdev.
0,Full-Speed USB uses a bidirectional serial interface as shown in Figure 7-24 of the USB 2.0 Full-Speed specification.
0,"For reasons of flexibility, this IP block features multiple transmit and receive paths for interfacing with various transceivers."
0,The following sections describe how the various input/output signals relate to the USB interface pins for the different receive and transmit configurations.
0,"The IP block supports two different encodings, driving out on separate TX interfaces."
0,"The default encoding looks like the USB bus, with D+ and Dvalues driven on usb_dp_o and usb_dn_o pins."
0,"The alternate encoding uses usb_se0_o to indicate a single-ended zero (SE0), and usb_d_o encodes K/J (when usb_se0_o is low)."
0,"The TX mode can be selected by setting the use_tx_d_se0 bit in phy_config to either 1 (alternate, using d/se0) or 0 (default, using dp/dn)."
0,The following table summarizes how the different output signals relate to the USB interface pins.
0,"On an FPGA, the components should be used with a USB transceiver, as the regular bidirectional I/O cells will likely not be USB compliant."
0,"Note that according to the Comportable guideline for peripheral functionality, every output signal name_o has a dedicated output enable name_en_o."
0,"For TX data, these separate signals dp_en_o and dn_en_o all correspond to the same TX or output enable signal (OE in the USB spec)."
0,"The other signals listed are of the intersignal variety, and they do not go directly to pads or have dedicated output enable signals."
0,The IP block supports recovery of the differential K and J symbols from the output of an external differential receiver or directly from the D+/Dpair.
0,The D+/Dpair is always used to detect the single-ended zero (SE0) state.
0,The following table summarizes how the different input signals relate to the USB interface pins.
0,"On an FPGA, the components should be used with a USB transceiver, as the bidirectional regular IO cells will likely not be USB compliant."
0,This can be done inside the chip or with an external pin.
0,"A permanently connected resistor could be used if the pin flip feature is not needed, but this is not recommended because there is then no way to force the device to appear to unplug."
0,Only one of the pullup signals can be asserted at any time.
0,The selection is based on the pinflip bit in phy_config.
0,The suspend pin indicates to the USB transceiver that a constant idle has been detected on the link and the device is in the Suspend state (see Section 7.1.7.6 of the USB 2.0 specification).
0,Note that this may require a resistor divider or (for USB-C where VBUS can be up to 20V) active level translation to an acceptable voltage for the input pin.
0,"In an FPGA implementation, this signal can drive a 3.3V output pin that is driven high when the signal is asserted and set high impedance when the signal is deasserted, and the output pin used to drive a 1.5k resistor connected on the board to the D+ line."
0,"Alternatively, it can be used to enable an internal 1.5k pullup on the D+ pin."
0,"To control the pullup on the Dline, this USB device features dn_pullup_o signal."
0,"Of the two pullup signals dp_pullup_o and dn_pullup_o, only one can be enabled at any time."
0,"As this is a Full-Speed device, dp_pullup_o, i.e., the pullup on D+ is used by default (pinflip equals zero)."
0,"Referring to the Comportable guideline for peripheral device functionality, the module usbdev has the following hardware interfaces defined."
0,This interrupt is directly tied to whether a sent packet has not been acknowledged in the in_sent register.
1,"This interrupt is directly tied to the FIFO status, so the AV FIFO must be provided a free buffer before the interrupt is cleared."
1,"If the condition is not cleared, the interrupt can re-assert."
1,"This interrupt is directly tied to the FIFO status, so the RX FIFO must have an entry removed before the interrupt is cleared."
1,"If the condition is not cleared, the interrupt can re-assert."
0,"After transmitting the IN payload, the USB device expects a valid ACK handshake packet."
0,The USB link has a number of states.
0,These are detected and reported in usbstat.link_state and state changes are reported using interrupts.
0,The FSM implements a subset of the USB device state diagram shown in Figure 9-1 of the USB 2.0 specification.
0,"This is signaled when the VBUS is not driven by the host, which results in the sense input pin being low, or when the user has not connected the pull-up by enabling the interface."
0,"The device has been powered as VBUS is being driven by the host and the user has connected the pull-up, but the device has not been reset yet."
0,The implementation here will report the reset state and raise an interrupt when the link is in SE0 for 3 us.
0,"The link has been reset and can begin receiving packets, but no Start-of-Frame packets have yet been seen."
0,The link is awaiting the end of resume signaling before transitioning to the Active No SOF state.
0,"The USB 2.0 Full-Speed Protocol Engine is provided by the common USB interface code and is, strictly speaking, not part of this USB device module."
0,This means the USB device module must accept or provide data when requested.
0,The protocol engine may cancel a transaction because of a bad cyclic redundancy check (CRC) or request a retry if an acknowledgment (ACK) was not received.
0,A 2 kB SRAM is used as a packet buffer to hold data between the system and the USB interface.
0,This is divided up into 32 buffers each containing 64 bytes.
0,This is an asynchronous dual-port SRAM with software accessing from the bus clock domain and the USB interface accessing from the USB 48 MHz clock domain.
0,Software provides buffers for packet reception through a 4-entry Available Buffer FIFO.
0,"(More study needed but four seems about right: one just returned to software, one being filled, one ready to be filled, and one for luck)."
0,"The rxenable_out and rxenable_setup registers is used to indicate which endpoints will accept data from the host using OUT or SETUP transactions, respectively."
0,"When a packet is transferred from the host to the device (using an OUT or SETUP transaction) and reception of that type of transaction is enabled for the requested endpoint, the next buffer ID is pulled from the Available Buffer FIFO."
0,The packet data is written to the corresponding buffer in the packet buffer (the 2 kB SRAM).
0,"In addition, the buffer ID, the packet size, an out/setup flag and the endpoint ID are passed back to software using the Received Buffer FIFO and a pkt_received interrupt is raised."
0,Software should immediately provide a free buffer for future reception by writing the corresponding buffer ID to the Available Buffer FIFO.
0,It can then process the packet and eventually return the received buffer to the free pool.
0,This allows streaming on a single endpoint or across a number of endpoints.
0,"In the unfortunate event that the Available Buffer FIFO is empty or the Received Buffer FIFO is full, all OUT transactions are NAKed and SETUP transactions are ignored."
0,"In that event, the host will retry the transaction (up to some maximum attempts or time)."
0,"There are two options for a given OUT endpoints flow control, controlled by the set_nak_out register."
0,"For timing, this option implies that software may not be able to affect the response to a given transaction, and buffer availability is the only needed factor."
0,"That option uses NAK to defer the host, and this enables software to implement features that require protocol-level control at transaction boundaries, such as when implementing the functional stall."
0,"To send data to the host in response to an IN transaction, software first writes the data into a free buffer."
0,"Then, it writes the buffer ID, data length and rdy flag to the configin register of the corresponding endpoint."
0,"To keep track of such canceled buffers, the pend bit in the same register is set."
1,"Similarly, a Link Reset cancels any waiting IN transactions by clearing the rdy bit in the configin register of all endpoints."
0,The pend bit in the configin register is set for all endpoints with a pending IN transaction.
0,"The size of 64 bytes per buffer satisfies the maximum USB packet size for a Full-Speed interface for Control transfers (max may be 8, 16, 32 or 64 bytes), Bulk Transfers (max is 64 bytes) and Interrupt transfers (max is 64 bytes)."
0,It is small for Isochronous transfers (which have a max size of 1023 bytes).
0,The interface will need extending for high rate isochronous use (a possible option would be to allow up to 8 or 16 64-byte buffers to be aggregated as the isochronous buffer).
0,"The basic hardware initialization is to (in any order) configure the physical interface for the implementation via the phy_config register, fill the Available Buffer FIFO, enable IN and OUT endpoints with ID 0 (this is the control endpoint that the host will use to configure the interface), enable reception of SETUP and OUT packets on OUT Endpoint 0, and enable any required interrupts."
0,"Finally, the interface is enabled by setting the enable bit in the usbctrl register."
0,"Setting this bit causes the USB device to assert the pullup on the D+ line, which is used by the host to detect the device."
0,There is no need to configure the device ID in ( usbctrl.device_address) at this point â the line remains in reset and the hardware forces the device ID to zero.
0,"The second stage of initialization is done under control of the host, which will use control transfers (always beginning with SETUP transactions) to Endpoint 0."
0,Initially these will be sent to device ID 0.
0,"The host will then issue additional control transfers to Endpoint 0 to configure the device, now to the devices configured address."
0,"In response to the Set Configuration request, software should set up the rest of the endpoints for that configuration, including configuring the flow control behavior for OUT endpoints via the set_nak_out register, configuring the endpoint type via the rxenable_setup register (for a control endpoint) and the out_iso and in_iso registers (for isochronous OUT and IN endpoints, respectively)."
0,"Finally, software should enable the configured endpoints via the ep_out_enable and ep_in_enable registers."
0,Software needs to manage the buffers in the packet buffer (2 kB SRAM).
0,Each buffer can hold the maximum length packet for a Full-Speed interface (64 bytes).
0,"Other than for data movement, the management is most likely done based on their buffer ID which is a small integer between zero and (SRAM size in bytes)/(max packet size in bytes)."
0,"In order to avoid unintentionally deferring transactions, there must be buffers available when the host sends data to the device (an OUT or SETUP transaction)."
0,"Software needs to ensure (1) there are always buffer IDs in the Available Buffer FIFO, and (2) the Received Buffer FIFO is not full."
0,"For OUT transactions, if the Available Buffer FIFO is empty or the Received Buffer FIFO is full when data is received, a NAK will be returned to the host, requesting the packet be retried later."
0,"For SETUP transactions under the same conditions, the request will be dropped and a handshake will not be sent, indicating an error to the host and provoking a retry."
0,"These conditions cause the bus to be busy and perform no work, lowering performance for this device and potentially others on the same bus."
0,Timely management of buffers may have a significant impact on throughput.
0,"Keeping the Available Buffer FIFO full can be done with a simple loop, adding buffer IDs from the software-managed free pool until the FIFO is full."
0,"A simpler policy of just adding a buffer ID to the Available Buffer FIFO whenever a buffer ID is removed from the Received Buffer FIFO should work on average, but performance will be slightly worse when bursts of packets are received."
0,Flow control (using NAKs) may be done on a per-endpoint basis using the rxenable_out register.
0,This should only be done for short durations or the host may timeout the transaction.
0,The host will send OUT or SETUP transactions when it wants to transfer data to the device.
0,"The data packets are directed to a particular endpoint, and the maximum packet size is set per-endpoint in its Endpoint Descriptor (this must be the same or smaller than the maximum packet size supported by the device)."
0,Note that the data length could be between zero and the maximum packet size â in some situations a zero length packet is used as an acknowledgment or end of transfer.
0,The data length does not include the packet CRC.
0,"Packets with a bad CRC will not be transferred to the Received Buffer FIFO; the hardware will drop the transaction without a handshake, indicating an error to the host."
0,"For non-isochronous endpoints, this typically results in the host retrying the transaction."
0,The Endpoint Descriptor also includes a description of the frequency the endpoint should be polled (for isochronous and interrupt endpoints).
0,This data (with the packet CRC) will be sent as a response to the next IN transaction on the corresponding endpoint.
0,"Note that the configin for an endpoint is a single register, so no new data packet should be queued until the previous packet has been ACKed."
0,The out_stall and in_stall registers are used for endpoint stalling.
0,There is one dedicated register per endpoint.
0,Stalling is used to signal that the host should not retry a particular transmission or to signal certain error conditions (functional stall).
0,Control endpoints also use a STALL to indicate unsupported requests (protocol stall).
0,"Unused endpoints can have their in_stall or out_stall register left clear, so in many cases there is no need to use the register."
0,The hardware will then send a STALL response to all IN/OUT transactions until the next SETUP is received for this endpoint.
0,Receiving the SETUP token clears the in_stall and out_stall registers for that endpoint.
0,This register can be used to read out the state of the USB device inputs and outputs from software.
0,This is designed to be used for debugging purposes or during chip testing.
0,This register can be used to control the USB device inputs and outputs from software.
0,This is designed to be used for debugging purposes or during chip testing.
0,This interrupt is directly tied to whether a sent packet has not been acknowledged in the in_sent register.
0,"After transmitting the IN payload, the USB device expects a valid ACK handshake packet."
0,Its intention is to handle a resume-from-suspend event after the IP has been powered down.
0,This bit must be set to enable upstream transactions to be received on the endpoint and elicit responses.
0,Reflects the state of the sense pin.
0,1 indicates that the host is providing VBUS.
0,Note that this bit always shows the state of the actual pin and does not take account of the override control.
0,These buffers have packets that have been received and should be popped from the FIFO and processed.
0,This field contains the buffer ID that data was received into.
0,On read the buffer ID is popped from the Received Buffer FIFO and returned to software.
0,This field contains the data length in bytes of the packet written to the buffer.
0,This bit indicates if the received transaction is of type SETUP (1) or OUT (0).
0,This field contains the endpoint ID to which the packet was directed.
0,This bit must be set to enable SETUP transactions to be received on the endpoint.
0,This bit must be set to enable OUT transactions to be received on the endpoint.
1,"When this bit is set, hardware will clear this endpoint's rxenable_out bit whenever an OUT transaction is received on this endpoint."
1,This bit should not be changed while the endpoint is active.
0,This bit will be set when the ACK is received from the host to indicate successful packet delivery as part of an IN transaction.
0,Note that SETUP transactions are always either accepted or ignored.
0,"For endpoints that accept SETUP transactions, a SETUP packet will clear the STALL flag on endpoints for both the IN and OUT directions."
0,Note that SETUP transactions are always either accepted or ignored.
0,"For endpoints that accept SETUP transactions, a SETUP packet will clear the STALL flag on endpoints for both the IN and OUT directions."
0,This bit indicates a pending transaction was canceled by the hardware.
0,This bit should be set to indicate the buffer is ready for sending.
0,This allows use of the IN channel for transfer of SETUP information.
0,The original buffer must be resubmitted after the SETUP sequence is complete.
0,A link reset also clears the bit.
0,In either of the cases where the hardware cancels the transaction it will also set the pend bit.
0,No handshake packet will be expected for an IN transaction.
0,Regardless of the state of this field usb_rx_dp and usb_rx_dn are always used to detect SE0.
0,"This bit also feeds the rx_enable pin, activating the receiver when the device is not suspended."
0,This directly controls the output pin of the same name.
0,"It is intended to be used to enable the use of a variety of external transceivers, to select an encoding that matches the transceiver."
0,"Recognize a single SE0 bit as an end of packet, otherwise two successive bits are required."
0,Particularly useful if D+/Dare mapped to SBU1/SBU2 pins of USB-C.
0,"Note that while in oscillator test mode, the device no longer receives SOFs and consequently does not generate the reference signal for clock synchronization."
0,The clock might drift off.
0,"Activation may not happen immediately, and its status can be verified by checking wake_events.module_active."
0,Signal to the wake detection module that it may release control of the pull-ups back to the main block and return to an inactive state.
0,The release back to normal state may not happen immediately.
0,The status can be confirmed via wake_events.module_active.
0,"Note that this bit can also be used without powering down, such as when usbdev detects resume signaling before transitions to low power states have begun."
0,"For better receive sensitivity, lower transmit jitter and to be standard compliant, a dedicated, differential USB transceiver such as the USB1T11A or the USB1T20 must be used (see Section 7.1.4.1 of the USB 2.0 specification)."
0,"Depending on the selected USB transceiver, either the dp/dn or d/se0 transmit paths or can be used to interface the IP block with the transceiver."
0,"If the selected USB transceiver contains a differential receiver, its output may also be enabled and passed to the D input of the IP block."
0,When prototyping on FPGAs the interface can be implemented with pseudo-differential 3.3V GPIO pins for D+ and D-.
0,The receiver will oversample to recover the bitstream and clock alignment even if there is considerable timing skew between the signal paths.
0,"The full speed transmit always uses LVCMOS output drivers (see USB 2.0 spec Figure 7-1 and Figure 7-3) but there are two possible encodings: Either the D+ and Dvalues are directly driven from tx_dp and tx_dn, or there is a data value from tx_d and an indicator to force SE0 from tx_se0."
0,"External to the IP, these should be combined to drive the actual pins when transmit is enabled and receive otherwise."
0,Using standard 3.3V IO pads allows use on most FPGAs although the drive strength and series termination resistors may need to be adjusted to meet the USB signal eye.
0,"On a Xilinx Artix-7 (and less well tested Spartan-7) part, setting the driver to the 8mA, FAST setting seems to work well with a 22R series termination (and with a 0R series termination)."
0,The interface was developed using the Digilent Nexys Video board with a PMOD card attached.
0,A PMOD interface with direct connection to the SoC should be used (some PMOD interfaces include 100R series resistors which break the signal requirements for USB).
0,The PMOD card includes two USB micro-B connectors and allows two USB interfaces to be used.
0,The D+ and Dsignals have 22R series resistors (in line with the USB spec) and there is a 1.5k pullup on D+ to the pullup enable signal.
0,There is a resistive divider to set the sense pin at half of the VBUS voltage which enables detection on the FPGA without overvoltage on the pin.
0,Data is transferred to the host based on the host requesting a transfer with an IN transaction.
0,"Data is queued for transmission by writing the corresponding configin register with the buffer ID containing the data, the length in bytes of data (0 to maximum packet length) and setting the rdy bit."
0,"The higher level protocol engine forms the bitstream into packets, performs CRC checking and recognizes IN, OUT and SETUP transactions."
0,"At the lowest level of the USB stack the transmit bitstream is serialized, converted to non-return-to-zero inverted (NRZI) encoding with bit-stuffing and sent to the transmitter."
0,"The received bitstream is recovered, clock aligned and decoded and has bit-stuffing removed."
0,A Full-Speed device identifies itself by providing a 1.5k pullup resistor (to 3.3V) on the D+ line.
1,Implementations might allow a more-privileged level to trap otherwise permitted CSR accesses by a less-privileged level to allow these accesses to be intercepted.
1,Shadows CSRs provide a read-write address via which a higher privilege level can modify a register that is read-only at a lower privilege level.
1,CSRs that are read-only at some lower privilege level are shadowed into separate CSR addresses if they are made read-write at a higher privilege level.This avoids trapping permitted lower-privilege accesses while still causing traps on illegal accesses.
1,We require that lower privilege levels execute environment calls instead of reading CPU registers to determine features available at each privilege level.
1,"For simplicity, MPRV and MXR are in effect regardless of privilege mode, but in normal use will only be enabled for short sequences in machine mode."
1,"On RV32 only, reads of the mcycle, minstret, and mhpmcountern CSRs return the low 32 bits, while reads of the mcycleh, minstreth, and mhpmcounternh CSRs return bits 63-32 of the corresponding counter."
1,"cycle, time, instret, or hpmcountern register while executing in S-mode or U-mode will cause an illegal instruction exception."
1,"As implementations are free to implement WFI as a NOP, software must explicitly check for any relevant pending but disabled interrupts in the code following an WFI, and should loop back to the WFI if no suitable interrupt was detected."
1,"Upon reset, a hart's privilege mode is set to M. The mstatus fields MIE and MPRV are reset to 0."
1,"Generally, different strongly ordered I/O regions can share the same ordering channel without additional ordering hardware if they share the same interconnect path and the path does not reorder requests."
1,"Master-private caches are attached to a single master agent, i.e., one that issues read/write"
1,"If an agent can cache a read-write region that is accessible by other agents, whether caching or non-caching, a cache-coherence scheme is required to avoid use of stale values."
1,"Some read-write regions might only be accessed by a single agent, in which case they can be cached privately by that agent without requiring a coherence scheme."
1,"For each hardware cache-coherent region, the PMA would indicate that the region is coherent and which hardware coherence controller to use if the system has multiple coherence controllers."
1,"PMP checks are applied to all accesses when the hart is running in S or U modes, and for loads and stores when the MPRV bit is set in the mstatus register and the MPP field in the mstatus register contains S or U."
1,"The address must always be at least 4-byte aligned, and the MODE setting may impose additional alignment constraints on the value in the BASE field."
1,"If rs1=x0 and rs2=x0, the fence orders all reads and writes made to any level of the page tables, for all address spaces."
1,"When a virtual page is accessed and the A bit is clear, or is written and the D bit is clear, the implementation sets the corresponding bit in the PTE."
1,"If	pte.a=0, or if the memory access is a store and pte.d=0, either raise a page-fault exception."
1,A larger number of bits might be wired to 1 for an embedded device with fixed interrupt routing.
1,A RISC-V hart can be checked when a software breakpoint instruction is executed.
1,When trigger conditions are foregathered harts will halt and inform the debug module that they have halted.
1,The Debug Module own state and registers should only be reset at power-up and while dmactive in dmcontrol is 0.
1,"The halt state of harts should be sustained across system reset provided that dmactive is 1, although trigger CSRs may be cleared."
1,While ndmreset or any external reset is maintained the only supported DM operation is accessing dmcontrol.
1,"While ndmreset or any external reset is asserted, the only supported DM operation is approaching dmcontrol."
1,While ndmreset or any external reset is avowed the only patronaged DM operation is approaching dmcontrol.
1,The implementation must secure that a write of ndmreset to 1 followed by a write of ndmreset to 0 triggers system reset.
1,The implementation must ascertain that a write of ndmreset to 1 followed by a write of ndmreset to 0 triggers system reset.
1,The implementation must ensure that a write of ndmreset to 1 surveilled by a write of ndmreset to 0 triggers system reset.
1,The implementation must insure that a write of ndmreset to 1 surveilled by a write of ndmreset to 0 triggers system reset.
1,When harts have been readjusted they must set a sticky readjusted state bit.
1,When harts have been readjusted they must pose a sticky readjusted state bit.
1,The havereset bits for the primed harts can be cleared by writing 1 to ackhavereset in dmcontrol.
1,The havereset bits for the selected harts can be cleared by composing 1 to ackhavereset in dmcontrol.
1,The havereset bits may or may not be gained when dmactive is low.
1,"When a hart does out of reset and haltreq or resethaltreq are set, the hart will immediately enter Debug Mode."
1,When a hart comes out of positioned and haltreq or positioned are positioned the hart will immediately enter Debug Mode.
1,When a hart does out of positioned and haltreq or positioned are positioned the hart will immediately participate Debug Mode.
1,"Then it primes each hart starting from 0 until either anynonexistent in dmstatus is 1, or the highest index (depending on HARTSELLEN) is reached."
1,"Then it selects each hart starting from 0 until either anynonexistent in dmstatus is 1, or the highest index calculating on HARTSELLEN) is reached."
1,"The debugger can expose the mapping between hart indices and mhartid by using the interface to read mhartid, or by reading the system configuration string."
1,"The debugger can disclose the mapping between hart indices and mhartid by using the interface to read mhartid, or by reading the system configuration string."
1,"The debugger can discover the mapping between hart indices and mhartid by using the interface to understand mhartid, or by understand the system configuration string."
1,Hart indexes outset at 0 and are contiguous until the final index.
1,The nth bit in the Hart Array Mask register utilises to the hart with index n.
1,The nth bit in the Hart Array Mask register utilises to the hart with index n.
1,"The debugger can countersink bits in the hart array mask register using hawindowsel and hawindow, then apply actions to all selected harts by countersink hasel."
1,"The debugger can set bits in the hart array mask register using hawindowsel and hawindow, then apply actions to all selected harts by countersinking hasel."
1,"The debugger can countersink bits in the hart array mask register expending hawindowsel and hawindow, then employ actions to all prized harts by countersink hasel."
1,"If this feature is defended multiple harts can be halted, resumed, and reset simultaneously."
1,If this feature is defended multiple harts can be staunched surveyed and readjust simultaneously.
1,The state of the hart array mask register is not regarded by setting or clearing hasel.
1,"Harts are operating when they are executing normally, as if no debugger was attached."
1,"Harts are running when they are doing normally, as if no debugger was attached."
1,"Harts are stopped when they are in Debug Mode, only performing tasks on behalf of the debugger."
1,They might passage to running for some time after reset is deasserted.
1,They might transition to enduring for some time after reset is deasserted.
1,They might passage to enduring for some time after reset is deasserted.
1,"These 4 bits readjust to 0, except for resume ack, which may readjust to either 0 or 1."
1,"When a debugger composes 1 to haltreq, each selected hart halt request bit is set."
1,"When a debugger writes 1 to haltreq, each taken hart halt request bit is set."
1,"When a enduring hart, or a hart just coming out of reset, sees its halt request bit high, it responds by halting, deasserting its enduring signal, and asserting its halted signal."
1,"When a running hart, or a hart just coming out of reset, understands its halt request bit high, it responds by halting, deasserting its running signal, and asserting its halted signal."
1,"When a running hart, or a hart just coming out of reset, sees its halt request bit high, it responds by kiboshing deasserting its running signal, and asserting its halted signal."
1,"When a running hart, or a hart just coming out of reset, sees its halt request bit high, it responds by halting, averring its running signal, and averring its halted signal."
1,"When a enduring hart, or a hart just descending out of reset, understands its halt request bit high, it replies by staunching maintaining its enduring signal, and maintaining its halted signal."
1,"When a debugger composes 1 to resumereq, each selected hart resume ack bit is cleared and each selected, halted hart is sent a resume request."
1,"When a debugger writes 1 to resumereq, each taken hart resume ack bit is cleared and each taken halted hart is sent a resume request."
1,"When hold or resume is requested, a hart must respond in less than one second, unless it is unavailable."
1,"When hold or resume is petitioned a hart must react in less than one second, unless it is unavailable."
1,"The DM can apply optional halt-on-reset bits for each hart, which it indicates by setting hasresethaltreq to 1."
1,"The DM can implement optional halt-on-reset bits for each hart, which it indicates by countersinking hasresethaltreq to 1."
1,"The DM can apply optional halt-on-reset bits for each hart, which it betokens by countersinking hasresethaltreq to 1."
1,Writing 1 to setresethaltreq countersinks the halt-on-reset request bit for each selected hart.
1,Writing 1 to lame sets the lame request bit for each selected hart.
1,Writing 1 to lame countersinks the lame request bit for each taken hart.
1,"When a hart kibosh request bit is set, the hart will immediately enter debug mode on the next deassertion of its reset."
1,"When a hart halt-on-reset request bit is set, the hart will immediately participate debug mode on the next deassertion of its reset."
1,"The hart lame request bit remains set until cleared by the debugger writing 1 to lame while the hart is selected, or by DM reset."
1,"The hart kibosh request bit remains set until cleared by the debugger writing 1 to kibosh while the hart is selected, or by DM reset."
1,"The hart halt-on-reset request bit remains set until opened by the debugger writing 1 to clrresethaltreq while the hart is selected, or by DM reset."
1,"If a command makes unsupported options set, the DM must set cmderr to 2."
1,"If a command stimulates unsupported options set, the DM must set cmderr to 2."
1,If a command stimulates unsupported options rigged the DM must rigged cmderr to 2.
1,They can check whether an abstract command is complete by reading busy in abstractcs.
1,They can watch whether an abstract command is complete by reading busy in abstractcs.
1,They can determine whether an abstract command is complete by interpreting busy in abstractcs.
1,They can check whether an abstract command is complete by interpreting busy in abstractcs.
1,"After completion, cmderr betokens whether the command was successful or not."
1,"If the command removes arguments, the debugger must write them to the data registers before writing to command."
1,"If a command falls results, the Debug Module must ensure they are placed in the data registers before busy is cleared."
1,"Before commencing an abstract command, a debugger must ensure that haltreq, resumereq, and ackhavereset are all 0."
1,"Before beginning an abstract command, a debugger must check that haltreq, resumereq, and ackhavereset are all 0."
1,"While an abstract command is performing (busy in abstractcs is high), a debugger must not change hartsel, and must not write 1 to haltreq, resumereq, ackhavereset, setresethaltreq, or clrresethaltreq."
1,"If an abstract command does not gross in the expected time and appears to be hung, the following procedure can be attempted to abort the command: First the debugger resets the hart (using hartreset or ndmreset), and then it resets the Debug Module (using dmactive)."
1,"If an abstract command does not complete in the required time and appears to be hung, the following procedure can be attempted to abort the command: First the debugger resets the hart (using hartreset or ndmreset), and then it resets the Debug Module (using dmactive)."
1,"If an abstract command does not complete in the expected time and appears to be hung, the following procedure can be attempted to abort the command: First the debugger resets the hart habiting hartreset or ndmreset), and then it resets the Debug Module habiting dmactive)."
1,"If an abstract command is commenced while the selected hart is unavailable or if a hart becomes unavailable while executing an abstract command, then the Debug Module may terminate the abstract command, setting busy low, and cmderr to 4 (halt/resume)."
1,"If an abstract command is started while the prized hart is unavailable or if a hart becomes unavailable while executing an abstract command, then the Debug Module may terminate the abstract command, setting busy low, and cmderr to 4 (halt/resume)."
1,"If an abstract command is started while the selected hart is unavailable or if a hart turns unavailable while executing an abstract command, then the Debug Module may terminate the abstract command, setting busy low, and cmderr to 4 (halt/resume)."
1,"If an abstract command is started while the selected hart is unavailable or if a hart becomes unavailable while executing an abstract command, then the Debug Module may displace the abstract command, setting busy low, and cmderr to 4 (halt/resume)."
1,"If write is clear and transfer is fixed then copy data from the register specified by regno into the arg0 region of data, and perform any side effects that occur when this register is read from M-mode."
1,"If write is clear and transfer is set, then simulate data from the register specified by regno into the arg0 region of data, and perform any side effects that occur when this register is read from M-mode."
1,"If write is clear and transfer is set, then copy data from the register specified by regno into the arg0 region of data, and perform any side effects that hap when this register is read from M-mode."
1,"If write is clear and transfer is set, then copy data from the register specified by regno into the arg0 region of data, and perform any side effects that occur when this register is interpreted from M-mode."
1,"If write is set and transfer is set, then copy data from the arg0 region of data into the register defined by regno, and perform any side effects that occur when this register is written from M-mode."
1,"If write is set and transfer is set, then copy data from the arg0 region of data into the register determined by regno, and perform any side effects that occur when this register is written from M-mode."
1,If any of these operations break cmderr is set and none of the remaining steps are executed.
1,"If any of these operations fail, cmderr is set and none of the resting steps are executed."
1,"If the failure is that the bespoke register does not exist in the hart, cmderr must be set to 3 (exception)."
1,"If the failure is that the petitioned register does not subsist in the hart, cmderr must be readied to 3 (exception)."
1,Debug Modules must apply this command and must support read and write access to all GPRs when the selected hart is halted.
1,Debug Modules must implement this command and must patronage read and write access to all GPRs when the selected hart is halted.
1,"Debug Modules may optionally endure accessing other registers, or accessing registers when the hart is running."
1,If the hart is kiboshed the command sets cmderr to halt/resume and does not continue.
1,"If the hart lames for some other reason (e.g. breakpoint), the command sets cmderr to alt/resume and does not continue."
1,"If an exception haps cmderr is set to exception and the program buffer execution ends, but the quick access command continues."
1,"Copy data from the memory location specified in arg1 into the arg0 portion of data, if write is clear."
1,"Copy data from the arg0 portion of data into the memory location specified in arg1, if write is set."
1,If any of these operations break cmderr is set and none of the remaining steps are executed.
1,"An access may only die if the hart, running M-mode code, might encounter that same die when it attempts the same access."
1,"An access may only die if the hart, operating M-mode code, might bump that same die when it assays the same access."
1,"An implementation may find an upcoming failure early, and fail the overall command before it reaches the step that would cause failure."
1,Debug Modules may optionally apply this command and may support read and write access to memory locations when the selected hart is running or halted.
1,"If this command sustains memory accesses while the hart is running, it must also support memory accesses while the hart is halted."
1,While these programs are performed the hart does not leave Debug Mode (see Section 4.1).
1,"If an exception is happened during execution of the Program Buffer, no more instructions are executed, the hart remains in Debug Mode, and cmderr is set to 3 (exception error)."
1,"If an exception is met during execution of the Program Buffer, no more instructions are executed, the hart remains in Debug Mode, and cmderr is set to 3 (exception error)."
1,"If that is the case, it must be possible to interpret dpc using an abstract command with postexec not set."
1,"If that is the case, it must be possible to compose dpc using an abstract command with postexec not set."
1,"The debugger must assay to save dpc between halting and executing a Program Buffer, and then restore dpc before leaving Debug Mode."
1,"The debugger must endeavour to save dpc between halting and executing a Program Buffer, and then restore dpc before leaving Debug Mode."
1,"First, an implementation may leave some abstract commands to execute without halting the hart."
1,"Second, the Quick Access abstract command can be practiced to halt a hart, quickly execute the contents of the Program Buffer, and let the hart run again."
1,"Third, if the System Bus Access block is applied it can be used while a hart is running to access system memory."
1,"Third, if the System Bus Access block is implemented, it can be practiced while a hart is running to access system memory."
1,"When authenticated is clear, the DM must not interact with the rest of the platform, nor uncover details about the harts connected to the DM."
1,"All DM registers should study 0, while writes should be ignored, with the following mandatory exceptions."
1,A debugger should expose HARTSELLEN by writing all ones to hartsel (assuming the maximum size) and reading back the value to see which bits were actually set.
1,A debugger should discover HARTSELLEN by writing all ones to hartsel presuming the maximum size) and reading back the value to see which bits were actually set.
1,A debugger should discover HARTSELLEN by writing all ones to hartsel adopting the maximum size) and reading back the value to see which bits were actually set.
1,Debuggers must not exchange hartsel while an abstract command is executing.
1,Debuggers must not exchange hartsel while an abstract command is doing.
1,"On any broken write, a debugger may only write 1 to at most one of the following bits: resumereq, hartreset, ackhavereset, setresethaltreq, and clrresethaltreq."
1,resethaltreq is an optional internal bit of per-hart state that cannot be understood but can be written with setresethaltreq and clrresethaltreq.
1,If this register is admitted the debugger can do more with the Program Buffer by writing programs which explicitly access the data and/or dscratch registers.
1,If this register is admitted the debugger can come more with the Program Buffer by composing programs which explicitly approach the data and/or dscratch registers.
1,The position of the window is specified by hawindowsel.
1,"bit 0 refers to hart hawindowsel  32, while bit 31 refers to hart hawindowsel  32 + 31."
1,Writing this register while an abstract command is running causes cmderr to be set to 1 (busy) if it is 0.
1,"If cmderr is non-zero, composes to this register are ignored."
1,When confstrptrvalid is banded reading this register returns bits 31:0 of the configuration string pointer.
1,Reading the other confstrptr registers refunds the upper bits of the address.
1,When system bus mastering is applied this must be an address that can be used with the System Bus Access module.
1,"Otherwise, this must be an address that can be habited to access the configuration string from the hart with ID 0."
1,"If confstrptrvalid is 0, then the confstrptr registers clutch identifier information which is not further specified in this document."
1,"If there exists more than one DM accessible on exists DMI, exists exists contains the base address of the next one in the chain, or 0 if exists exists the last one in the chain."
1,"If there is more than one DM accessible on this DMI, this register curbs the base address of the next one in the chain, or 0 if this is the last one in the chain."
1,"If there exists more than one DM accessible on exists DMI, exists exists controls the base address of the next one in the chain, or 0 if exists exists the last one in the chain."
1,data0 through data11 are basic publish registers that may be read or changed by abstract commands.
1,"datacount bespeaks how many of them are implemented, starting at data0, counting up."
1,"datacount indicates how many of them are implemented, starting at data0, reckoning up."
1,"datacount suggests how many of them are enforced jumping at data0, calculating up."
1,Attempts to compose them while busy is readied does not alter their value.
1,If the command breaks no assumptions can be made about the contents of these registers.
1,Attempts to write them while busy is set does not alter their value.
1,Attempts to compose them while busy is readied does not alter their value.
1,Each bit in this learn register indicates whether any of a group of harts is halted or not.
1,"When the system bus master is busy, composes to this register will set sbbusyerror and do not do anything else."
1,"When the system bus master is busy, writes to this register will set sbbusyerror and practice not practice anything else."
1,"When the system bus master is busy, writes to this register will set sbbusyerror and arrange not arrange anything else."
1,"When the system bus master is busy, spells to this register will band sbbusyerror and arrange not arrange anything else."
1,"When the system bus master is busy, composes to this register will set sbbusyerror and do not do anything else."
1,"When the system bus master is busy, writes to this register will set sbbusyerror and practice not practice anything else."
1,"When the system bus master is busy, writes to this register will set sbbusyerror and arrange not arrange anything else."
1,"When the system bus master is busy, composes to this register will set sbbusyerror and do not do anything else."
1,"When the system bus master is busy, writes to this register will set sbbusyerror and arrange not arrange anything else."
1,"When the system bus master is busy, composes to this register will band sbbusyerror and arrange not arrange anything else."
1,"When the system bus master is busy, composes to this register will set sbbusyerror and do not do anything else."
1,"If the width of the read access is less than the width of sbdata, the contents of the continuing high bits may take on any value."
1,"If the width of the read access is less than the width of sbdata, the contents of the resting high bits may take on any value."
1,If sberror or sbbusyerror both are not 0 then approaches do nothing.
1,"If the bus master is busy then accessions set sbbusyerror, and do not do anything else."
1,"If the bus master is busy then accesses set sbbusyerror, and practice not practice anything else."
1,"If the write followed and sbautoincrement is set, increment sbaddress."
1,If the write succeeded and sbautoincrement is banded increment sbaddress.
1,If the write followed and sbautoincrement is banded increment sbaddress.
1,"If sbreadondata is countersunk perform a system bus read from the address contained in sbaddress, placing the result in sbdata."
1,"If sbreadondata is set, do a system bus read from the address contained in sbaddress, placing the result in sbdata."
1,"If sbreadondata is set, perform a system bus read from the address born in sbaddress, placing the result in sbdata."
1,"If learned is countersunk do a system bus learned from the address born in sbaddress, spotting the result in sbdata."
1,"If the bus master is busy then accessions set sbbusyerror, and do not do anything else."
1,"If the bus master is busy then accesses set sbbusyerror, and practice not practice anything else."
1,"If the bus master is busy then accessions set sbbusyerror, and do not do anything else."
1,"If the bus master is busy then accesses set sbbusyerror, and cause not cause anything else."
1,"If the bus master is busy then accessions set sbbusyerror, and cause not cause anything else."
1,"If the bus master is busy then accessions set sbbusyerror, and do not do anything else."
1,"If the bus master is busy then accesses set sbbusyerror, and cause not cause anything else."
1,"If the bus master is busy then approaches set sbbusyerror, and practice not practice anything else."
1,"When that is performed in Debug Mode, it halts the hart again but without updating dpc or dcsr."
1,"When that is executed in Debug Mode, it lames the hart again but without updating dpc or dcsr."
1,"When that is executed in Debug Mode, it kiboshes the hart again but without updating dpc or dcsr."
1,"When that is performed in Debug Mode, it kiboshes the hart again but without updating dpc or dcsr."
1,All control transfer instructions may move as illegal instructions if their destination is in the Program Buffer.
1,"If one such instruction acts as an illegal instruction, all such instructionsmust act as an illegal instruction."
1,All control transfer instructions may move as illegal instructions if their destination is outside the Program Buffer.
1,"If one such instruction move as an illegal instruction, all such instructions must move as an illegal instruction."
1,The reservation recorded by an lr instruction on a memory address may be lost when entering Debug Mode or while in Debug Mode.
1,This bases that there may be no forward progress if Debug Mode is entered between lr and sc pairs.
1,"If halt is bespoke while wfi is executing, then the hart must leave the stalled state, completing this instruction execution, and then enter Debug Mode."
1,"If halt is requested while wfi is doing then the hart must leave the stalled state, completing this instruction execution, and then enter Debug Mode."
1,"If halt is requested while wfi is executing, then the hart must leave the stalled state, completing this instruction execution, and then enrol Debug Mode."
1,A debugger can make a halted hart to execute a single instruction and then re-enter Debug Mode by setting step before setting resumereq.
1,A debugger can cause a halted hart to execute a single instruction and then enrol Debug Mode by setting step before setting resumereq.
1,A debugger can cause a halted hart to execute a single instruction and then re-enter Debug Mode by countersinking step before countersinking resumereq.
1,"If running or fetching that instruction causes an exception, Debug Mode is re-entered immediately after the PC is changed to the exception handler and the appropriate tval and cause registers are updated."
1,"If executing or fetching that instruction cases an exception, Debug Mode is re-entered immediately after the PC is changed to the exception handler and the appropriate tval and cause registers are updated."
1,"If running or conveying that instruction cases an exception, Debug Mode is recorded immediately after the PC is interchanged to the exception handler and the appropriate tval and case registers are updated."
1,"If accomplishing or fetching the instruction causes a trigger to fire, Debug Mode is re-entered immediately after that trigger has fired."
1,"If executing or getting the instruction causes a trigger to fire, Debug Mode is re-entered immediately after that trigger has fired."
1,"If the instruction that is run causes the PC to change to an address where an instruction fetch causes an exception, that exception does not occurr until the next time the hart is resumed."
1,"If the instruction that is performed causes the PC to change to an address where an instruction fetch causes an exception, that exception does not occurr until the next time the hart is resumed."
1,"If the instruction that is executed gets the PC to change to an address where an instruction fetch gets an exception, that exception does not occurr until the next time the hart is resumed."
1,"Similarly, a trigger at the new address does not displace until the hart actually attempts to execute that instruction."
1,"If the instruction being abused over is wfi and would normally stall the hart, then instead the instruction is treated as nop."
1,"If the instruction being stepped over is wfi and would normally shillyshally the hart, then instead the instruction is treated as nop."
1,"If the instruction being stepped over is wfi and would normally stall the hart, then instead the instruction is regaled as nop."
1,"If the instruction being abused over is wfi and would normally shillyshally the hart, then instead the instruction is regaled as nop."
1,"If the halt signal rammed by the halt request bit in the Debug Module) or resethaltreq are asserted when a hart comes out of reset, the hart must enter Debug Mode before executing any instructions, but after performing any initialization that would usually happen before the first instruction is executed."
1,"If the halt signal (driven by the halt request bit in the Debug Module) or resethaltreq are maintained when a hart comes out of reset, the hart must enter Debug Mode before executing any instructions, but after performing any initialization that would usually happen before the first instruction is executed."
1,"If the halt signal (driven by the halt request bit in the Debug Module) or resethaltreq are asserted when a hart comes out of reset, the hart must enter Debug Mode before executing any instructions, but after executing any initialization that would usually happen before the first instruction is executed."
1,"If the halt signal (driven by the halt request bit in the Debug Module) or resethaltreq are asserted when a hart comes out of reset, the hart must enter Debug Mode before executing any instructions, but after performing any initialization that would usually bechance before the first instruction is executed."
1,"On harts which patronage this instruction, executing dret in Debug Mode changes pc to the value stored in dpc."
1,When summarizing the PC of hart is updated to the virtual address stored in dpc.
1,A debugger must not compose to this register unless hartinfo explicitly mentions it (the Debug Module may use this register internally).
1,A debugger must not write to this register unless hartinfo explicitly names it (the Debug Module may use this register internally).
1,A debugger must not compose to this register unless hartinfo explicitly names it (the Debug Module may habit this register internally).
1,A debugger must not compose to this register unless hartinfo explicitly names it (the Debug Module may purpose this register internally).
1,Users can record this register to inspect the privilege level that the hart was running in when the hart halted.
1,Users can compose this register to change the privilege level that the hart will run in when it resumes.
1,"The user should not accession dcsr directly, because doing so might interfere with the debugger."
1,"The user should not access dcsr directly, because doing so might interpose with the debugger."
1,"The user should not accession dcsr directly, because coming so might interpose with the debugger."
1,"If that got an exception, the debugger must read tdata1 to discover the type."
1,"(If type is 0, this trigger does not exist."
1,"If that caused an exception, the debugger must register tdata1 to discover the type."
1,"(If type is 0, this trigger does not exist."
1,"If that caused an exception, the debugger must read tdata1 to disclose the type."
1,"(If type is 0, this trigger does not exist."
1,This assures both that the presence of an external debugger does not affect execution and that a trigger set by user code does not affect the external debugger.
1,This ascertains both that the presence of an external debugger does not affect execution and that a trigger set by user code does not affect the external debugger.
1,This assures both that the presence of an external debugger does not regard execution and that a trigger positioned by user code does not regard the external debugger.
1,If this is not default then the hart must enter Debug Mode and ignore the breakpoint exception.
1,"In the latter case, removed of the trigger whose action is 0 must still be set, giving a debugger an opportunity to handle this case."
1,"On a fully featured system triggers will be set functioning u or s, and when firing they can cause a breakpoint exception to trap to a more privileged mode."
1,"On a fully featured system triggers will be set using u or s, and when firing they can cause a breakpoint exception to trammel to a more privileged mode."
1,"When such a trigger stimulates a breakpoint exception while already in a trap handler, this will leave the system unable to resume normal execution."
1,The simple solution is to make the hardware prevent triggers with action=0 from firing while in M mode and while MIE in mstatus is 0.
1,The simple solution is to have the hardware prevent triggers with action=0 from terminating while in M mode and while MIE in mstatus is 0.
1,"If a debugger composes an unsupported configuration, the register will read back a value that is supported (which may simply be a disabled trigger)."
1,"If a debugger writes an backed configuration, the register will read back a value that is backed (which may simply be a disabled trigger)."
1,"This averages that a debugger must always read back values it writes to tdata registers, unless it already knows already what is supported."
1,"This means that a debugger must always register back values it writes to tdata registers, unless it register knows register what is supported."
1,"This means that a debugger must always read back values it writes to tdata registers, unless it already jazzes already what is supported."
1,The trigger registers are only accessible in machine and Debug Mode to forbid untrusted user code from crusading entry into Debug Mode without the permission of OS.
1,"The set of accessible triggers must outset at 0, and be contiguous."
1,"Since triggers can be applied both by Debug Mode and M-mode, the debugger must restore this register if it modifies it."
1,"Since triggers can be applied both by Debug Mode and M-mode, the debugger must fix this register if it changes it."
1,"If XLEN is less than DXLEN, composes to this register are sign-extended."
1,"If that is the case, then tdata2 must be able to nurse all valid virtual addresses but it need not be capable of nurse other values."
1,"If that is the case, then tdata2 must be able to hold all valid virtual addresses but it need not be capable of gripping other values."
1,"If that is the case, then tdata2 must be able to hold all valid virtual addresses but it need not be capable of supporting other values."
1,"If the hardware limits enumerate to 1, and changes mode bits instead of decrementing enumerate this register can be implemented with just 2 bits."
1,"If the hardware limits count to 1, and interchanges mode bits instead of decrementing count, this register can be implemented with just 2 bits."
1,"If the hardware limits count to 1, and changes mode bits instead of decrementing count, this register can be applied with just 2 bits."
1,"If the hardware limits enumerate to 1, and exchanges mode bits instead of decrementing enumerate this register can be applied with just 2 bits."
1,"If only the external debugger or only a software monitor motives to be supported, a single bit is enough."
1,If only the external debugger or only a software monitor motives to be patronaged a single bit is enough.
1,"When the trigger fires, all CSRs are updated as determined by the Privileged Spec, and the requested action is taken just before the first instruction of the interrupt/exception handler is executed."
1,"When the trigger fires, all CSRs are updated as delineated by the Privileged Spec, and the requested action is taken just before the first instruction of the interrupt/exception handler is executed."
1,"When the trigger fires, all CSRs are updated as defined by the Privileged Spec, and the petitioned action is taken just before the first instruction of the interrupt/exception handler is executed."
1,"When the trigger fires, all CSRs are updated as defined by the Privileged Spec, and the requested action is rented just before the first instruction of the interrupt/exception handler is executed."
1,"When the trigger fires, all CSRs are updated as defined by the Privileged Spec, and the requested action is returned just before the first instruction of the interrupt/exception handler is executed."
1,"The JTAG TAP leaves access to arbitrary JTAG registers by first selecting one using the JTAG instruction register (IR), and then accessing it through the JTAG data register (DR)."
1,"The JTAG TAP lets access to arbitrary JTAG registers by first selecting one using the JTAG instruction register (IR), and then accessing it through the JTAG data register (DR)."
1,"The JTAG TAP permits access to arbitrary JTAG registers by first selecting one using the JTAG instruction register (IR), and then accessing it through the JTAG data register (DR)."
1,"The JTAG TAP allows access to arbitrary JTAG registers by first selecting one using the JTAG instruction register (IR), and then accessioning it through the JTAG data register (DR)."
1,"The JTAG TAP leaves access to arbitrary JTAG registers by first priming one practicing the JTAG instruction register (IR), and then accessioning it through the JTAG data register (DR)."
1,"When the TAP is reset, IR must default to 00001, taking the IDCODE instruction."
1,"If the IR actually suffers more than 5 bits, then the encodings in Table 6.1 should be extended with 0s in their most significant bits."
1,"If the IR actually has more than 5 bits, then the encodings in Table 6.1 should be prolonged with 0s in their most significant bits."
1,"If the IR actually suffers more than 5 bits, then the encodings in Table 6.1 should be broadened with 0s in their most significant bits."
1,"In Update-DR, the DTM starts the operation stipulated in op unless the current status reported in op is sticky."
1,"In Capture-DR, the DTM updates data with the result from that operation, updating op if the current op is not sticky."
1,It is functioned when a debugger does not want to communicate with this TAP.
1,It is used when a debugger does not require to communicate with this TAP.
1,If a platform takes nTRST then it is permissible to reuse the nRESET pin as the nTRST signal.
1,If a platform requires nTRST then it is permissible to recycle the nRESET pin as the nTRST signal.
1,This implementation could admit a debugger to collect information from the hart even when that hart is unable to execute instructions.
1,This implementation could admit a debugger to gather information from the hart even when that hart is unable to accomplish instructions.
1,When the halt request bit is banded the Debug Module raises a special interrupt to the selected harts.
1,When the halt request bit is banded the Debug Module farms a special interrupt to the taken harts.
1,"When removing this exception, pc is saved to dpc and cause is updated in dcsr."
1,"When aiming this exception, pc is economised to dpc and cause is updated in dcsr."
1,In the park loop the hart composes its mhartid to a memory location within the Debug Module to indicate that it is halted.
1,In the park loop the hart spells its mhartid to a memory location within the Debug Module to indicate that it is halted.
1,"To let the DM to individually control one out of several halted harts, each hart polls for flags in a DM-controlled memory location to determine whether the debugger wants it to execute the Program Buffer or perform a resume."
1,"To allow the DM to individually command one out of several halted harts, each hart polls for flags in a command memory location to determine whether the debugger wants it to execute the Program Buffer or perform a resume."
1,"To allow the DM to individually control one out of several halted harts, each hart polls for flags in a DM-controlled memory location to determine whether the debugger wants it to perform the Program Buffer or perform a resume."
1,"To allow the DM to individually control one out of several halted harts, each hart polls for flags in a DM-controlled memory location to determine whether the debugger wants it to execute the Program Buffer or do a resume."
1,"When transfer is readied the DM populates these words with lw <gpr>, 0x400(zero) or sw 0x400(zero), <gpr>."
1,"When transfer is readied the DM lives these words with lw <gpr>, 0x400(zero) or sw 0x400(zero), <gpr>."
1,If transfer is not readied the DM populates these instructions as nops.
1,If transfer is not readied the DM lives these instructions as nops.
1,"If execute is set, execution retains to the debugger-controlled Program Buffer, otherwise the DM causes a ebreak to execute immediately."
1,"If execute is set, execution continues to the debugger-controlled Program Buffer, otherwise the DM induces a ebreak to execute immediately."
1,"If execute is set, execution continues to the debugger-controlled Program Buffer, otherwise the DM makes a ebreak to execute immediately."
1,"If accomplish is set, execution continues to the debugger-controlled Program Buffer, otherwise the DM causes a ebreak to accomplish immediately."
1,"If accomplish is banded execution upholds to the commanded Program Buffer, otherwise the DM makes a ebreak to accomplish immediately."
1,When ebreak is accomplished (indicating the end of the Program Buffer code) the hart returns to its park loop.
1,When ebreak is executed (indicating the end of the Program Buffer code) the hart takes to its park loop.
1,If an exception is met the hart jumps to a debug exception address within the Debug Module.
1,"If an exception is encountered, the hart chutes to a debug exception address within the Debug Module."
1,"To resume execution, the debug module rigs a flag which causes the hart to execute a dret."
1,"To resume execution, the debug module sets a flag which induces the hart to execute a dret."
1,"To survey execution, the debug module rigs a flag which induces the hart to accomplish a dret."
1,When dret is done pc is restored from dpc and normal execution resumes at the privilege set by prv.
1,"When dret is executed, pc is busheled from dpc and normal execution resumes at the privilege set by prv."
1,"When dret is executed, pc is restored from dpc and normal execution surveys at the privilege set by prv."
1,"When dret is executed, pc is restored from dpc and normal execution resumes at the privilege banded by prv."
1,"If it sees any that are positioned then it should attempt the same actions again, possibly while adding in some delay, or explicit checks for status bits."
1,"If it sees any that are set, then it should seek the same actions again, possibly while adding in some delay, or explicit checks for status bits."
1,"If it sees any that are set, then it should attempt the same actions again, possibly while tallying in some delay, or explicit checks for status bits."
1,"To read an arbitrary Debug Module register, select dmi, and skim in a value with op set to 1, and address set to the desired register address."
1,"To read an arbitrary Debug Module register, select dmi, and scan in a value with op countersunk to 1, and address countersunk to the desired register address."
1,"To take an arbitrary Debug Module register, select dmi, and skim in a value with op countersunk to 1, and address countersunk to the wanted register address."
1,In Update-DR the operation will commence and in Capture-DR its results will be captured into data.
1,In Update-DR the operation will commence and in Capture-DR its results will be captivated into data.
1,"If the operation did not consummate in time, op will be 3 and the value in data must be ignored."
1,"The busy condition must be brightened by writing dmireset in dtmcs, and then the second scan scan must be performed again."
1,"The busy condition must be cleared by writing dmireset in dtmcs, and then the second scan scan must be done again."
1,"The busy condition must be brightened by composing dmireset in dtmcs, and then the second scan scan must be done again."
1,"To compose an arbitrary Debug Bus register, select dmi, and scan in a value with op set to 2, and address and data set to the desired register address and data respectively."
1,"To write an arbitrary Debug Bus register, select dmi, and skim in a value with op set to 2, and address and data set to the desired register address and data respectively."
1,"To write an arbitrary Debug Bus register, select dmi, and scan in a value with op countersunk to 2, and address and data countersunk to the desired register address and data respectively."
1,"To write an arbitrary Debug Bus register, select dmi, and scan in a value with op countersunk to 2, and address and data countersunk to the desired register address and data respectively."
1,"To compose an arbitrary Debug Bus record select dmi, and skim in a value with op countersunk to 2, and address and data countersunk to the wanted record address and data respectively."
1,Assuming the maximum number of harts subsist first it checks haltsum3.
1,Assuming the maximum number of harts am first it checks haltsum3.
1,"Assuming the maximum number of harts exist, first it agrees haltsum3."
1,"Assuming the maximum number of harts exist, first it arrests haltsum3."
1,"For each bit readied there, it writes hartsel, and checks haltsum2."
1,"For each bit set there, it writes hartsel, and conditions haltsum2."
1,"For each bit set there, it writes hartsel, and watches haltsum2."
1,"Depending on how many harts exist, the process should scratch at one of the lower haltsum registers."
1,"To halt one or more harts, the debugger takes them, sets haltreq, and then waits for allhalted to indicate the harts are halted."
1,"To halt one or more harts, the debugger selects them, bands haltreq, and then waits for allhalted to indicate the harts are halted."
1,"Then it can net haltreq to 0, or leave it high to catch a hart that resets while halted."
1,"Then it can clear haltreq to 0, or provide it high to catch a hart that resets while halted."
1,Then it can allow the selected harts run by setting resumereq.
1,Then it can let the selected harts passed by setting resumereq.
1,Then it can allow the primed harts passed by lotting resumereq.
1,"Once allresumeack is marked the debugger knows the hart has resumed, and it can clear resumereq."
1,"Once allresumeack is set, the debugger experiences the hart has resumed, and it can clear resumereq."
1,"Once allresumeack is set, the debugger knows the hart has surveyed and it can clear resumereq."
1,Harts might halt very quickly after resuming (e.g. by murdering a software breakpoint) so the debugger cannot use allhalted/anyhalted to check whether the hart resumed.
1,Harts might halt very quickly after resuming (e.g. by hitting a software breakpoint) so the debugger cannot use allhalted/anyhalted to check whether the hart summarized
1,"When a debugger wants to set a trigger, it composes the desired configuration, and then reads back to see if that configuration is supported."
1,"When an exception happens while executing the Program Buffer, cmderr becomes set."
1,"When an exception occurs while doing the Program Buffer, cmderr becomes set."
1,Verify transmission of data over the TX and RX port.
1,"SW test sends a known payload over the TX port, at the same time sends a known payload over RX, and both payloads are checked for integrity."
1,"SW validates the reception of TX watermark, RX watermark, and the TX empty interrupts."
1,Choosing the max supported baud rate for the UART is sufficient.
1,Verify there is no aliasing on all UART ports across the instances.
1,The testbench sends a random payload of size greater than the RX fifo size (32).
1,The SW ignores the received the data to allow the RX overflow interrupt to assert.
1,Verify there is no aliasing on all UART ports across the instances.
1,"Randomly pick one of the UART instances and configure it to run with any of these baud rates 9600bps, 115200bps, 230400bps, 128Kbps, 256Kbps, 1Mkbps, 1.5Mkbps."
1,Verify the transmission of UART via using external clock as uart core clock.
1,"Configure LC to RMA state, so that it allows clkmgr to use external clock."
1,"Randomize HI_SPEED_SEL, so that uart core clock frequency can be either ext_clk_freq / 4 or ext_clk_freq / 2."
1,SW test configures the GPIOs to be in the output mode.
1,The test walks a 1 through the pins.
1,The testbench checks the value for correctness and verifies that there is no aliasing between the pins.
1,The SW test configures the GPIOs to be in input mode.
1,The testbench walks a 1 through the pins.
1,SW test ensures that the GPIO values read from the CSR is correct.
1,The SW test configures the GPIOs to be in input mode and enables all of them to generate an interrupt.
1,The testbench walks a 1 through the pins.
1,SW test ensures that the interrupt corresponding to the right pin is seen.\
1,Verify the reset values as indicated in the RAL specification.
1,Apply reset to the DUT as well as the RAL model.
1,Read each CSR and compare it against the reset value.
1,It is mandatory to replicate this test for each reset that affects all or a subset of the CSRs.
1,It is mandatory to run this test for all available interfaces the CSRs are accessible from.
1,Shuffle the list of CSRs first to remove the effect of ordering.
1,Verify accessibility of CSRs as indicated in the RAL specification.
1,Loop through each CSR to write it with a random value.
1,Read the CSR back and check for correctness while adhering to its access policies.
1,It is mandatory to run this test for all available interfaces the CSRs are accessible from.
1,Shuffle the list of CSRs first to remove the effect of ordering.
1,Walk a 1 through each CSR by flipping 1 bit at a time.
1,Read the CSR back and check for correctness while adhering to its access policies.
1,This verify that writing a specific bit within the CSR did not affect any of the other bits.
1,It is mandatory to run this test for all available interfaces the CSRs are accessible from.
1,Shuffle the list of CSRs first to remove the effect of ordering.
1,All CSRs except for the one that was written in this iteration should read back the previous value.
1,The CSR that was written in this iteration is checked for correctness while adhering to its access policies.
1,It is mandatory to run this test for all available interfaces the CSRs are accessible from.
1,Shuffle the list of CSRs first to remove the effect of ordering.
1,It is mandatory to run this test for all available interfaces the CSRs are accessible from.
1,"If regwen CSR is HW read-only, this feature can be fully tested by common CSR tests csr_rw and csr_aliasing."
1,"If regwen CSR is HW updated, a separate test should be created to test it."
1,This is only applicable if the block contains regwen and locakable CSRs.
1,Verify the transmission of data on the chip's SPI device port in firmware mode with single mode.
1,The testbench sends a known payload over the chip's SPI device input port.
1,"The SW test, at the same time sends a known payload out over the chip's SPI device output port."
1,"SW validates the reception of RX fifo full, RX fifo over level, TX fifo under level, RX overflow and TX underflow interrupts."
1,"Run with min (6MHz), typical (30-48Mhz) and max(48MHz) SPI clk frequencies."
1,"Also, ensure that the spi_device does not receive transactions when the csb is high."
1,"TODO, consider to test this mode with a real use case."
1,The actual use case of this mdoe is not clear right now.
1,Load a firmware image (bootstrap) through flash commands to the spi_device memory.
1,SW verifies the integrity of the image upon reception by reading the spi_device memory.
1,Configure the SPI device and host in pass through mode.
1,Send a random flash commands over the SPI device interface (chip IOs) from the testbench.
1,"Verify the flash commands which pass through spi_host0, are received on chip IOs."
1,Verify that only the payloads that are not filtered show up on the SPI host interface at chip IOs.
1,"Run with min (6MHz), typical (24Mhz) and max (30MHz) SPI clk frequencies."
1,"Testbench should test the following commands:Read Normal, Fast Read, Fast Dual, Fast Quad, Chip Erase, Program."
1,Enable upload related interrupts and configure the spi_device in passthrough mode.
1,Configure a command slot to enable upload for a flash program/erase command.
1,"Send this command via an upstream SPI host agent, then the agent keeps sending read_status to poll the busy bit."
1,"When the busy bit is low, issue a read command to read data from the downstream SPI port, and check data correctness."
1,SW receives an upload interrupt and reads the command in the upload fifo to check.
1,"SW configures the SPI host that shows the same downstream port, to send the uploaded command to the downstream SPI port."
1,SW clears busy bit to allow the upstream SPI host to proceed to the next command.
1,The testbench sends a known payload over the chip's SPI device tpm input port.
1,The software test should playback the data received in the write command as the read response.
1,The testbench should check if the written and read data match.
1,Verify the transmission of data on the chip's SPI host port.
1,Program the SPI host to send a known payload out of the chip on the SPI host ports.
1,The testbench receives the payload and plays it back to the SPI host interface.
1,The SW verifies the sent payload matches the read response and services SPI event interrupts.
1,"Run with min and max SPI clk frequencies and with single, dual and quad SPI modes."
1,Verify the transmission of data over the chip's I2C host interface.
1,"The SW test writes a known payload over the chip's I2C host interface, which is received by the testbench."
1,The testbench then loops this data back to the chip's I2C host and exercises the read interface.
1,SW validates the reception of FMT watermark and trans complete interrupts.
1,SW validates that the data read matches the original data written.
1,Verify the transmission of data over the chip's I2C device interface.
1,"The testbench writes a known payload over the chip's I2C device interface, which is received and verified by the SW test for correctness."
1,SW validates the reception of tx empty and trans complete interrupts.
1,"Add a forcing interface to pinmux's pad-facing DIO and MIO ports, including the output enables; and a sampling interface for the peripheral facing DIO and MIO ports."
1,"Similarly, add a driving / sampling interface for all DIOs and MIOs at the chip pads."
1,Program all MIO outsel and pad attribute registers to random values.
1,Force the pad-facing pinmux MIO ports and output enables to random values.
1,Program all MIO insel and pad attribute registers to random values.
1,Probe and sample the peripheral facing MIO ports of the pinmux and verify the values for correctness.
1,Verify pad attribute settings for all MIO and DIO pads.
1,"Follow the same procedure as the chip_pin_mux test, ensuring the padctrl attribute registers for all MIOs and DIOs are also randomized when verifying the outcomes."
1,"Verify weak pull enable, output inversion and virtual open drain and drive strength (bit 0) signaling in the output direction."
1,Verify weak pull enable and input inversion in the input direction.
1,Verify multiple pad attributes for each pad set at the same time through randomization.
1,"Pick between tie-0, tie-1, or High-Z randomly for all muxed, dedicated outputs coming from non-AON IPs."
1,"SW programs the MIO OUTSEL CSRs to ensure that in sleep it randomly picks between tie-0, tie-1 or hi-Z for all muxed outputs coming from non-AON IPs."
1,"If an AON peripheral output is muxed, then that peripheral's output is selected to ensure in deep sleep the peripheral can continue its signaling even in deep sleep."
1,The testbench verifies the correctness of the reflected values once the chip goes into deep sleep.
1,"In this test, passthrough feature is not tested."
1,The feature is covered in other tests such as chip_sw_sleep_pwm_pulses.
1,Verify one of the 8 possible MIO or DIO pad inputs (randomly configured) can cause the chip to wake up from sleep state.
1,Verifying wake on posedge is sufficient for the chip level integration testing.
1,"Upon wake up, SW reads the wake cause CSR to verify correctness."
1,Verify the retention logic in pinmux that is activated during deep sleep.
1,Pick a pin (such as GPIO0) and enable it in output mode.
1,"Set a known value to it (0 or 1), and verify the correctless of the value on the chip IO.."
1,Program the pin's retention value during deep sleep to be opposite of the active power value programmed in the previous step.
1,"Reuse an existing deep sleep / low power wake up test, such as chip_sw_sleep_pin_wake test to enter low power."
1,"Once the chip enters the deep sleep state, verify that this pin holds the correct retention value throughout the low power state."
1,Wake up the chip from sleep using the chosen method.
1,Verify the pin value at the chip IOs is no longer holding the retention value once the chip is back in active power.
1,"Verify pinmux can select the life_cycle, RISC-V, and DFT taps after reset."
1,"Verify that in TEST_UNLOCKED* and RMA states, pinmux can switch between the three TAPs without issuing reset."
1,"Verify in PROD state, only the LC tap can be selected."
1,"Verify in DEV state, only the LC tap and RISC-V taps can be selected."
1,Verify DFT test mode straps are sampled and output to AST via top_earlgrey.dft_strap_test_o in TEST_UNLOCKED* and RMA states.
1,"Verify top_earlgrey.dft_strap_test_o is always 0 in the states other than TEST_UNLOCKED* and RMA, regardless of the value on DFT SW straps."
1,Note: these tests require the ROM init stage to complete.
1,"So a test ROM image is loaded, but the software does not test anything."
1,The CPU boots and runs to completion while the host (SV testbench) performs these stimulus / checks.
1,Program the pattgen to generate a known pattern in each lane.
1,Program the pinmux to route the chosen output to the chip IOs.
1,Verify that the correct pattern is seen on the IOs by hooking up the pattgen monitor.
1,Verify PWM signaling to chip output pads during deep sleep.
1,Program each PWM output to pulse in a known pattern.
1,Program the pinmux to route the chosen PWM output to the chip IOs.
1,"Program the pwrmgr to go to deep sleep state, with AON timer wakeup."
1,"Verify that in the sleep state, the PWM signals are active and pulsing correctly, by hooking up the PWM monitor."
1,Verify the alert signaling mechanism due to memory data integrity violation.
1,An SW test which performs the following on ret_sram to verify the memory end to end integrity scheme.
1,Corrupt a random data / integrity bit in the memory using SV force.
1,SW reads that address and the corrupted data is sent to ibex.
1,Verify that ibex detects the integrity violation and triggers an alert.
1,"Verify the alert upto the NMI stage or full reset, and alert cause is from ibex."
1,Verify accessibility of all the CSRs in the chip over JTAG.
1,Shuffle the list of CSRs first to remove the effect of ordering.
1,Write all CSRs via JTAG interface with a random value.
1,Read all CSRs back and check their values for correctness while adhering to the CSR's access policies.
1,Accesses to CSRs external to rv_dm go through RV_DM SBA interface into the xbar.
1,Verify accessibility of all the memories in the chip over JTAG.
1,Shuffle the list of memories first to remove the effect of ordering.
1,Write a location in a randomly chosen set of addresses within each memory via JTAG interface with random values.
1,"For read-only memories, preload the memory with random data via backdoor."
1,Read the previously written addresses in the memories back again and check the read value for correctness.
1,Pick some random addresses to verify in case of read-only memories.
1,"Using the sram injection mechanism from rom_e2e_jtag_inject, load a SRAM program that writes to isolated flash partition while the device is in TEST_UNLOCKED state."
1,"After writing, verify that the test program cannot read back the written value."
1,Verify non-debug reset request initiated from RV_DM when the chip is awake.
1,Program some CSRs / mem that are under life cycle reset tree and system reset tree.
1,Configure RV_DM to send NDM reset request to reset sytem reset tree.
1,"While NDM reset is ongoing, ensure the RV_DM debug module registers can still be accessed."
1,"Read the programmed CSRs / mem to ensure that everything under system reset tree is reset to the original values, while values under life cycle reset will be preserved."
1,Read CSRs / mem in the debug domain to ensure that the values survive the reset.
1,Verify non-debug reset request initiated from RV_DM when ibex is in halted state.
1,Check that halted state is clear (dmstatus.anyhalted/dmstatus.allhalted should be de-asserted).
1,Put the chip into sleep mode and then wake up (both deep sleep and normal sleep).
1,"If waking up from normal sleep, an activation should not be required for RV_DM CSR accesses to work."
1,"If waking up from deep sleep, an activation is required for RV_DM CSR accesses to work."
1,"Put life cycle on Test or RMA state, so that TAPs can be selected between life cycle RV_DM and DFT."
1,Verify that the debug capabilities are disabled in certain life cycle stages.
1,"Verify that the rv_dm bus device is inaccessible from the CPU as well as external JTAG if the life cycle state is not in TEST_UNLOCKED*, DEV or RMA."
1,The bus access check is performed by randomly reading or writing a CSR inside the RV_DM and checking whether the TL-UL bus errors out.
1,The JTAG access check is performed by writing and then reading a register that is accessible via the TAP/DMI inside the RV_DM.
1,"If the JTAG wires are gated, it is expected that the RV_DM returns all-zero instead of the written value."
1,Configure the RV_TIMER to generate interrupt after a set timeout.
1,Issue a WFI to wait for the interrupt to trigger.
1,Service the interrupt when it triggers; verify that it came from rv_timer.
1,Verify that the interrupt triggered only after the timeout elapsed.
1,Verify the AON timer wake up interrupt in normal operating state.
1,Program the PLIC to let the AON timer wake up interrupt the CPU.
1,Program the AON timer to generate the wake up timeout interrupt after some time.
1,Issue a WFI to wait for the interrupt to trigger.
1,Service the interrupt when it triggers; verify that it came from AON timer.
1,Verify that the interrupt triggered only after the timeout elapsed.
1,Verify that AON timer can wake up the chip from a deep sleep state.
1,Read the reset cause register in rstmgr to confirm that the SW is in the POR reset phase.
1,"Program the pwrmgr to go to deep sleep state (clocks off, power off)."
1,Program the AON timer to wake up the chip in a reasonable amount of time.
1,Have the CPU issue WFI to signal the pwrmgr to go into sleep state.
1,"Verify via assertion checks, the wake up request occurs after the timeout has elapsed."
1,"After reset followed by AON timer wake up, read the reset cause register to confirm the AON timer wake up phase."
1,"After the test sequence is complete, read the wake up threshold register it should not be reset."
1,Program the PLIC to let the wdog bark signal interrupt the CPU.
1,Program the AON timer wdog to 'bark' after some time and enable the bark interrupt.
1,Verify that the LC escalation signal disables the AON timer wdog.
1,Program the AON timer wdog to 'bark' after some time and enable the bark interrupt.
1,Start the escalation process and fail the test in the interrupt handler in case the bark interrupt is fired.
1,Program the alert handler to escalate on alerts upto phase 2 (i.e.
1,reset) but the phase 1 (i.e.
1,wipe secrets) should occur and last during the time the wdog is programed to bark and bite.
1,Trigger an alert to cause an escalation condition before the bark signal asserts.
1,After the reset ensure that the reset cause was due to the escalation to prove that the wdog was disabled.
1,Verify the watchdog bite causing reset in the normal state.
1,Read the reset cause register in rstmgr to confirm that the SW is in the POR reset phase.
1,Program the AON timer wdog to 'bark' after some time.
1,"Let the bark escalate to bite, which should result in a reset request."
1,"After reset, read the reset cause register in rstmgr to confirm that the SW is now in the wdog reset phase."
1,"Program the pwrmgr to go to deep sleep state (clocks off, power off)."
1,"Issue a WFI after programming the wdog, so that the reset request due to bite occurs during deep sleep state."
1,"After reset, read the reset cause register in rstmgr to confirm that the SW is now in the wdog reset phase."
1,Verify that the wdog can be paused in sleep state.
1,Program the wdog to 'bite' a little sooner than the AON timer wake up.
1,"Issue a WFI after programming the wdog, so that the reset request occurs during deep sleep state."
1,"After reset followed by AON timer wake up, read the reset cause register to confirm that the AON timer woke up the chip, not the wdog reset."
1,Verify all interrupts from all peripherals aggregated at the PLIC.
1,The automated SW test enables all interrupts at the PLIC to interrupt the core.
1,"It uses the intr_test CSR in each peripheral to mock assert an interrupt, looping through all available interrupts in that peripheral."
1,The ISR verifies that the right interrupt occurred.
1,This is used as a catch-all interrupt test for all peripheral integration testing within which functionally asserting an interrupt is hard to achieve or not of high value.
1,Write to the MSIP CSR to generate a SW interrupt to the CPU.
1,Verify that the only interrupt that is seen is the SW interrupt.
1,Verify the ability to turn off the transactional clock via SW.
1,Ensure that the clock to transactional units will be turned off after any activity completes in the transactional IP.
1,Verify that turning off this clock does not affect the other derived clocks.
1,Verify CSR accesses do not complete in units that are off.
1,"Using the watchdog timers, turn off a transactional unit's clock, issue a CSR access to that unit, verify a watchdog event results, and verify the rstmgr crash dump info records the CSR address."
1,A stretch goal is to check the PC corresponds to the code performing the CSR access (stretch since it could be difficult to maintain this check).
1,Verify the ability to turn off the peripheral clock via SW.
1,Verify CSR accesses do not complete in peripherals that are off.
1,"Using the watchdog timers, turn off a peripheral's clock, issue a CSR access to that peripheral, verify a watchdog event results, and verify the rstmgr crash dump info records the CSR address."
1,"The IP level checks the divided clocks via SVA, and these are also bound at chip level."
1,Connectivity tests check peripherals are connected to the clock they expect.
1,Use the clkmgr count measurement feature to verify clock division.
1,Verify the clkmgr requests ext clk src during certain LC states.
1,"On POR lc asserts lc_clk_byp_req on some LC states, and de-asserts it when lc_program completes."
1,"It may be best to verify this via SVA, unless we implement clock cycle counters."
1,Verify SW causes the clkmgr requests ext clk src during certain LC states.
1,In RMA and TEST_UNLOCKED lc states the external clock is enabled in response to extclk_ctrl.sel CSR writes.
1,In addition extclk_ctrl.hi_speed_sel CSR causes the divided clocks to step down.
1,"Verify this via SVA bound to clkmgr, and clock cycle counters."
1,"X-ref with chip_sw_uart_tx_rx_alt_clk_freq, which needs to deal with this as well."
1,Verify this output is connected to AST's clk_src_sys_jen_i input using formal.
1,"Verify that the system can run at a reduced, calibrated clock frequency."
1,"This test should check that the system can run at a reduced, calibrated clock frequency (70MHz) with jitter enabled (which can lower the frequency down to ~55 MHz momentarily)."
1,This option is intended as a fall-back in case there are issues running the system with at 100MHz (calibrated).
1,"This testpoint can be covered by extending the DV environment to support the extended range clock option via a flag, and running several existing chip-level tests with that option."
1,"Upon wakeup reset the clock measurements should be off, but the recoverable fault status should not be cleared."
1,Enable clock cycle counts.
1,Put the chip in shallow sleep with pwrmgr's CONTROL CSR keeping some clocks disabled.
1,"Upon wakeup the clock measurements should be on, and the recoverable fault status should show no errors for the disabled clocks."
1,Trigger a chip reset via SW. After reset the clock measurements should be off and the recoverable fault status should be cleared.
1,Verify the clock manager resets to a clean state after an escalation reset.
1,Trigger an internal fatal fault for the regfile onehot checker and let it escalate to reset.
1,"Upon alert escalation reset, the internal status should be clear and clkmgr should not attempt to send out more alerts."
1,Verify the flash ctrl fatal error does not disturb escalation process and operation of ibex core.
1,Trigger an internal fatal fault (host_gnt_err) from flash_ctrl and let it escalate to reset.
1,"Upon alert escalation reset, the internal status should be clean and should not send out more alerts."
1,Verify the cold boot sequence by wiggling of chip's POR_N.
1,This ensures that both FSMs are properly reset on the POR signal.
1,The check is that the processor ends up running.
1,"Also verify, the rstmgr recorded POR in reset_info CSR by checking retention SRAM for reset_reason."
1,Verify that the chip can go into random low power states and be woken up by ALL wake up sources.
1,This verifies ALL wake up sources.
1,This also verifies that the pwrmgr sequencing is working correctly as expected.
1,X-ref'ed with all individual IP tests.
1,"For each wakeup source clear and enable wake_info CSR, enable the wakeup from that source with the wakeup_en CSR, bring the chip to both normal and low power sleep, optionally disabling the source's clock, have the source issue a wakeup event and verify wake_info indicates the expected wakeup."
1,Each test should perform a minimum of 2 low power transitions to ensure there are no state dependent corner cases with wakeup interactions.
1,Verify that the chip can go into normal sleep state and be woken up by ALL wake up sources.
1,This also verifies that the pwrmgr sequencing is working correctly as expected.
1,"For each wakeup source clear and enable wake_info CSR, enable the wakeup from that source with the wakeup_en CSR, bring the chip to normal sleep, optionally disabling the source's clock, have the source issue a wakeup event and verify wake_info indicates the expected wakeup."
1,Verify that the chip can go into normal sleep state and be reset by ALL reset req sources.
1,This also verifies that the pwrmgr sequencing is working correctly as expected.
1,X-ref'ed with all individual IP tests.
1,"For each reset source, enable the source and bring the chip to low power, issue a reset, and verify the rstmgr's reset_info indicated the expected reset by checking retention SRAM for reset_reason."
1,Verify that the chip can go into deep sleep state and be woken up by ALL wake up sources.
1,This also verifies that the pwrmgr sequencing is working correctly as expected.
1,X-ref'ed with all individual IP tests.
1,Verify that the chip can go into deep sleep state and be reset up by ALL reset req sources.
1,Verify that the chip can be reset by watchdog timer reset source.
1,This also verifies that the pwrmgr sequencing is working correctly as expected.
1,X-ref'ed with all individual IP tests.
1,"Similar to chip_pwrmgr_sleep_all_reset_reqs, except the chip is not put in low power mode."
1,Verify the cold boot sequence through an AON power glitch.
1,Pulsing the AST vcaon_supp_i input causes an AON power glitch which becomes a POR.
1,This ensures that both FSMs are properly reset on the POR signal.
1,The check is that the processor ends up running.
1,"Also verify, the rstmgr recorded POR in reset_info CSR by checking retention SRAM for reset_reason."
1,Verify the effect of a glitch in main power rail.
1,The vcmain_supp_i AST input is forced to drop once the test is running.
1,"This triggers a MainPwr reset request, which is checked by reading retention SRAM's reset_reason to see that the reset_info CSR's POR bit is not set when the test restarts."
1,Verify the effect of a glitch in main power rail in random sleep states.
1,The vcmain_supp_i AST input is forced to drop right after putting the chip in a random sleep state.
1,"This triggers a MainPwr reset request, which is checked by reading retention SRAM's reset_reason to show that the reset_info CSR's POR bit is not set when the test restarts."
1,If sent too early the chip won't have started to process deep sleep.
1,"If too late the hardware won't monitor main power okay so the glitch will have no effect, and the test will timeout."
1,Each test should perform a minimum of 2 low power transitions to ensure there are no state dependent corner cases with power glitch handling.
1,Verify the effect of a glitch in main power rail in deep sleep.
1,The vcmain_supp_i AST input is forced to drop right after putting the chip in deep sleep.
1,"This triggers a MainPwr reset request, which is checked by reading retention SRAM's reset_reason to show that the reset_info CSR's POR bit is not set when the test restarts."
1,If sent too early the chip won't have started to process deep sleep.
1,"If too late the hardware won't monitor main power okay so the glitch will have no effect, and the test will timeout."
1,Verify the effect of a glitch in main power rail in shallow sleep.
1,The vcmain_supp_i AST input is forced to drop after putting the chip in shallow sleep.
1,"This triggers a MainPwr reset request, which is checked by reading the retention SRAM's reset_reason shows that the reset_info CSR's POR bit is not set when the test restarts."
1,Verify that this chip can be reset by All available reset sources.
1,Verify the effect of a sysrst_ctrl output in main power rail.
1,Read the reset cause register in rstmgr to confirm that the SW is in the POR reset phase.
1,"After sysrst reset is generated by forcing, read the reset cause register in rstmgr to confirm that the SW is now in the sysrst reset phase."
1,"After reset, read the reset cause register in rstmgr to confirm that the SW is now in the sysrst reset phase."
1,Program the AON timer wdog to 'bark' after some time.
1,"Let the bark escalate to bite, which should result in a reset request."
1,"After reset, read the reset cause register in rstmgr to confirm that the SW is now in the wdog reset phase."
1,Program the AON timer wdog to 'bark' after some time.
1,"Verify that the pwrmgr sequences sleep_req and reset req coming in almost at the same time, one after the other."
1,Use POR_N PAD to trigger reset.
1,Verify that the chip does not go to sleep on WFI when low power hint is 0.
1,"This calls WFI with low_power_hint disabled and pwrmgr interrupts enabled, and fails if the pwrmgr ISR is called."
1,Verify the power manager resets to a clean state after an escalation reset.
1,Trigger an internal fatal fault for the regfile onehot checker and let it escalate to reset.
1,"Upon alert escalation reset, the internal status should be clear and pwrmgr should not attempt to send out more alerts."
1,Verify the reset_info CSR register for lc or higher resets.
1,"Generate the 5 types of reset at lc level or higher, and check the retention SRAM's reset_reason to show that reset_info CSR is as expected."
1,"This and other rstmgr testpoints that require different resets cross-reference the individual IP tests that generate those resets, and this testpoint merely adds reset checks in them."
1,This should also check the reset's destination IP to make sure some reset side-effect is present.
1,Setting some intr_enable CSR bit when the test starts and checking it after reset seems suitable.
1,The spi_host IPs receive multiple resets so they will need special consideration.
1,"Generate reset triggered by rv_dm, which results in a sys level reset, and check the retention SRAM's reset_reason to show that the reset_info CSR is as expected."
1,"This testpoint cross-reference the rv_dm tests that generate this reset, and this testpoint merely adds reset checks in them."
1,This should also check the reset's destination IP to make sure some reset side-effect is present.
1,Setting some intr_enable CSR bit when the test starts and checking it after reset seems suitable.
1,The spi_host IPs receive multiple resets so they will need special consideration.
1,Verify the expected values from the cpu_info CSR on reset.
1,For some software induced resets we can predict the expected contents of cpu_info; reads of writes to unmapped addresses for example.
1,Generate these resets and verify the cpu_info register contents when reset is handled.
1,Generate a reset request by directly writing the reset_req CSR.
1,The reset created should be identical to those caused by hardware sources.
1,"After reset, the retention SRAM's reset_reason should show that the reset_info CSR reflects that a software request was the reset cause."
1,Verify the expected values from the alert_info CSR on reset.
1,"Various alerts can be created, for example, timeouts, and integrity errors, and at least part of the alert_info CSR can be predicted."
1,"To cause some of these to cause a reset, mask the relevant processor interrupts."
1,Trigger these resets and verify the alert_info register contents when reset is handled.
1,Pick a rw type CSR in each peripheral and program arbitrary value that does not cause any adverse side-effects.
1,Read the resister after reset and verify it returns the reset value.
1,"Repeat these steps for each of these software resettable peripherals: spi_device, spi_host0, spi_host1, usb, i2c0, i2c1, i2c2."
1,Verify the reset manager resets to a clean state after an escalation reset.
1,Trigger an internal fatal fault for the regfile onehot checker and let it escalate to reset.
1,"Upon alert escalation reset, the internal status should be clear and rstmgr should not attempt to send out more alerts."
1,Program the alert_test CSR in each block to trigger each alert one by one.
1,Ensure that all alerts are properly connected to the alert handler and cause the escalation paths to trigger.
1,Verify the first escalation results in NMI interrupt serviced by the CPU.
1,"Verify the second results in device being put in scrap state, via the LC JTAG TAP."
1,"Inject integrity errors in any unit that has a one-hot checker for CSR register writes, and verify escalation is triggered."
1,Allow escalation to go through reset.
1,Use the rstmgr alert info and the unit's fault CSRs to check the alert cause is right.
1,Each run of the test randomly chooses some one-hot checker for the error to be injected.
1,Keep state across resets in flash to check the expected interrupts and the right number of resets occur.
1,Verify the first escalation results in NMI serviced by the CPU.
1,Verify the unit's fault CSR correctly captured the fault kind.
1,"Verify after the escalation reset all faults are cleared, and that the alert info captured the correct alert."
1,Verify all classes of alert handler interrupts to the CPU.
1,Verify the alert handler entropy input to ensure pseudo-random ping timer.
1,Force alert_handler_ping_timer input signal wait_cyc_mask_i to 8'h07 to shorten the simulation time.
1,Verify that the alert_handler can request EDN to provide entropy.
1,Ensure that the alert ping handshake to all alert sources and escalation receivers complete without errors.
1,"When the chip resets due to alert escalating to cause the chip to reset, verify the reset cause to verify the alert crashdump."
1,Set alert_handler's ping timeout cycle to 2 and enable alert_senders.
1,Verify that alert_handler detects the ping timeout and reflects it on the loc_alert_cause register.
1,Trigger fatal alerts for all IPs but configure alert_handler so it won't trigger reset.
1,Wait random cycles then wake up from the sleep mode.
1,"After wake up from normal sleep mode, clear all alert cause registers and check that all alerts are still firing after waking up."
1,Verify alert_handler's ping mechanism works correctly during sleep and wake up.
1,Configure alert_handler's ping timeout register to a reasonble value that won't cause ping timeout in normal cases.
1,Then randomly enter and exit normal or deep sleep modes.
1,This scenario ensures that ping mechanism won't send out spurious failure.
1,Configure alert_handler's ping timeout register to a small value that will always causes ping timeout.
1,Then randomly enter and exit normal or deep sleep modes.
1,Clear local alert cause register and check that alert ping timeout continue to fire after wake up.
1,This scenario ensures the ping mechanism will continue to send out pings after waking up from sleep modes.
1,Verify alert_handler's works correctly when sender clock is turned off.
1,Configure clkmgr to randomly turn off one of the IP's clock and check alert_handler won't trigger a ping timeout error on that block.
1,Trigger fatal alerts in an IP then configure clkmgr to turn off the IP clock.
1,Check the IP's fatal alert resumes after clock is turned back on.
1,Configure rstmgr to randomly toggle one IP block's SW reset and check alert_handler won't trigger a ping timeout error on that block.
1,Check that escalation receivers located inside always-on blocks do not auto-escalate due to the reverse ping feature while the system is in deep sleep.
1,"Enable all alerts assigning them to ClassA, on POR reset."
1,"Enable all local alerts and assign to ClassB, on POR reset."
1,"Set escalation configuration to trigger before test wake up time, on POR reset."
1,"Set ping timeout to a time less than wake up time, on POR reset."
1,"Lock alert configuration and enable ping mechanism, on POR reset."
1,"Wait for polling counters to cycle through by busy polling on Ibex for reverse_ping_timeout >> 2 usec, on POR reset."
1,"Configure AON to wake up device at a later time, making sure it is greater than the reverse_ping_timeout calculated in the previous section, on POR reset."
1,"Ensure reset status is low power exit, on wake up from sleep."
1,"A kDifRstmgrResetInfoEscalation signals that there was a local escalation and should result in test failure, on wake up from sleep."
1,"Check there are no flagged local alerts, on wake up from sleep."
1,Verify that the escalation signals from the alert handler are connected to LC ctrl.
1,First escalation has no effect on the LC ctrl.
1,Read LC_STATE CSR to confirm this is the case.
1,Second escalation should cause the lc_escalation_en output to be asserted and for the LC_STATE to transition to scrap state.
1,Verify that all decoded outputs except for escalate_en are disabled.
1,"Using the JTAG agent, write and read LC ctrl CSRs, verify the read value for correctness."
1,Preload the hw_cfg partition in OTP ctrl with random data.
1,Read the device ID and the ID state CSRs to verify their correctness.
1,Reset the chip and repeat the first 2 steps to verify a different set of values.
1,"The pwrmgr initiates a handshake with OTP ctrl and later, with LC ctrl in subsequent FSM states."
1,Ensure that the whole power up sequence does not hang.
1,"Verify with connectivity assertion checks, the handshake signals are connected."
1,Verify the LC ctrl can transit from one state to another valid state with the correct tokens.
1,Preload OTP image with a LC state and required tokens to transfer to next state.
1,"Initiate an LC ctrl state transition via SW if CPU is enabled, or via JTAG interface if CPU is disable."
1,Ensure that the LC program request is received by the OTP ctrl.
1,Verify the updated data output from OTP ctrl to LC ctrl is correct.
1,Verify that the LC ctrl has transitioned to the programmed state after a reboot.
1,"For conditional transition, the LC ctrl will send out a token request to KMAC."
1,"Verify that the KMAC returns a hashed token, which should match one of the transition token CSRs."
1,Verify the effect of putting the KMAC logic in reset during LC state transition.
1,"For a lc state transition, force a reset to KMAC when KMAC is processing lc transition tokens."
1,Force another KMAC reset after KMAC is done processing lc trantition tokens.
1,"Verify in different LC states, LC ctrl outputs the correct key_div_o to keymgr."
1,Verify that the keymgr uses the given key_div_o value to compute the keys.
1,"Preload the LC partition in the otp_ctrl with the following states: RMA, DEV, TEST_LOCKED[N] & SCRAP."
1,"Drive a known value on ac_reset, ec_rst_l, flash_wp_l, pwrb, lid_open and key* pins at the chip inputs."
1,"Drive a known value on ac_reset, ec_rst_l, flash_wp_l, pwrb, lid_open and key* pins at the chip inputs."
1,Verify that SYSRST ctrl correctly loops them back to the chip outputs.
1,Write the pin_allowed_ctl register to allow some of the pins to be overridden with either 0 or 1 or both.
1,Write the pin_out_ctl register to enable the override on some of the pins.
1,Write the pin_out_value register to set known values on those pins.
1,"Verify that at the chip outputs, pins on which override should be active is reflecting the overridden values."
1,All others should reflect the values driven on chip inputs.
1,"Via assertion checks (or equivalent) verify that the transitions at the inputs immediately reflect at the outputs, if not intercepted / debounced by sysrst_ctrl."
1,"Program a specific combination of transitions on pwrb, key*, ac_present and ec_reset_l pins to trigger an interrupt by writing to key_intr_ctl register."
1,Enable the interrupt at SYSRST ctrl as well as at the PLIC.
1,Create glitches only for some time less than detection time and check that there is no interrupt triggered.
1,Glitch the inputs at the chip IOs before stabilizing on the programmed transitions.
1,"SW services the interrupt when triggered, verifies the pin input value and key_intr_status for correctness and clears the interrupt status."
1,Read the reset cause register in rstmgr to confirm we are in POR reset phase.
1,Program one of the com_sel_ctl_* CSRs to choose a set of inputs to be detected as a low power wakeup signal for the pwrmgr.
1,Program the detection outcome CSR's (com_out_ctl) interrupt bit to 1.
1,Program the pwrmgr to put the chip in deep sleep state and wake up on chip wake up event.
1,Issue a WFI to bring the chip in low power state.
1,"After the chip has entered low power mode, set the SYSRST ctrl inputs at the chip IOs to the programmed combination for the duration of the detection timer."
1,Read the reset cause register to confirm wake up from low power exit phase.
1,Read the pwrmgr wake up status register to confirm chip wake up.
1,Read the pin input value and the combo_intr_status CSRs to verify the correct combination on inputs woke up the chip from sleep.
1,Read the reset cause register in rstmgr to confirm we are in POR reset phase.
1,Program one of the com_sel_ctl_* CSRs to choose a set of inputs to be detected as the chip reset signal.
1,Program the detection outcome CSR's (com_out_ctl) chip reset bit to 1.
1,"After some time, set the SYSRST ctrl inputs at the chip IOs to the programmed combination for the duration of the detection timer."
1,The pwrmgr will power cycle the chip once it receives the chip reset input.
1,Check that ec_rst_l and flash_wp_l (on pads IOR8 and IOR9) are asserted right after the pwrmgr has power cycled the system.
1,Read the reset cause register after boot up to confirm peripheral reset phase.
1,Read the pwrmgr reset status register to confirm chip reset.
1,Read the com_sel_ctl_* CSR in SYSRST ctrl we programmed earlier it should have been reset.
1,Read the reset cause register in rstmgr to confirm we are in POR reset phase.
1,Program one of the com_sel_ctl_* CSRs to choose a set of inputs to be detected as the chip reset signal.
1,Program the detection outcome CSR's (com_out_ctl) chip reset bit to 1.
1,Program the pwrmgr to put the chip in deep sleep state and allow it to be reset by the chip reset bit.
1,Issue a WFI to bring the chip in low power state.
1,"After the chip has entered low power mode, set the SYSRST ctrl inputs at the chip IOs to the programmed combination for the duration of the detection timer."
1,The pwrmgr will power cycle the chip from the deep sleep state once it receives the chip reset input.
1,Read the reset cause register after boot up to confirm peripheral reset phase.
1,Read the pwrmgr reset status register to confirm chip reset.
1,Read the com_sel_ctl_* CSR in SYSRST ctrl we programmed earlier it should have been reset.
1,Verify that ec_rst_l stays asserted as the chip is brought out of reset.
1,Verify that the pin continues to remain low until SW is alive.
1,Have the SW write to pin_allowed|out_ctrl CSRs to control the ec_rst_l value and verify the value at the chip output.
1,"Optionally, also verify ec_rst_l pulse stretching by setting the ec_rst_ctl register with a suitable pulse width."
1,"Exactly the same as chip_sysrst_ctrl_ec_rst_l, but covers the flash_wp_l pin."
1,"Start off with ac_present=0, lid_open=0 and pwrb=0 at the chip inputs."
1,Program the ulp_ac|lid|pwrb_debounce_ctl registers to debounce these inputs for an appropriate time.
1,Enable the ULP wakeup feature by writing to the ulp_ctl register.
1,"Read the ulp_wakeup register and verify that no wakeup event is detected, after some amount of delay."
1,Glitch the lid_open input at the chip IOs before stabilizing on value 1.
1,Read the ulp_wakeup register to verify that the wakeup event is detected this time.
1,Verify that the z3_wakeup output at the chip IOs is reflecting the value of 1.
1,Program both ADC channels to detect mutually exclusive range of voltages.
1,Program the ADC intr ctrl CSR to detect the selected filter on both channels.
1,Enable the debug cable interrupt at ADC ctrl as well as PLIC.
1,Enable the ADC ctrl to run with defaults in normal mode (depending on simulation runtime).
1,"Verify through assertion checks, the ADC with AST stays powered down periodically in slow scan mode."
1,"After some time, force the ADC output of AST to be a value within the programmed range for each channel."
1,Glitch it out of range for some time before stabilizing to ensure that debouce logic works.
1,Service the debug cable irq.
1,Read the intr status register to verify that the selected filter caused the interrupt to fire.
1,Read the ADC channel value register to verify the correctness of the detected value that was forced in the AST for each channel.
1,Read the reset cause register in rstmgr to confirm we are in POR reset phase.
1,"Follow the same steps as chip_adc_ctrl_debug_cable_irq, but instead of programming the selected filter to interrupt, program it to wake up the chip from sleep."
1,Program the pwrmgr to put the chip in deep sleep state and wake up on debug cable detection.
1,Issue a WFI to bring the chip in low power state.
1,"After some time, force the ADC output of AST to be a value within the programmed filter range."
1,That should cause the pwrmgr to wake up.
1,Read the reset cause register to confirm wake up from low power exit phase.
1,Read the pwrmgr wake up status register to confirm wake up was due to debug cable detection.
1,Read the ADC channel value register to verify the correctness of the detected value that was forced in the AST.
1,Write a 32-byte key and a 16-byte plain text to the AES registers and trigger the AES computation to start.
1,Wait for the AES operation to complete by polling the status register.
1,Check the digest registers for correctness against the expected digest value.
1,"Write the initial key share, IV and data in CSRs (known combinations)."
1,Write the PRNG_RESEED bit to reseed the internal state of the PRNG.
1,Poll the status idle bit to ensure reseed operation is complete.
1,Trigger the AES operation to run and wait for it to complete.
1,Write the KEY_IV_DATA_IN_CLEAR and DATA_OUT_CLEAR trigger bits to 1 and wait for it to complete by polling the status idle bit.
1,Read back the data out CSRs they should all read garbage values.
1,"Assertion check verifies that the IV are also garbage, i.e."
1,different from the originally written values.
1,Write the AES clk hint to 0 within clkmgr to indicate AES clk can be gated and verify that the AES clk hint status within clkmgr reads 0 (AES is disabled).
1,Write the AES clk hint to 1 within clkmgr to indicate AES clk can be enabled.
1,"Initiate an AES operation with a known key, plain text and digest, write AES clk hint to 0 and verify that the AES clk hint status within clkmgr now reads 1 (AES is enabled), before the AES operation is complete."
1,After the AES operation is complete verify that the AES clk hint status within clkmgr now reads 0 again (AES is disabled).
1,"Write the AES clk hint to 1, read and check the AES output for correctness."
1,Trigger the AES encryption and wait for it to complete.
1,Trigger the AES decryption and wait for it to complete.
1,Verify that the output is equal to the plain text.
1,Clear the key in the keymgr and decrypt the ciphertext again.
1,Verify that output is not equal to the plain text.
1,"SW test verifies an HMAC operation with a known key, plain text and digest (pick one of the NIST vectors)."
1,Verify the HMAC done and FIFO empty interrupts as a part of this test.
1,Write the HMAC clk hint to 0 within clkmgr to indicate HMAC clk can be gated and verify that the HMAC clk hint status within clkmgr reads 0 (HMAC is disabled).
1,Write the HMAC clk hint to 1 within clkmgr to indicate HMAC clk can be enabled.
1,Verify that the HMAC clk hint status within clkmgr reads 1 (HMAC is enabled).
1,"Initiate an HMAC operation with a known key, plain text and digest."
1,"Write HMAC clock hint to 0 and verify the HMAC clk hint status within clkmgr reads 1 (HMAC is enabled), before the HMAC operation is complete."
1,"After the HMAC operation is complete, verify the digest for correctness."
1,Verify that the HMAC clk hint status within clkmgr now reads 0 again (HMAC is disabled).
1,This process is repeated for two hmac operations needed to verify the resulting hmac digest.
1,"SW test verifies SHA3 operation with a known key, plain text and digest (pick one of the NIST vectors)."
1,SW validates the reception of kmac done and fifo empty interrupts.
1,Configure the keymgr to start sending known message data to the KMAC.
1,Keymgr should transmit a sideloaded key to the KMAC as well.
1,KMAC should finish hashing successfully (not visible to SW) and return digest to keymgr.
1,This digest is compared against the known digest value for correctness.
1,Verify that the keymgr has received valid output from the KMAC.
1,Configure the LC_CTRL to start a token hash using KMAC interface.
1,KMAC should finish hashing successfully (not visible to SW) and return digest to LC_CTRL.
1,KMAC will hash and return the digest to the ROM.
1,ROM will compare received digest against its first 8 logical memory lines for correctness.
1,Program wait_timer to a small value.
1,Check if EDN timeout error occurs after issuing the hashing op.
1,Adjust wait_timer greater than expected EDN latency (with correct prescaler too).
1,Then check if Digest is correct.
1,KMAC should send EDN request after entropy_ready is set.
1,KMAC also should send out another request to EDN when either:
1,Hash count exceeds the threshold.
1,SW verifies that KMAC produces the correct digest value.
1,Write the KMAC clk hint to 0 within clkmgr to indicate KMAC clk can be gated and verify that the KMAC clk hint status within clkmgr reads 0 (KMAC is disabled).
1,Write the KMAC clk hint to 1 within clkmgr to indicate KMAC clk can be enabled.
1,Verify that the KMAC clk hint status within clkmgr reads 1 (KMAC is enabled).
1,"Initiate a KMAC operation with a known key, plain text and digest."
1,"Write KMAC clock hint to 0 and verify the KMAC clk hint status within clkmgr reads 1 (KMAC is enabled), before the KMAC operation is complete."
1,"After the KMAC operation is complete, verify the digest for correctness."
1,Verify that the KMAC clk hint status within clkmgr now reads 0 again (KMAC is disabled).
1,Route the entropy data received from RNG to the FIFO.
1,Verify that the FIFO depth is non-zero via SW indicating the reception of data over the AST RNG interface.
1,Verify the correctness of the received data with assertion based connectivity checks.
1,"Disable edn0, edn1, csrng and entropy_src, as these are enabled by the test ROM."
1,Issue csrng instantiate and reseed commands.
1,"Check that for each csrng command, there is a corresponding entropy request interrupt."
1,"Generate output and ensure the data output is valid, and that csrng is not reporting any errors."
1,"Check that for each command, there is a corresponding entropy request interrupt."
1,Initialize the OTP with the fuse that controls whether the SW can read the entropy src enabled.
1,Read the OTP and verify that the fuse is enabled.
1,Read the entropy_data_fifo via SW and verify that it reads valid values.
1,"Reset the chip, but this time, initialize the OTP with with the fuse disabled."
1,Read the internal state via SW and verify that the entropy valid bit is zero.
1,Read the entropy_data_fifo via SW; verify that it reads the expected values.
1,"Have each EDN instance issue an instantiate, reseed and generate command to CSRNG."
1,"On each command done, verify the reception of edn cmd req done interrupt."
1,Run OTBN randomness test to test the output from EDN0 and EDN1.
1,Check the data returned to EDN via connectivity assertion checks.
1,Initialize the OTP with the fuse that control whether the SW can read the CSRNG state enabled.
1,"Reset the chip and repeat the steps above, but this time, initialized the OTP with fuse disabled."
1,Verify that the SW reads back all zeros when reading the internal state values.
1,Configure entropy_src into bypassing the conditioner and directly inject known entropy.
1,Instantiate CSRNG with the known entropy while in TEST state (hw_debug_en=1).
1,Retrieve entropy from csrng and save it in flash and reset the system.
1,Run the process again and ensure the exact same result can be reproduced (similar to KAT).
1,Again configure entropy_src to bypass the conditioner and use direct injection.
1,Instantiate CSRNG with the same fixed seed and fetch entropy again while in the NEW state.
1,The newly fetched entropy and the old entropy stored in flash should not match.
1,Configure the software instance with the expected seed (as per the NIST-specified test for CTR_DRBG operation).
1,Compare the DRBG internal K and V state against the test vector expected values.
1,"In the SW test, write fixed value to OTP for root_key and write creator and owner seeds in flash."
1,And then roboot the chip.
1,"In the SV sequence, backdoor read Device ID and ROM digest through CSRs."
1,"No need to test the Attestation CDI in chip-level as the only difference is to use another set of CSR values, and the rest of inputs are the same as the Sealing CDI."
1,KMAC should finish hashing successfully (not visible to SW) and return digest to keymgr.
1,Advance to Disabled and verify keymgr enters the state successfully.
1,"For each operation, wait for the interrupt op_done to be triggered and check CSR op_status is DONE_SUCCESS."
1,"Use SW to calculate that, and it will also exercise the Ibex."
1,SW sends all the keys through CSRs to KMAC to generate the degist data.
1,DV calls C functions to generate and backdoor load to a specific memory location for SW. (Adpot this approach.)
1,Configure KMAC to use the sideload key to generate digest data.
1,"Load OTBN binary image, the rest is similar to chip_keymgr_sideload_kmac, except sideloading to otbn."
1,SW test directs the OTBN engine to perform an ECDSA operation.
1,SW validates the reception of the otbn done interrupt once the operation is complete.
1,SW verifies the correctness of the result with the expected value which is pre-computed using a reference model.
1,SW loads an OTBN app that executes instructions to read the RND bits.
1,"The OTBN app ensures that the values when read consequtively do not match, and its not all 0s or all 1s, as a basic measure to ensure that the entropy subsystem is returning some data."
1,Write the OTBN clk hint to 0 within clkmgr to indicate OTBN clk can be gated and verify that the OTBN clk hint status within clkmgr reads 0 (OTBN is disabled).
1,Write the OTBN clk hint to 1 within clkmgr to indicate OTBN clk can be enabled.
1,Verify that the OTBN clk hint status within clkmgr reads 1 (OTBN is enabled).
1,"Start an OTBN operation, write the OTBN clk hint to 0 within clkmgr and verify that the OTBN clk hint status within clkmgr reads 1 (OTBN is enabled) before the OTBN operation is complete."
1,"After the OTBN operation is complete, verify that the OTBN clk hint status within clkmgr now reads 0 again (OTBN is disabled)."
1,"Write the OTBN clk hint to 1, read and check the OTBN output for correctness."
1,Initialize the entropy_src subsystem to enable OTP_CTRL fetch random data (already done by the test_rom startup code).
1,Read back the written address offsets and compare against expected values.
1,"All values must match, no integrity errors must be triggered."
1,Have OTBN fetch new keys and nonces from the OTP_CTRL.
1,Read back the written address offsets.
1,Most reads should trigger integrity errors.
1,It is possible that after re-scrambling the integrity bits are still valid.
1,But this is expected to happen rarely.
1,"If the number of observed integrity errors is below a chosen threshold, the test fails."
1,"Verify the validity of EDN's output to OTP_CTRL via assertions (unique, non-zero data)."
1,Verify that the CPU can fetch instructions from the ROM.
1,"In non-PROD LC state, the computed digest does not have to match the top 8 words in the ROM."
1,Verify that we can successfully power up the chip in this case.
1,"In PROD LC state, verify that the pwrmgr does not fully power up if the computed digest does not match the top 8 words of the ROM."
1,Initialize the entropy_src subsystem to enable OTP_CTRL fetch random data (already done by the test_rom startup code).
1,Fetch a new key from the OTP_CTRL and ensure that the previous contents cannot be read anymore.
1,"Verify the validity of EDN's output to OTP_CTRL via assertions (unique, non-zero data)."
1,The fetch enable bit in the HW_CFG partition of OTP controller set and not set.
1,"A life cycle state that enables (TEST_UNLOCKED, DEV or RMA) and disables (PROD) hardware debug."
1,"If the instruction execution is enabled, verify that the CPU can fetch and execute the instruction from the SRAM correctly."
1,"If the instruction execution is not enabled, verify that the SRAM throws an error response via an exception handler."
1,Configure the LC_CTRL to trigger an escalation request to the SRAMs.
1,Verify that the SRAMs stop accepting and responding to new memory requests.
1,Re-initialize the SRAMs and verify that they can now respond correctly to any further memory requests.
1,"The pwrmgr initiates a handshake with OTP ctrl and later, with LC ctrl in subsequent FSM states."
1,Ensure that the whole power up sequence does not hang.
1,"Verify with connectivity assertion checks, the handshake signals are connected."
1,"Verify the correctness of keys provided to SRAM ctrl (main & ret), flash ctrl, keymgr, (note that keymgr does not have handshake), and OTBN."
1,"Verify that upon an LC state transition request, LC ctrl signals the OTP ctrl with a program request."
1,Verify that the OTP ctrl generates the LC data output correctly and is sent to the LC ctrl before it is reset.
1,Ensure that the whole operation does not raise any interrupts or alerts or errors.
1,"After reset, verify that the LC state transition completed successfully by reading the LC state and LC count CSRs."
1,Initiate an illegal program request from LC ctrl to OTP ctrl by forcing the lc_otp_program_i.
1,Verify that the LC ctrl triggers an alert when the OTP ctrl responds back with a program error.
1,Verify the correctness of otp_hw_cfg bus in all peripherals that receive it.
1,lc_seed_hw_rd_en_i: verify that the keymgr outputs a default value when enabled.
1,lc_dft_en_i: verify that the test interface within OTP ctrl is accessible.
1,lc_check_byp_en_i: verify that the background check during LC ctrl state programming passes when enabled.
1,The prim tlul interface is a open source placeholder for the closed source CSRs that will be implemented in a translation 'shim'.
1,"Verify that when lc_dft_en_i is On, this region can be read / written to by the SW."
1,"When lc_dft_en_i is Off, accessing this region will result in a TLUL error."
1,Ensure device id and manufacturing state can be read through the LC JTAG.
1,"Enable RMA mode, and verify that the SW can access the flash."
1,Ensure that the previous contents are inaccessible.
1,"RMA entry can be through the C side or the JTAG interface, both vectors should be tested."
1,Verify flash scrambling with different key values programmed in OTP.
1,"Verify read of scrambled contents via both, controller and direct host read."
1,Program a new scramble key in OTP and reboot this time we need to backdoor load the flash with new test image that is re-scrambled with the new key.
1,Ensure that the low power entry does not happen due to the ongoing flash operation.
1,Transition from TEST_LOCKED to DEV/PROD to ESCALATION/SCRAP state via OTP and verify that this LC signal transitions from 0 to 1 and back to 0.
1,Verify that the SW accessibility of the corresponding partition depending on the signal value.
1,Transition from DEV to PROD to ESCALATION/SCRAP state via OTP and verify that this LC signal transitions from 0 to 1 and back to 0.
1,Verify that the SW accessibility of the corresponding partition depending on the signal value.
1,Transition from TEST_LOCKED to DEV/PROD to ESCALATION/SCRAP state via OTP and verify that this LC signal transitions from 0 to 1 and back to 0.
1,Verify that the SW accessibility of the corresponding partition depending on the signal value.
1,Transition from TEST_LOCKED to DEV/PROD to ESCALATION/SCRAP state via OTP and verify that this LC signal transitions from 0 to 1 and back to 0.
1,Verify that the flash ctrl does (or does not) read the creator and owner partitions to fetch the seeds for the keymgr.
1,Verify that all flash accesses are disabled when the escalation kicks in.
1,Confirm flash accesses are disabled by erroing if the device executes the ISR.
1,Use assertion based connectivity check to prove that this signal is connected to the flash ctrl.
1,The prim tlul interface is a open source placeholder for the closed source CSRs that will be implemented in a translation 'shim'.
1,Verify that this region can be read / written to by the SW in any LC state.
1,"Enable jitter on the clock while performing erase, write and read operations to the flash."
1,This sets the test for closed source where the flash access timing matters.
1,Verify that the AST generates the 4 clocks when requested by the clkmgr.
1,Verify the clock frequencies are reasonably accurate.
1,"Bring the chip to deep sleep, and verify that upon wakeup reset the clock counters are turned off, measure ctrl regwen is enabled, and errors are not cleared."
1,First place the AST into a mode where usb clock frequency significantly deviates from the ideal.
1,Verify the clock is off using the clkmgr measurement mechanism.
1,"Then, turn on the usb sof calibration machinery and wait a few mS."
1,"Afterwards, measure the usb clock again using the clkmgr measurement controls, at this point the clock should be significantly more accurate."
1,"Note, while the above is ideal, usbdev chip level testing is not yet ready and this test fakes the usb portion through DV forces."
1,"Note also the real AST calibration logic is not available, so the sof testing in the open source is effectively short-circuited."
1,Check that AST events can be triggered from sensor_ctrl and that the resulting AST outputs are observed in both sensor_ctrl and the alert_handler.
1,"For the alert handler case, make sure to test each alert configured as either recoverable or fatal."
1,"Check that when the IO POK status changes, an interrupt is triggered from sensor_ctrl."
1,"After triggering, the IO status can be read from a sensor_ctrl register."
1,Verify the sensor control is able to wake the device from sleep mode when an alert event is triggered from AST.
1,Randomly use these two methods (simultaneously or choose one of them) to trigger the NMI interrupt: 1)Trigger the alert_handler escalation pair that maps to NMI 2)Trigger a watchdog bark.
1,Check rv_core_ibex's NMI interrupt register and clear the interrupt.
1,"If the NMI interrupt is triggered by alert_handle and the class_clr_regwen register is not locked, check that alert_handler can clear this NMI escalation stage."
1,Then make sure that the alert_handler won't move forward to the next escalation stage.
1,Perform multiple reads from RND_DATA polling RND_STATUS in between to only read valid data.
1,Check different random bits are provided each time and that the random data is never zero or all ones.
1,Perform repeated reads from RND_DATA without RND_STATUS polling to check read when invalid doesn't block.
1,Setup address translation for both slots on the the I and D side and check correct translation for I and D accesses.
1,Switch address translation to use different regions that overlap for both slots and check translation again.
1,"Ensure some test accesses match both regions, where the lowest indexed one takes priority."
1,Turn off address translation and confirm regions are no longer being remapped.
1,Purposely create an ibex exception during execution through reads to an ummapped address.
1,Ensure the rstmgr fault dump correctly captures the related addresses to the exception.
1,"Purposely create an ibex double exception during execution, by performing an unmapped read and in the exception handler perform another unmapped read."
1,Ensure the rstmgr fault dump correctly captures both dumps correctly and indicates the previous dump is valid.
1,"ROM functional tests test ROM drivers and libraries by exercising these components in the flash stage, launched via the test ROM."
1,"They primarily are tested on the FPGA, however, we ensure they run in DV as well."
1,"In addition to ROM E2E tests, we select at least one (or a few) tests defined in this file to sign, and run via ROM instead of test ROM."
1,We need to ensure our test infrastructure and ROM can boot and run one (or a few) of the same tests our test ROM can.
1,Load a firmware image (bootstrap) through spi input pin to the spi_device memory.
1,SW verifies the integrity of the image upon reception by reading the spi_device memory.
1,It should be possible to transition from every legal state using external clock.
1,"Where it is allowed, transition using internal clocks should also be checked."
1,"After transition, verify that the device is in SCRAP state through LC read."
1,Verify while in SCRAP state: 1)RV JTAG interface is unavailable 2)Ibex is not executing 3)RV_DM is unreachable by the stub CPU.
1,Verify When in TEST_LOCKED state: 1)RV JTAG interface is unavailable 2)Ibex is not executing 3)RV_DM is unreachable by the stub CPU.
1,Initiate the LC transition to one of the test unlock state.
1,Move forward to next valid LC states via JTAG interface or SW interface if CPU is enabled.
1,Verify that the features that should indeed be disabled are indeed disabled.
1,"This concurrency test runs multiple blocks at the same time, to simulate maximum load (power virus test)."
1,Should be combined with low power entry and exit scenarios.
1,The test should be made configurable so that the type of power state and the time spent in a particular power state can be configured via a flag (or similar).
1,This will make it easier to reuse the test for power simulation and characterization later on.
1,The test should set a GPIO (mapped to the IOA2 pin) to high while the power state of interest is active.
1,The test should be made configurable so that the type of power state and the time spent in a particular power state can be configured via a flag (or similar).
1,This will make it easier to reuse the test for power simulation and characterization later on.
1,The test should set a GPIO (mapped to the IOA2 pin) to high while the power state of interest is active.
1,Pre-load the device into TEST_UNLOCKED state and ROM_EXEC_EN=0.
1,"In the same power cycle, advance device to PROD, PROD_END or DEV through LC JTAG request and set ROM_EXEC_EN in OTP to logically true."
1,"Reboot the device and perform boot strap of a simple image, (e.g Hello World)."
1,"In the test program, populate the scramble seeds (flash / sram)."
1,"In the test program, populate OTP entries to inform ROM to scramble flash upon next boot."
1,"Reboot the device and perform boot strap of the same test image, ROM should now program the flash image with scramble enabled."
1,"Upon successful boot strap, ROM jumps to the newly programmed image and de-scrambles the instructions."
1,"In the test program, check whether the OTP partition containing the scramble seeds is locked."
1,Also check that the unscrambled value progarmmed into flash isolated partition can be correctly read back when the region is set to scramble disable.
1,"If either of the above checks is incorrect, return error."
1,Drive back-to-back requests without waiting for response to ensure there is one transaction outstanding within the TL device.
1,"Also, verify one outstanding when backto-back accesses are made to the same address."
1,Access CSR with one or more bytes of data.
1,"For read, expect to return all word value of the CSR."
1,"For write, enabling bytes should cover all CSR valid fields."
1,Ensure DUT returns d_error=1 if address is unmapped and transaction isn't passed down to any device.
1,"Drive any random value on size, mask, opcode in both channels."
1,Ensure everything just pass through host to device or device to host.
1,"Randomly pick a device, make all hosts to access this device."
1,"If the device isn't accessible for the host, let the host randomly access the other devices."
1,"Inject reset while stress_all is running, after reset is completed, kill the stress seq and then start a new stress seq."
1,Run a few iteration to ensure reset doesn't break the design.
1,Verify that ROM can boot a ROM_EXT with default infrastructure configurations.
1,"The valid ROM_EXT should be a test program that returns true, optimizing for speed."
1,"Verify that we can receive the 28 character long (BFV:xxxxxxxx\r\nLCV:xxxxxxxx\r\n) error output in all life cycle states where Ibex is enabled, i.e."
1,"TEST_UNLOCKED*, PROD, PROD_END, DEV, and RMA."
1,Verify that there is no redaction in TEST_UNLOCKED* and RMA.
1,ROM_EXT needs to print something and busy loop (bounded) until watchdog resets the chip.
1,Verify that the chip does not reset in TEST and RMA.
1,Verify that the chip resets when the WATCHDOG_BITE_THRESHOLD_CYCLES OTP item is 0x00061a80 (2 s).
1,Power on with the CREATOR_SW_CFG_ROM_EXEC_EN OTP item set to 0.
1,"Set pc to 0x10000000 (start of main SRAM) and execute one machine instruction, i.e."
1,Verify that execution stops at _asm_exception_handler since code execution from SRAM is not enabled.
1,Continue and verify that the asm exception handler resets the chip by confirming that execution halts at _rom_start_boot.
1,Boot a valid fake ROM_EXT that doesn't register any interrupt handlers.
1,"Set pc to 0x10000000 (start of main SRAM), this should trigger an exception since code execution from SRAM is not enabled."
1,"Verify that the chip resets with the correct BFV: 01495202, i.e."
1,instruction access fault in the interrupt module.
1,"For PROD, PROD_END, DEV, and RMA life cycle states, use an OTP image with an alert enabled."
1,Boot a ROM_EXT that triggers this alert by writing to a ALERT_TEST register.
1,Verify that ROM_EXT boots and the chip resets after the write to the ALERT_TEST register.
1,Verify that the chip responds to READ_STATUS (0x05) with 0x00.
1,Verify that the chip outputs the expected BFV: 0142500d over UART.
1,ROM will continously reset the chip and output the same BFV.
1,Verify that the chip does not respond to READ_SFDP (0x5a).
1,Verify that ROM does not enter bootstrap when disabled in OTP but requested.
1,Verify that ROM does not enter bootstrap when disabled in OTP and not requested.
1,Do not apply bootstrap pin strapping.
1,Verify that the chip outputs the expected BFV: 0142500d over UART.
1,ROM will continously reset the chip and output the same BFV and LCV.
1,Verify that the chip does not respond to READ_STATUS (0x05).
1,The data on the CIPO line must be 0xff.
1,Apply bootstrap pin strapping.
1,Verify that the chip responds to READ_SFDP (0x5a) correctly.
1,Release bootstrap pin strapping and wait for 2 seconds.
1,Verify that the chip responds to READ_SFDP (0x5a) correctly.
1,Verify that there was no output from UART.
1,Verify that the chip responds to READ_STATUS (0x05) with 0x00.
1,"Verify that the chip responds with the WEL bit set, i.e."
1,Apply bootstrap pin strapping and reset the chip.
1,Write 0x4552544f_00000000 (ASCII \0\0\0\0OTRE) at byte offset 0x80330.
1,Write the ROM_EXT images to the chip -same security_version.
1,"Verify that ROM chooses the slot with the valid signature, otherwise triggers a shutdown."
1,"Repeat for all life cycle states: TEST, DEV, PROD, PROD_END, and RMA."
1,Prepare a ROM_EXT image with a valid signature generated using an authorized key.
1,Apply bootstrap pin strapping and reset the chip and load the image.
1,"Verify that ROM can be debugged in TEST, DEV, and RMA life cycle states."
1,Connect a debugger and verify that ROM halts very early in rom_start.S.
1,"CREATOR_SW_CFG_MIN_SEC_VER_ROM_EXT OTP item should be 0, and CREATOR_SW_CFG_DEFAULT_BOOT_DATA_IN_PROD should be kHardenedBoolTrue for PROD and PROD_END for the sake of simplicity."
1,"CREATOR_SW_CFG_ROM_EXEC_EN should be set to 0 and the chip should in a life cycle state where debugging is enabled, i.e."
1,"If CREATOR_SW_CFG_AST_INIT_EN is set to kMultiBitBool4True, check that the AST_INIT_DONE signal is correctly set to 1 in sensor_ctrl once the AST initialization is complete."
1,CREATOR_SW_CFG_RET_RAM_RESET_MASK should be 1 << 3 so that ROM initializes the retention SRAM after a SW reset request.
1,Verify that ROM correctly configures the ePMP region for debug ROM.
1,"ePMP Debug ROM region should be enabled in TEST, DEV, and RMA, anddisabled in PROD and PROD_END."
1,"In DEV, PROD, and PROD_END, the threshold should be OWNER_SW_CFG_ROM_WATCHDOG_BITE_THRESHOLD_CYCLES if greater than or equal to kWatchdogMinThreshold, disabled otherwise."
1,Verify that a failed sec_mmio check triggers an illegal instruction exception.
1,Verify that ROM initializes the data structures in the .static_critical section properly.
1,"Verify clock connectivity between AST and other blocks in the system, excluding clkmgr connections."
1,"Verify the connectivity of power-related signals between AST and other blocks in the system, excluding power manager."
1,Verify that the Ibex and alert_handler crashdump outputs are correctly connected to the rstmgr.
1,Verify CSRNG produces the deterministic seed leading to an all-zero output of the AES masking PRNG.
1,Configure EDN to perform a CSRNG instantiate followed by repeated generate and reseed commands using the maximum amount of additional data and no entropy input in automatic mode.
1,Let CSRNG produce and forward to EDN the deterministic seed leading to an all-zero output of the AES masking PRNG.
1,Configure an AES key of which the second share is zero.
1,Trigger a reseed operation of the masking PRNG inside AES to load the deterministic seed produced by CSRNG and distributed by EDN.
1,"Verify that the second share of the initial, intermediate and output state is zero."
1,Verify that the second share of the SubBytes input and output is zero.
1,Verify the transmission of single-ended data over the USB at full speed.
1,"As a part of this test, the enablement of USB pullup is also expected to be verified."
1,"This test extends from chip_usb_fs_df_tx_rx, add below at the end of the sequence."
1,"This test extends from chip_usb_fs_df_tx_rx, add below at the end of the sequence."
1,Configure USB device to enter Suspend state and ensure link_suspend interrupt is triggered.
1,"When regwen=1, a different value is written to the lockable CSR field, and a read occurs after that."
1,"When regwen=0, a different value is written to the lockable CSR field, and a read occurs after that."
1,"In iteration 1, do not issue the life cycle rma command."
1,ROM should timeout on spin cycles and automatically reset the device.
1,Check to ensure device has reset via backdoor CSR.
1,"In iteration 2, issue the life cycle RMA command and ensure RMA transition can be successfully completed."
1,Backdoor load a valid test ROM image and bring the DUT out of reset.
1,"During the ROM checker pwrmgr FSM state, while the ROM controller is actively sending data to KMAC for the digest computation, glitch the KMAC app sparse FSM to trigger a fault."
1,A RISC-V hart can be halted when a software breakpoint instruction is executed.
1,The Debug Module own state and registers should only be reset at power-up and while dmactive in dmcontrol is 0.
1,"The debugger can discover the mapping between hart indices and mhartid by using the interface to read mhartid, or by reading the system configuration string."
1,The nth bit in the Hart Array Mask register applies to the hart with index n.
1,If the bit is 1 then the hart is selected.
1,"When a debugger writes 1 to haltreq, each selected hart halt request bit is set."
1,"When a debugger writes 1 to resumereq, each selected hart resume ack bit is cleared and each selected, halted hart is sent a resume request."
1,"When a hart halt-on-reset request bit is set, the hart will immediately enter debug mode on the next deassertion of its reset."
1,"The hart halt-on-reset request bit remains set until cleared by the debugger writing 1 to clrresethaltreq while the hart is selected, or by DM reset."
1,"If a command has unsupported options set, the DM must set cmderr to 2."
1,"Before starting an abstract command, a debugger must ensure that haltreq, resumereq, and ackhavereset are all 0."
1,"If write is set and transfer is set, then copy data from the arg0 region of data into the register specified by regno, and perform any side effects that occur when this register is written from M-mode."
1,"If an exception occurs, cmderr is set to exception and the program buffer execution ends, but the quick access command continues."
1,"Copy data from the memory location specified in arg1 into the arg0 portion of data, if write is clear."
1,"Copy data from the arg0 portion of data into the memory location specified in arg1, if write is set."
1,"While these programs are executed, the hart does not leave Debug Mode (see Section 4.1)."
1,"If an exception is encountered during execution of the Program Buffer, no more instructions are executed, the hart remains in Debug Mode, and cmderr is set to 3 (exception error)."
1,"If the debugger executes a program that does not terminate with an ebreak instruction, the hart will remain in Debug Mode and the debugger will lose control of the hart."
1,"All DM registers should read 0, while writes should be ignored, with the following mandatory exceptions."
1,"bit 0 refers to hart hawindowsel â 32, while bit 31 refers to hart hawindowsel â 32 + 31."
1,"When the system bus master is busy, writes to this register will set sbbusyerror and do not do anything else."
1,"When the system bus master is busy, writes to this register will set sbbusyerror and do not do anything else."
1,"When the system bus master is busy, writes to this register will set sbbusyerror and do not do anything else."
1,"When the system bus master is busy, writes to this register will set sbbusyerror and do not do anything else."
1,If sberror or sbbusyerror both are not 0 then accesses do nothing.
1,"If the bus master is busy then accesses set sbbusyerror, and do not do anything else."
1,"If the bus master is busy then accesses set sbbusyerror, and do not do anything else."
1,"If the bus master is busy then accesses set sbbusyerror, and do not do anything else."
1,"If the bus master is busy then accesses set sbbusyerror, and do not do anything else."
1,"If one such instruction acts as an illegal instruction, all such instructionsmust act as an illegal instruction."
1,"If halt is requested while wfi is executing, then the hart must leave the stalled state, completing this instruction execution, and then enter Debug Mode."
1,"If the halt signal (driven by the halt request bit in the Debug Module) or resethaltreq are asserted when a hart comes out of reset, the hart must enter Debug Mode before executing any instructions, but after performing any initialization that would usually happen before the first instruction is executed."
1,"When resuming, the PC of hart is updated to the virtual address stored in dpc."
1,"(If type is 0, this trigger does not exist."
1,This ensures both that the presence of an external debugger does not affect execution and that a trigger set by user code does not affect the external debugger.
1,"In the latter case, hit of the trigger whose action is 0 must still be set, giving a debugger an opportunity to handle this case."
1,"On a fully featured system triggers will be set using u or s, and when firing they can cause a breakpoint exception to trap to a more privileged mode."
1,The trigger registers are only accessible in machine and Debug Mode to prevent untrusted user code from causing entry into Debug Mode without the permission of OS.
1,"If the hardware limits count to 1, and changes mode bits instead of decrementing count, this register can be implemented with just 2 bits."
1,"If the IR actually has more than 5 bits, then the encodings in Table 6.1 should be extended with 0s in their most significant bits."
1,"In Update-DR, the DTM starts the operation specified in op unless the current status reported in op is sticky."
1,"In Capture-DR, the DTM updates data with the result from that operation, updating op if the current op is not sticky."
1,In the park loop the hart writes its mhartid to a memory location within the Debug Module to indicate that it is halted.
1,"If the operation did not complete in time, op will be 3 and the value in data must be ignored."
1,"To write an arbitrary Debug Bus register, select dmi, and scan in a value with op set to 2, and address and data set to the desired register address and data respectively."
1,"Multibit life cycle hardware debug enable signal coming from life cycle controller, asserted when the hardware debug mechanisms are enabled in the system."
1,It is used to keep a debug session live while the rest of the system undergoes an NDM reset.
1,"The debug system is able to reset the system through its JTAG connection; the non-debug module reset (ndmreset_req_o) signals this intent.If needed, a request to the entropy source hardware interface will be made."
1,This step can take milliseconds if seed entropy is not immediately available.
1,"Once all of the prerequisites have been collected, a CTR_DRBG command can be launched."
1,"If the command is a generate, the ctr_drbg_cmd block will process the first half of the algorithm, and then pass it on to the ctr_drbg_gen block."
1,"Additionally, the ctr_drbg_gen block also uses the update block and the block_encrypt block."
1,"When the state_db block issues an ack to the cmd_stage block, the cmd_stage block increments an internal counter."
1,This process repeats until the glen field value has been matched.
1,"The commands supported are instantiate, reseed, generate, update, and uninstantiate."
1,Each application interface port used by peripheral hardware commands a unique instance number in CSRNG.
1,A value of zero will only transfer the command header.
1,A value of 4'hc will transfer the header plus an additional twelve 32-bit words of data.
1,Setting this field to kMultiBitBool4True will enable flag0 to be enabled.
1,"Note that flag0 is used for the instantiate and reseed commands only, for all other commands its value is ignored."
1,"The NIST reference name is max_number_of_bit_per_request, and this field size supports the maximum size of 219 bits."
1,"When seeding, the following table describes how the seed is determined based on flag0 and the clen field."
1,"Though flag0 may be useful for generating fully-deterministic bit sequences, the use of this flag will render the instance non-FIPS compliant until it is re-instantiated."
1,"When the Instantiate command is completed, the active bit in the CSRNG working state will be set."
1,"If both a seed and additional data must be provided to the Reseed command, the seed and additional data must be xor'ed first."
1,Note that additional data is also supported when the clen field is set to non-zero.
1,"When the Update command is completed, the results will be reflected in the CSRNG working state."
1,"When the Uninstantiate command is completed, the Status bit in the CSRNG working state will be cleared."
1,"Uninstantiating an instance effectively resets it, clearing any errors that it may have encountered due to bad command syntax or entropy source failures."
1,"Only a value of zero should be used for clen, since any additional data will be ignored."
1,"If the command is successful, the csrng_rsp_sts signal will indicate the value 0 (CSRNG_OK) in the same cycle."
1,Otherwise the application will receive the value 1 (CSRNG_ERROR) on the csrng_rsp_sts signal.
1,"If flag0 is asserted during instantiation, the resulting DRBG instance will have a fully-deterministic seed, determined only by user input data."
1,"The application command signal csrng_req_bus is accompanied by a csrng_valid_signal, which is asserted by the requester when the command is valid."
1,"Likewise a requester must only consider data on the genbits bus to be valid when the genbits_valid signal is asserted, and should assert genbits_ready whenever it is ready to accept the genbits data."
1,The cs_cmd_req_done interrupt will assert when a CSRNG command has been completed.
1,The cs_entropy_req interrupt will assert when CSRNG requests entropy from ENTROPY_SRC.
1,"The cs_hw_inst_exc interrupt will assert when any of the hardware-controlled CSRNG instances encounters an exception while executing a command, either due to errors on the command sequencing, or an exception within the ENTROPY_SRC IP."
1,The cs_fatal_err interrupt will assert when any of the CSRNG FIFOs has a malfunction.
1,The conditions that cause this to happen are either when there is a push to a full FIFO or a pull from an empty FIFO.
1,CSRNG may only be disabled if all EDNs are disabled.
1,This application interface for software (register based) will be enabled only if the otp_en_csrng_sw_app_read input vector is set to the enable encoding.
1,Reading the internal state of the enable instances will be enabled only if the otp_en_csrng_sw_app_read input vector is set to the enable encoding.
1,The application interface must wait for the ack to return before issuing new commands.
1,Reading this register indicates whether one of the CSRNG HW instances has encountered an exception.
1,"Each bit corresponds to a particular hardware instance, with bit 0 corresponding to instance HW0, bit 1 corresponding to instance HW1, and so forth."
1,Writing a zero to this register resets the status bits.
1,This bit is set when the ENABLE field in the CTRL register is set to a value other than kMultiBitBool4True or kMultiBitBool4False.
1,This bit is set when an unsupported CSRNG command is being processed.
1,The main FSM will hang unless the module enable field is set to the disabled state.
1,This bit will be set to one when an illegal state has been detected for the ctr_drbg update out block state machine.
1,"This error will signal a fatal alert, and also an interrupt if enabled."
1,This bit will be set to one when an illegal state has been detected for the ctr_drbg update block encode state machine.
1,"This error will signal a fatal alert, and also an interrupt if enabled."
1,"If enabled, the device constantly transmits a J/K pattern, which is useful for testing the USB clock."
1,"Note that if a rxenable_setup is set for this endpoint's number, this bit will not take effect."
1,If this bit is set then the endpoint will be treated as an isochronous endpoint.
1,This bit will also be cleared if an enabled SETUP transaction is received on the endpoint.
1,It will be cleared when the ACK is received indicating the host has accepted the data.
1,"If this bit is set then an OUT transaction to this endpoint will elicit a STALL handshake, when a non-isochronous endpoint is enabled."
1,"If the configuration has both STALL and NAK enabled, the STALL handshake will take priority."
1,"If this bit is set then an OUT transaction to this endpoint will elicit a STALL handshake, when a non-isochronous endpoint is enabled."
1,"If the configuration has both STALL and NAK enabled, the STALL handshake will take priority."
1,If the bit is clear then a SETUP packet will be ignored.
1,The bit should be set for control endpoints (and only control endpoints).
1,"If the bit is clear then an OUT request will be responded to with a NAK, if the endpoint is enabled."
1,"If set_nak_out for this endpoint is set, hardware will clear this bit whenever an OUT transaction is received on this endpoint."
1,Software must set this bit again to receive the next OUT transaction.
1,"Until that happens, hardware will continue to NAK any OUT transaction to this endpoint."
1,If the bit is clear then a SETUP packet will be ignored.
1,If the bit is clear then any IN packets sent to the endpoint will be ignored.
1,The write will only have an effect when the device is in the LinkPowered state.
1,This will be zeroed by the hardware when the link resets.
1,It should be cleared only after clearing all bits in the in_sent register.
1,"This interrupt is directly tied to whether the RX FIFO is empty, so it should be cleared only after handling the FIFO entry."
1,"To support this, software sets the in_stall and out_stall register for an endpoint when the host requests an unsupported transfer."
1,"In the case of a protocol stall, the device must send a STALL for all IN/OUT requests until the next SETUP token is received."
1,"If either a control endpoints set_nak_out bit is set or software has cleared the rxenable_out bit before this transfer began, the hardware will send NAKs to any IN/OUT requests until the software has decided what action to take for the new SETUP request."
1,"Software must remember the pending transmission and, after the Control transaction is complete, write it back to the configin register with the rdy bit set."
1,"If a SETUP transaction is received on a control endpoint that has a transmission pending, the hardware will clear the rdy bit and set the pend bit in the configin register of that endpoint."
1,"When the packet transmission has been noted by software, the corresponding endpoint bit should be cleared in the in_sent register (by writing a 1 to this very bit)."
1,"If the host does not ACK the data, the packet will be retried."
1,The CRC bytes are written to the buffer if they fit within the maximum buffer size.
1,The host will only generate IN requests if the endpoint is declared as an IN endpoint in its Endpoint Descriptor (note that two descriptors are needed if the same endpoint is used for both IN and OUT transfers).
1,A pkt_received interrupt is raised whenever there are one or more packets in the Received Buffer FIFO.
1,"Software should pop the information from the Received Buffer FIFO by reading the rxfifo register, which gives (1) the buffer ID that the data was received in, (2) the data length received in bytes, (3) the endpoint to which the packet was sent, and (4) an indication if the packet was sent with an OUT or SETUP transaction."
1,"If this does not indicate OUT packet reception is enabled, then any OUT packet will receive a NAK to request a retry later."
1,The status stage of the Set Configuration request should not be allowed to complete until all endpoints are set up.
1,"When a Set Address request is received, the device ID received must be stored in the usbctrl.device_address register."
1,"Note that device 0 is used for the entire control transaction setting the new device ID, so writing the new ID to the register should not be done until the ACK for the Status stage has been received (see USB 2.0 specification)."
1,"When the host next does an IN transaction to that endpoint, the data will be sent from the buffer."
1,"A Control transfer requires one or more IN transactions, either during the data stage or the status stage."
1,"Therefore, when a SETUP transaction is received for an endpoint, any buffers that are waiting to be sent out to the host from that endpoint are canceled by clearing the rdy bit in the corresponding configin register."
1,The transfer must be queued again after the Control transfer is completed.
1,"On receipt of the ACK from the host, the rdy bit in the configin register will be cleared, and the bit corresponding to the endpoint ID will be set in the in_sent register causing a pkt_sent interrupt to be raised."
1,Software can return the buffer to the free pool and write a 1 to clear the endpoint bit in the in_sent register.
1,Note that streaming can be achieved if the next buffer has been prepared and is written to the configin register when the interrupt is received.
1,"If set_nak_out is 1 for the endpoint, it will clear its corresponding bit in the rxenable_out register, forcing NAK responses to OUT transactions to that endpoint until software can intervene."
1,"If set_nak_out is 0 for the endpoint, it will accept packets as long as there are buffers available in the Available Buffer FIFO and space available in the Received Buffer FIFO."
1,"If the packets cannot be consumed at the rate they are received, software can implement selective flow control by clearing rxenable_out for a particular endpoint, which will result in a request to that endpoint being NAKed (negative acknowledgment)."
1,"If the packet is correctly received, an ACK is returned to the host."
1,It should be cleared only after clearing all bits in the in_sent register.
1,"This interrupt is directly tied to whether the RX FIFO is empty, so it should be cleared only after handling the FIFO entry."
1,"Because this is a Full-Speed device the resistor must be on the D+ pin, so when pinflip is zero, dp_pullup_o is used."
1,"These signals are used to detect the SE0 link state, and if a differential receiver is not present, they are also used for K and J symbols."
1,They can be forced to zero by setting phy_config.usb_ref_disable to 1.
1,The RX mode can be selected to use a differential receivers output by setting the use_diff_rcvr bit in phy_config.
1,"When dp_pullup_o or dn_pullup_o asserts a 1.5k pullup resistor should be connected to D+ or D-, respectively."
1,It is enabled via a CSR and automatically disabled when the device suspends.
1,It may do a hard reset of a port by removing and reasserting VBUS (the Linux driver will do this when it finds a port in an inconsistent state or a port that generates errors during enumeration).
1,This pin is always an input and should be externally connected to detect the state of the VBUS.
1,The IP block produces a signal dp_pullup_o that is asserted when this resistor should be presented.
1,This signal will be asserted whenever the interface is enabled and VBUS is present.
1,"If the pinflip bit in phy_config is set, the data pins are flipped internally, meaning the 1.5k pullup resistor needs to be on the external Dline."
1,This error is raised if either the packet or CRC is invalid or a different token was received.
1,"This error is raised if either the data toggle, token, packet or CRC is invalid or if there is no buffer available in the Received Buffer FIFO."
1,This fatal alert is triggered when a fatal TL-UL bus integrity fault is detected.
1,The link is reset whenever the D+ and Dare both low (an SE0 condition) for an extended period.
1,"The host will assert reset for a minimum of 10 ms, but the USB specification allows the device to detect and respond to a reset after 2.5 us."
1,The link is suspended when at idle (a J condition) for more than 3 ms.
1,An interrupt is generated when the suspend is detected and a resume interrupt is generated when the link exits the suspend state.
1,"This state is entered, if the device has not been reset yet."
1,"When the host ACKs the data, the rdy bit is cleared, the corresponding endpoint bit is set in the in_sent register, and a pkt_sent interrupt is raised."
1,This error is raised if either the packet or CRC is invalid or a different token was received.
1,"This error is raised if either the data toggle, token, packet or CRC is invalid or if there is no buffer available in the Received Buffer FIFO."
1,Write a 1 to this bit to instruct usbdev to jump to the LinkResuming state.
1,"If the Available Buffer FIFO is full, any write operations are discarded."
1,If this is 0 then a CRC only packet is sent.
1,If this is greater than 64 then 64 bytes are sent.
1,The bit is set when the rdy bit is cleared by hardware because of a SETUP packet being received or a link reset being detected.
1,The bit remains set until cleared by being written with a 1.
1,Writing 1 to this bit will clear the data toggle bit for this endpoint to Data0 in both IN and OUT directions.
1,The register must no be written again within 200 ns.
1,Writing 1 to this bit will clear the data toggle bit for this endpoint to Data0 in both IN and OUT directions.
1,"Detect received K and J symbols from the usb_rx_d signal, which must be driven from an external differential receiver."
1,"If 1, make use of the usb_rx_d input."
1,"If 0, the usb_rx_d input is ignored and the usb_rx_dp and usb_rx_dn pair are used to detect K and J ."
1,"If 1, select the d and se0 TX interface."
1,"If 0, select the dp and dn TX interface."
1,"0: Enable reference signal generation for clock synchronization, 1: disable it by forcing the associated signals to zero."
1,Trigger the wake detection module to begin monitoring for wake-from-suspend events.
1,"When written with a 1, the wake detection module will activate."
1,"rst_por_n -> rst_sys_n -> rst_module_n This means when a particular reset asserts, all downstream resets also assert."
1,"The primary difference between rst_lc_n and rst_sys_n is that the former controls the reset state of most logic in the system, while the latter controls the reset state only of the debug domain."
1,This separation is required because the debug domain may request the system to reset while retaining debug info and control.
1,"This is particularly useful if one wanted to debug something early during the boot flow, and thus needed to set a break point after requesting a debug reset."
